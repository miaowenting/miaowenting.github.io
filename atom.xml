<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Matty&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-10T05:58:06.371Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>miaowenting</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flink源码剖析-flink-table-runtime-blink_TopN</title>
    <link href="http://yoursite.com/2020/09/30/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-flink-table-runtime-blink-TopN/"/>
    <id>http://yoursite.com/2020/09/30/Flink源码剖析-flink-table-runtime-blink-TopN/</id>
    <published>2020-09-30T08:35:54.000Z</published>
    <updated>2020-10-10T05:58:06.371Z</updated>
    
    <content type="html"><![CDATA[<p>本文将基于 flink <code>release-1.11</code> 源码，简单分析下 TopN function 的实现。</p><a id="more"></a><p><img src="TopNFunction%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p><h2 id="AbstractTopNFunction"><a href="#AbstractTopNFunction" class="headerlink" title="AbstractTopNFunction"></a>AbstractTopNFunction</h2><p>AbstractTopNFunction 中有如下属性，定义 sortKey selector 和 comparator，rankEnd 相关参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// we set default topN size to 100</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_TOPN_SIZE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The util to compare two sortKey equals to each other.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 sortKey 比较器实例类的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> GeneratedRecordComparator generatedSortKeyComparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sortKey 比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Comparator&lt;RowData&gt; sortKeyComparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> generateUpdateBefore;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否输出排序序号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> outputRankNumber;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> RowDataTypeInfo inputRowType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key selector，选择 RowData 中的哪一个字段来排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> KeySelector&lt;RowData, RowData&gt; sortKeySelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key 上下文，获取当前处理数据的 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> KeyContext keyContext;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是固定的 TopN 集合大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isConstantRankEnd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rankStart 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> rankStart;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rankEnd 在 RowData 中的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rankEndIndex;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rankEnd 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> rankEnd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java.util.Function，从 RowData 的某一个位置获取 rankEnd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Function&lt;RowData, Long&gt; rankEndFetcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录 rankEnd，可能随着输入数据动态变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ValueState&lt;Long&gt; rankEndState;</span><br><span class="line"><span class="keyword">private</span> Counter invalidCounter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 TopN 需要输出排位序号时，会用到这个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> JoinedRowData outputRow;</span><br><span class="line"></span><br><span class="line"><span class="comment">// metrics</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> hitCount = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0L</span>;</span><br></pre></td></tr></table></figure><p>AbstractTopNFunction 的 <code>open()</code> 方法主要从状态后端获取 rankEndState，并初始化类属性： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.open(parameters);</span><br><span class="line">initCleanupTimeState(<span class="string">"RankFunctionCleanupTime"</span>);</span><br><span class="line">outputRow = <span class="keyword">new</span> JoinedRowData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isConstantRankEnd) &#123;</span><br><span class="line"><span class="comment">// 从状态后端读取当前 rankEnd 值</span></span><br><span class="line">ValueStateDescriptor&lt;Long&gt; rankStateDesc = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">"rankEnd"</span>, Types.LONG);</span><br><span class="line">rankEndState = getRuntimeContext().getState(rankStateDesc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// compile comparator</span></span><br><span class="line"><span class="comment">// classLoader 加载 key comparator 类</span></span><br><span class="line">sortKeyComparator = generatedSortKeyComparator.newInstance(getRuntimeContext().getUserCodeClassLoader());</span><br><span class="line"><span class="comment">// 把确定不需要的对象直接赋值为 null</span></span><br><span class="line">generatedSortKeyComparator = <span class="keyword">null</span>;</span><br><span class="line">invalidCounter = getRuntimeContext().getMetricGroup().counter(<span class="string">"topn.invalidTopSize"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize rankEndFetcher</span></span><br><span class="line"><span class="keyword">if</span> (!isConstantRankEnd) &#123;</span><br><span class="line">LogicalType rankEndIdxType = inputRowType.getLogicalTypes()[rankEndIndex];</span><br><span class="line"><span class="keyword">switch</span> (rankEndIdxType.getTypeRoot()) &#123;</span><br><span class="line"><span class="keyword">case</span> BIGINT:</span><br><span class="line">rankEndFetcher = (RowData row) -&gt; row.getLong(rankEndIndex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> INTEGER:</span><br><span class="line">rankEndFetcher = (RowData row) -&gt; (<span class="keyword">long</span>) row.getInt(rankEndIndex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SMALLINT:</span><br><span class="line">rankEndFetcher = (RowData row) -&gt; (<span class="keyword">long</span>) row.getShort(rankEndIndex);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">LOG.error(<span class="string">"variable rank index column must be long, short or int type, while input type is &#123;&#125;"</span>,</span><br><span class="line">rankEndIdxType.getClass().getName());</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="string">"variable rank index column must be long type, while input type is "</span> +</span><br><span class="line">rankEndIdxType.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractTopNFunction 的 <code>initRankEnd()</code> 方法根据 input row 来动态获取 rankEnd ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize rank end.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> row input record</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> rank end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">initRankEnd</span><span class="params">(RowData row)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isConstantRankEnd) &#123;</span><br><span class="line"><span class="keyword">return</span> rankEnd;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Long rankEndValue = rankEndState.value();</span><br><span class="line"><span class="keyword">long</span> curRankEnd = rankEndFetcher.apply(row);</span><br><span class="line"><span class="keyword">if</span> (rankEndValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">rankEnd = curRankEnd;</span><br><span class="line"><span class="comment">// 同步更新到状态后端</span></span><br><span class="line">rankEndState.update(rankEnd);</span><br><span class="line"><span class="keyword">return</span> rankEnd;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rankEnd = rankEndValue;</span><br><span class="line"><span class="keyword">if</span> (rankEnd != curRankEnd) &#123;</span><br><span class="line"><span class="comment">// increment the invalid counter when the current rank end not equal to previous rank end</span></span><br><span class="line">invalidCounter.inc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rankEnd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractTopNFunction 的 <code>checkSortKeyInBufferRange()</code> 方法来判断 input row 是否应该被放到其 key 对应的 TopBuffer 中：</p><ol><li>将 input row 与 TopBuffer 中的最后一个 entry 比较，comparator 返回 true 则将 input row 丢到 TopBuffer 中；</li><li>comparator 返回 false，当前 TopBuffer 中的 entry 个数还没有达到默认的 TopN size，也将 input row 丢到 TopBuffer 中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks whether the record should be put into the buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sortKey sortKey to test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buffer  buffer to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the record should be put into the buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkSortKeyInBufferRange</span><span class="params">(RowData sortKey, TopNBuffer buffer)</span> </span>&#123;</span><br><span class="line">Comparator&lt;RowData&gt; comparator = buffer.getSortKeyComparator();</span><br><span class="line">Map.Entry&lt;RowData, Collection&lt;RowData&gt;&gt; worstEntry = buffer.lastEntry();</span><br><span class="line"><span class="keyword">if</span> (worstEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// return true if the buffer is empty. TopNBuffer 是空的，直接返回 true</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">RowData worstKey = worstEntry.getKey();</span><br><span class="line"><span class="comment">//执行 TopN 比较器</span></span><br><span class="line"><span class="keyword">int</span> compare = comparator.compare(sortKey, worstKey);</span><br><span class="line"><span class="keyword">if</span> (compare &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 如果满足条件，可以放到 TopNBuffer 中</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 到达的数据条数还没有达到默认的 TopN 大小 100，也可以放到 TopNBuffer 中</span></span><br><span class="line"><span class="keyword">return</span> buffer.getCurrentTopNum() &lt; getDefaultTopNSize();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>AbstractTopNFunction 的 <code>createOutputRow()</code> 方法用于构建 output row，区分带不带 rank 序号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建 output row</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputRow input row</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rank     排位序号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowKind  描述一行 changelog 的行为种类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> RowData&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RowData <span class="title">createOutputRow</span><span class="params">(RowData inputRow, <span class="keyword">long</span> rank, RowKind rowKind)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (outputRankNumber) &#123;</span><br><span class="line"><span class="comment">// 需要输出 rank number</span></span><br><span class="line">GenericRowData rankRow = <span class="keyword">new</span> GenericRowData(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 第 0 个字段设置为排位序号，将 rank 专门放置在一个 RowData 中</span></span><br><span class="line">rankRow.setField(<span class="number">0</span>, rank);</span><br><span class="line"></span><br><span class="line">outputRow.replace(inputRow, rankRow);</span><br><span class="line">outputRow.setRowKind(rowKind);</span><br><span class="line"><span class="keyword">return</span> outputRow;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">inputRow.setRowKind(rowKind);</span><br><span class="line"><span class="keyword">return</span> inputRow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AppendOnlyTopNFunction"><a href="#AppendOnlyTopNFunction" class="headerlink" title="AppendOnlyTopNFunction"></a>AppendOnlyTopNFunction</h2><p>AppendOnlyTopNFunction 中有如下属性，状态后端 MapState 和本地堆内存 TopNBuffer 结合使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sortKey 字段类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RowDataTypeInfo sortKeyType;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * input row 的序列化类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeSerializer&lt;RowData&gt; inputRowSer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> cacheSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a map state stores mapping from sort key to records list which is in topN</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sortKey &lt;-&gt; 在 TopN 中的 RowData list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> MapState&lt;RowData, List&lt;RowData&gt;&gt; dataState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the buffer stores mapping from sort key to records list, a heap mirror to dataState</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前 sortKey 对应的 TopNBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> TopNBuffer buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the kvSortedMap stores mapping from partition key to it's buffer</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sortKey &lt;-&gt; TopNBuffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;RowData, TopNBuffer&gt; kvSortedMap;</span><br></pre></td></tr></table></figure><p>AppendOnlyTopNFunction 的 <code>open()</code> 方法中从状态后端中获取当前 key 的 TopN list：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.open(parameters);</span><br><span class="line"><span class="comment">// LRU的缓存大小=总的缓存大小/topN的缓存大小</span></span><br><span class="line"><span class="keyword">int</span> lruCacheSize = Math.max(<span class="number">1</span>, (<span class="keyword">int</span>) (cacheSize / getDefaultTopNSize()));</span><br><span class="line"><span class="comment">// 根据 key 缓存 LRU list</span></span><br><span class="line">kvSortedMap = <span class="keyword">new</span> LRUMap&lt;&gt;(lruCacheSize);</span><br><span class="line">LOG.info(<span class="string">"Top&#123;&#125; operator is using LRU caches key-size: &#123;&#125;"</span>, getDefaultTopNSize(), lruCacheSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 key 记录当前的 TopN list</span></span><br><span class="line"><span class="comment">// RowDataTypeInfo</span></span><br><span class="line">ListTypeInfo&lt;RowData&gt; valueTypeInfo = <span class="keyword">new</span> ListTypeInfo&lt;&gt;(inputRowType);</span><br><span class="line">MapStateDescriptor&lt;RowData, List&lt;RowData&gt;&gt; mapStateDescriptor = <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(</span><br><span class="line"><span class="string">"data-state-with-append"</span>, sortKeyType, valueTypeInfo);</span><br><span class="line">dataState = getRuntimeContext().getMapState(mapStateDescriptor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// metrics</span></span><br><span class="line">registerMetric(kvSortedMap.size() * getDefaultTopNSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppendOnlyTopNFunction 的 <code>processElement()</code> 方法处理数据，判断当前 input row 是否可以丢到 TopNBuffer 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(RowData input, Context context, Collector&lt;RowData&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前时间，记录在上下文的计时器中</span></span><br><span class="line"><span class="keyword">long</span> currentTime = context.timerService().currentProcessingTime();</span><br><span class="line"><span class="comment">// register state-cleanup timer</span></span><br><span class="line">registerProcessingCleanupTimer(context, currentTime);</span><br><span class="line"></span><br><span class="line">initHeapStates();</span><br><span class="line">initRankEnd(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输入的数据中抽取 sortKey</span></span><br><span class="line">RowData sortKey = sortKeySelector.getKey(input);</span><br><span class="line"><span class="comment">// check whether the sortKey is in the topN range</span></span><br><span class="line"><span class="comment">// 根据 sortKey 判断当前数据是否应该被放到 TopNBuffer 中</span></span><br><span class="line"><span class="keyword">if</span> (checkSortKeyInBufferRange(sortKey, buffer)) &#123;</span><br><span class="line"><span class="comment">// insert sort key into buffer</span></span><br><span class="line">buffer.put(sortKey, inputRowSer.copy(input));</span><br><span class="line">Collection&lt;RowData&gt; inputs = buffer.get(sortKey);</span><br><span class="line"><span class="comment">// update data state</span></span><br><span class="line"><span class="comment">// copy a new collection to avoid mutating state values, see CopyOnWriteStateMap,</span></span><br><span class="line"><span class="comment">// otherwise, the result might be corrupt.</span></span><br><span class="line"><span class="comment">// don't need to perform a deep copy, because RowData elements will not be updated</span></span><br><span class="line"><span class="comment">// 同步记录到 MapState 中</span></span><br><span class="line">dataState.put(sortKey, <span class="keyword">new</span> ArrayList&lt;&gt;(inputs));</span><br><span class="line"><span class="keyword">if</span> (outputRankNumber || hasOffset()) &#123;</span><br><span class="line"><span class="comment">// the without-number-algorithm can't handle topN with offset,</span></span><br><span class="line"><span class="comment">// so use the with-number-algorithm to handle offset</span></span><br><span class="line">processElementWithRowNumber(sortKey, input, out);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">processElementWithoutRowNumber(input, out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppendOnlyTopNFunction 的 <code>initHeapStates()</code> 是在处理 input row 之前，在堆内存中初始化 TopNBuffer，并将状态后端存储的 TopN list 设置到 TopNBuffer 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHeapStates</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">requestCount += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 从 KeyContext 中获取当前的key</span></span><br><span class="line">RowData currentKey = (RowData) keyContext.getCurrentKey();</span><br><span class="line"><span class="comment">// 取出 key 对应的 TopNBuffer</span></span><br><span class="line">buffer = kvSortedMap.get(currentKey);</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// buffer 为 null，则为此 key 构建 TopNBuffer，为其设置 key comparator</span></span><br><span class="line">buffer = <span class="keyword">new</span> TopNBuffer(sortKeyComparator, ArrayList::<span class="keyword">new</span>);</span><br><span class="line">kvSortedMap.put(currentKey, buffer);</span><br><span class="line"><span class="comment">// restore buffer</span></span><br><span class="line"><span class="comment">// 读取 state 中记录的 TopN list，塞到这个 TopNBuffer 里</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;RowData, List&lt;RowData&gt;&gt;&gt; iter = dataState.iterator();</span><br><span class="line"><span class="keyword">if</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;RowData, List&lt;RowData&gt;&gt; entry = iter.next();</span><br><span class="line">RowData sortKey = entry.getKey();</span><br><span class="line">List&lt;RowData&gt; values = entry.getValue();</span><br><span class="line"><span class="comment">// the order is preserved</span></span><br><span class="line">buffer.putAll(sortKey, values);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// buffer 不为 null，记录命中一次 TopNBuffer 缓存</span></span><br><span class="line">hitCount += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AppendOnlyTopNFunction 的 <code>processElementWithoutRowNumber()</code> 方法是处理丢到 TopNBuffer 中的 input row，决定这条数据是否被 Delete ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processElementWithoutRowNumber</span><span class="params">(RowData input, Collector&lt;RowData&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// remove retired element</span></span><br><span class="line"><span class="comment">// 当前 TopNBuffer 中缓存的数据条数大于 TopN 的 N</span></span><br><span class="line"><span class="keyword">if</span> (buffer.getCurrentTopNum() &gt; rankEnd) &#123;</span><br><span class="line">Map.Entry&lt;RowData, Collection&lt;RowData&gt;&gt; lastEntry = buffer.lastEntry();</span><br><span class="line">RowData lastKey = lastEntry.getKey();</span><br><span class="line">Collection&lt;RowData&gt; lastList = lastEntry.getValue();</span><br><span class="line">RowData lastElement = buffer.lastElement();</span><br><span class="line"><span class="keyword">int</span> size = lastList.size();</span><br><span class="line"><span class="comment">// remove last one</span></span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 移除最后一个元素</span></span><br><span class="line">buffer.removeAll(lastKey);</span><br><span class="line">dataState.remove(lastKey);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 移除大于 TopN 的 N 之后的元素</span></span><br><span class="line">buffer.removeLast();</span><br><span class="line"><span class="comment">// last element has been removed from lastList, we have to copy a new collection</span></span><br><span class="line"><span class="comment">// for lastList to avoid mutating state values, see CopyOnWriteStateMap,</span></span><br><span class="line"><span class="comment">// otherwise, the result might be corrupt.</span></span><br><span class="line"><span class="comment">// don't need to perform a deep copy, because RowData elements will not be updated</span></span><br><span class="line"><span class="comment">// 更新状态后端</span></span><br><span class="line">dataState.put(lastKey, <span class="keyword">new</span> ArrayList&lt;&gt;(lastList));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span> || input.equals(lastElement)) &#123;</span><br><span class="line"><span class="comment">// input 的数据和 TopNBuffer 中的最后一个元素相同，则直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// lastElement shouldn't be null</span></span><br><span class="line">collectDelete(out, lastElement);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it first appears in the TopN, send INSERT message</span></span><br><span class="line">collectInsert(out, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AppendOnlyTopNFunctionTest"><a href="#AppendOnlyTopNFunctionTest" class="headerlink" title="AppendOnlyTopNFunctionTest"></a>AppendOnlyTopNFunctionTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests for &#123;<span class="doctag">@link</span> AppendOnlyTopNFunction&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppendOnlyTopNFunctionTest</span> <span class="keyword">extends</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractTopNFunction <span class="title">createFunction</span><span class="params">(RankType rankType, RankRange rankRange,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> generateUpdateBefore, <span class="keyword">boolean</span> outputRankNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AppendOnlyTopNFunction(minTime.toMilliseconds(),</span><br><span class="line">maxTime.toMilliseconds(),</span><br><span class="line">inputRowType,</span><br><span class="line">sortKeyComparator,</span><br><span class="line">sortKeySelector,</span><br><span class="line">rankType,</span><br><span class="line">rankRange,</span><br><span class="line">generateUpdateBefore,</span><br><span class="line">outputRankNumber,</span><br><span class="line">cacheSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVariableRankRange</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER,</span><br><span class="line"><span class="comment">// 指定数据的第2个字段值为 rankEnd，动态指定 TopN 集合的大小</span></span><br><span class="line"><span class="keyword">new</span> VariableRankRange(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">true</span>,</span><br><span class="line"><span class="comment">// 不用输出 topN 的排序序号</span></span><br><span class="line"><span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 将 TopNFunction 包装进 KeyedProcessOperator</span></span><br><span class="line">OneInputStreamOperatorTestHarness&lt;RowData, RowData&gt; testHarness = createTestHarness(func);</span><br><span class="line"><span class="comment">// 测试类准备工作</span></span><br><span class="line">testHarness.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// KeyedProcessOperator 作为 input operator 模拟处理数据</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">12</span>)); <span class="comment">// 开始处理(book,2,12)，key 为 book，rankEnd 为 2，加入 TopN 集合</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>)); <span class="comment">// 开始处理(book,2,19)，key 为 book，rankEnd 为 2，加入 TopN 集合</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">11</span>)); <span class="comment">// 开始处理(book,2,11)，key 为 book，rankEnd 为 2，超出 TopN 集合容量，因此需要先删除 (book,2,19)，留下 2 个较小的</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>)); <span class="comment">// 开始处理(fruit,1,33)，key 为 fruit，rankEnd 为 1，加入 TopN 集合</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">44</span>)); <span class="comment">// 开始处理(fruit,1,44)，key 为 fruit，rankEnd 为 1，44 &gt; 33，直接过滤掉</span></span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">22</span>)); <span class="comment">// 开始处理(fruit,1,22)，key 为 fruit，rankEnd 为 1，超出 TopN 集合容量，因此需要先删除 (fruit,1,33)，留下 1 个较小的</span></span><br><span class="line">testHarness.close();</span><br><span class="line"></span><br><span class="line">ConcurrentLinkedQueue&lt;Object&gt; output = testHarness.getOutput();</span><br><span class="line"><span class="keyword">for</span> (Object o : output) &#123;</span><br><span class="line">StreamRecord streamRecord = (StreamRecord) o;</span><br><span class="line">System.out.println(<span class="string">"Output element -&gt; "</span> + streamRecord.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; expectedOutput = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// ("book", 2L, 12)</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">12</span>));</span><br><span class="line"><span class="comment">// ("book", 2L, 19)</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line"><span class="comment">// ("book", 2L, 11)</span></span><br><span class="line">expectedOutput.add(deleteRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">11</span>));</span><br><span class="line"><span class="comment">// ("fruit", 1L, 33)</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line"><span class="comment">// ("fruit", 1L, 44)</span></span><br><span class="line"><span class="comment">// ("fruit", 1L, 22)</span></span><br><span class="line">expectedOutput.add(deleteRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">22</span>));</span><br><span class="line">assertorWithoutRowNumber</span><br><span class="line">.assertOutputEquals(<span class="string">"output wrong."</span>, expectedOutput, testHarness.getOutput());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key 比较器的类加载工具类，生成一个 key 比较器实例</span></span><br><span class="line">    <span class="keyword">static</span> GeneratedRecordComparator sortKeyComparator = <span class="keyword">new</span> GeneratedRecordComparator(<span class="string">""</span>, <span class="string">""</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1434685115916728955L</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RecordComparator <span class="title">newInstance</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// compare(RowData o1, RowData o2) 方法中比较 o1 和 o2 的第 0 个元素，从小到大比较</span></span><br><span class="line"><span class="keyword">return</span> IntRecordComparator.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sortKeyIdx = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 选择器，比较 RowData 中的第 2 位置的元素</span></span><br><span class="line">BinaryRowDataKeySelector sortKeySelector = <span class="keyword">new</span> BinaryRowDataKeySelector(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sortKeyIdx&#125;,</span><br><span class="line">inputRowType.getLogicalTypes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Output element -&gt; +I(book,2,12)   </span><br><span class="line">Output element -&gt; +I(book,2,19)   </span><br><span class="line">Output element -&gt; -D(book,2,19)    </span><br><span class="line">Output element -&gt; +I(book,2,11)   </span><br><span class="line">Output element -&gt; +I(fruit,1,33)  </span><br><span class="line">Output element -&gt; -D(fruit,1,33)  </span><br><span class="line">Output element -&gt; +I(fruit,1,22)</span><br></pre></td></tr></table></figure><h2 id="RetractableTopNFunction"><a href="#RetractableTopNFunction" class="headerlink" title="RetractableTopNFunction"></a>RetractableTopNFunction</h2><p>内部使用 TreeMap 进行 TopN 排序，可以对数据执行撤回操作，RowKind.UPDATE_BEFORE（-U）。</p><p>RetractableTopNFunction 中有如下属性，记录相同的 RowData 列表，使用 sortedMap 来进行 TopN 排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a map state stores mapping from sort key to records list</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RowData &lt;-&gt;  相同的 RowData list，状态后端远程维护</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> MapState&lt;RowData, List&lt;RowData&gt;&gt; dataState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a sorted map stores mapping from sort key to records count</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RowData &lt;-&gt; 对应的记录个数，ValueState 中记录有序的 RowData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValueState&lt;SortedMap&lt;RowData, Long&gt;&gt; treeMap;</span><br></pre></td></tr></table></figure><p>RetractableTopNFunction 中的 <code>processElement()</code> 方法，按照数据的 RowKind 分别执行 emit 和 retract 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(RowData input, Context ctx, Collector&lt;RowData&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">long</span> currentTime = ctx.timerService().currentProcessingTime();</span><br><span class="line"><span class="comment">// register state-cleanup timer</span></span><br><span class="line">registerProcessingCleanupTimer(ctx, currentTime);</span><br><span class="line">initRankEnd(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从状态后端中获取有序 RowData 的集合</span></span><br><span class="line">SortedMap&lt;RowData, Long&gt; sortedMap = treeMap.value();</span><br><span class="line"><span class="keyword">if</span> (sortedMap == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果为 null，则新建一个，指定 sortKey comparator</span></span><br><span class="line">sortedMap = <span class="keyword">new</span> TreeMap&lt;&gt;(sortKeyComparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RowData sortKey = sortKeySelector.getKey(input);</span><br><span class="line"><span class="comment">// RowKind.INSERT 或 RowKind.UPDATE_AFTER</span></span><br><span class="line"><span class="keyword">boolean</span> isAccumulate = RowDataUtil.isAccumulateMsg(input);</span><br><span class="line"><span class="comment">// erase row kind for further state accessing</span></span><br><span class="line">input.setRowKind(RowKind.INSERT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isAccumulate) &#123;</span><br><span class="line"><span class="comment">// update sortedMap，记录当前 sortKey 的记录数到状态后端</span></span><br><span class="line"><span class="keyword">if</span> (sortedMap.containsKey(sortKey)) &#123;</span><br><span class="line">sortedMap.put(sortKey, sortedMap.get(sortKey) + <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sortedMap.put(sortKey, <span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit</span></span><br><span class="line"><span class="keyword">if</span> (outputRankNumber || hasOffset()) &#123;</span><br><span class="line"><span class="comment">// the without-number-algorithm can't handle topN with offset,</span></span><br><span class="line"><span class="comment">// so use the with-number-algorithm to handle offset</span></span><br><span class="line">emitRecordsWithRowNumber(sortedMap, sortKey, input, out);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">emitRecordsWithoutRowNumber(sortedMap, sortKey, input, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步更新到状态后端</span></span><br><span class="line"><span class="comment">// update data state</span></span><br><span class="line">List&lt;RowData&gt; inputs = dataState.get(sortKey);</span><br><span class="line"><span class="keyword">if</span> (inputs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// the sort key is never seen</span></span><br><span class="line">inputs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">inputs.add(input);</span><br><span class="line">dataState.put(sortKey, inputs);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// emit updates first，先输出 update 操作，-U 代表执行撤回操作</span></span><br><span class="line"><span class="keyword">if</span> (outputRankNumber || hasOffset()) &#123;</span><br><span class="line"><span class="comment">// the without-number-algorithm can't handle topN with offset,</span></span><br><span class="line"><span class="comment">// so use the with-number-algorithm to handle offset</span></span><br><span class="line">retractRecordWithRowNumber(sortedMap, sortKey, input, out);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">retractRecordWithoutRowNumber(sortedMap, sortKey, input, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and then update sortedMap</span></span><br><span class="line"><span class="keyword">if</span> (sortedMap.containsKey(sortKey)) &#123;</span><br><span class="line"><span class="keyword">long</span> count = sortedMap.get(sortKey) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">sortedMap.remove(sortKey);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sortedMap.put(sortKey, count);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (sortedMap.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (lenient) &#123;</span><br><span class="line">LOG.warn(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line"><span class="string">"Can not retract a non-existent record. This should never happen."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新状态后端中记录的 sortedMap</span></span><br><span class="line">treeMap.update(sortedMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RetractableTopNFunction 中的 <code>emitRecordsWithRowNumber()</code> 方法正常输出排序行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emitRecordsWithRowNumber</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SortedMap&lt;RowData, Long&gt; sortedMap, RowData sortKey, RowData inputRow, Collector&lt;RowData&gt; out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Iterator&lt;Map.Entry&lt;RowData, Long&gt;&gt; iterator = sortedMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">long</span> currentRank = <span class="number">0L</span>;</span><br><span class="line">RowData currentRow = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> findsSortKey = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">Map.Entry&lt;RowData, Long&gt; entry = iterator.next();</span><br><span class="line">RowData key = entry.getKey();</span><br><span class="line"><span class="keyword">if</span> (!findsSortKey &amp;&amp; key.equals(sortKey)) &#123;</span><br><span class="line">currentRank += entry.getValue();</span><br><span class="line">currentRow = inputRow;</span><br><span class="line"><span class="comment">// 从 sortedMap 中找到当前的 sortKey</span></span><br><span class="line">findsSortKey = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findsSortKey) &#123;</span><br><span class="line">List&lt;RowData&gt; inputs = dataState.get(key);</span><br><span class="line"><span class="keyword">if</span> (inputs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Skip the data if it's state is cleared because of state ttl.</span></span><br><span class="line"><span class="keyword">if</span> (lenient) &#123;</span><br><span class="line">LOG.warn(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; inputs.size() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">RowData prevRow = inputs.get(i); <span class="comment">// 取出前一个row</span></span><br><span class="line">collectUpdateBefore(out, prevRow, currentRank);</span><br><span class="line">collectUpdateAfter(out, currentRow, currentRank); <span class="comment">//输出当前行</span></span><br><span class="line">currentRow = prevRow; <span class="comment">// 前一行赋给当前行</span></span><br><span class="line">currentRank += <span class="number">1</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">currentRank += entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInRankEnd(currentRank)) &#123;</span><br><span class="line"><span class="comment">// there is no enough elements in Top-N, emit INSERT message for the new record.</span></span><br><span class="line">collectInsert(out, currentRow, currentRank);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RetractableTopNFunction 中的 <code>retractRecordWithRowNumber()</code> 方法将撤回行从 sortedMap 中移除，并更新前一行的排位输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">retractRecordWithRowNumber</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">SortedMap&lt;RowData, Long&gt; sortedMap, RowData sortKey, RowData inputRow, Collector&lt;RowData&gt; out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Iterator&lt;Map.Entry&lt;RowData, Long&gt;&gt; iterator = sortedMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">long</span> currentRank = <span class="number">0L</span>;</span><br><span class="line">RowData prevRow = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> findsSortKey = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">Map.Entry&lt;RowData, Long&gt; entry = iterator.next();</span><br><span class="line">RowData key = entry.getKey();</span><br><span class="line"><span class="keyword">if</span> (!findsSortKey &amp;&amp; key.equals(sortKey)) &#123;</span><br><span class="line">List&lt;RowData&gt; inputs = dataState.get(key);</span><br><span class="line"><span class="keyword">if</span> (inputs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Skip the data if it's state is cleared because of state ttl.</span></span><br><span class="line"><span class="keyword">if</span> (lenient) &#123;</span><br><span class="line">LOG.warn(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(STATE_CLEARED_WARN_MSG);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Iterator&lt;RowData&gt; inputIter = inputs.iterator();</span><br><span class="line"><span class="keyword">while</span> (inputIter.hasNext() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">RowData currentRow = inputIter.next();</span><br><span class="line"><span class="keyword">if</span> (!findsSortKey &amp;&amp; equaliser.equals(currentRow, inputRow)) &#123;</span><br><span class="line">prevRow = currentRow;</span><br><span class="line">findsSortKey = <span class="keyword">true</span>;</span><br><span class="line">inputIter.remove();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findsSortKey) &#123;</span><br><span class="line">collectUpdateBefore(out, prevRow, currentRank);</span><br><span class="line">collectUpdateAfter(out, currentRow, currentRank);</span><br><span class="line">prevRow = currentRow;</span><br><span class="line">&#125;</span><br><span class="line">currentRank += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputs.isEmpty()) &#123;</span><br><span class="line">dataState.remove(key); <span class="comment">// 将撤回的行从 sortedMap 中移除</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dataState.put(key, inputs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findsSortKey) &#123;</span><br><span class="line">List&lt;RowData&gt; inputs = dataState.get(key);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; inputs.size() &amp;&amp; isInRankEnd(currentRank)) &#123;</span><br><span class="line">RowData currentRow = inputs.get(i); <span class="comment">// 上一行作为当前行</span></span><br><span class="line"><span class="comment">// 处理上一条数据</span></span><br><span class="line">collectUpdateBefore(out, prevRow, currentRank);</span><br><span class="line"><span class="comment">// 输出当前行</span></span><br><span class="line">collectUpdateAfter(out, currentRow, currentRank);</span><br><span class="line">prevRow = currentRow;</span><br><span class="line">currentRank += <span class="number">1</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">currentRank += entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInRankEnd(currentRank)) &#123;</span><br><span class="line"><span class="comment">// there is no enough elements in Top-N, emit DELETE message for the retract record.</span></span><br><span class="line">collectDelete(out, prevRow, currentRank);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RetractableTopNFunctionTest"><a href="#RetractableTopNFunctionTest" class="headerlink" title="RetractableTopNFunctionTest"></a>RetractableTopNFunctionTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests for &#123;<span class="doctag">@link</span> RetractableTopNFunction&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetractableTopNFunctionTest</span> <span class="keyword">extends</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractTopNFunction <span class="title">createFunction</span><span class="params">(RankType rankType, RankRange rankRange,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> generateUpdateBefore, <span class="keyword">boolean</span> outputRankNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RetractableTopNFunction(</span><br><span class="line">minTime.toMilliseconds(),</span><br><span class="line">maxTime.toMilliseconds(),</span><br><span class="line">inputRowType,</span><br><span class="line">sortKeyComparator,</span><br><span class="line">sortKeySelector,</span><br><span class="line">rankType,</span><br><span class="line">rankRange,</span><br><span class="line">generatedEqualiser,</span><br><span class="line">generateUpdateBefore,</span><br><span class="line">outputRankNumber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessRetractMessageWithNotGenerateUpdateBefore</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER,</span><br><span class="line"><span class="comment">// 固定的 TopN 集合大小，1～2</span></span><br><span class="line"><span class="keyword">new</span> ConstantRankRange(<span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"><span class="keyword">false</span>,</span><br><span class="line"><span class="comment">// 输出 TopN 的排序序号</span></span><br><span class="line"><span class="keyword">true</span>);</span><br><span class="line">OneInputStreamOperatorTestHarness&lt;RowData, RowData&gt; testHarness = createTestHarness(func);</span><br><span class="line">testHarness.open();</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">1L</span>, <span class="number">12</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">4L</span>, <span class="number">11</span>));</span><br><span class="line">testHarness.processElement(updateBeforeRecord(<span class="string">"book"</span>, <span class="number">1L</span>, <span class="number">12</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">5L</span>, <span class="number">11</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">4L</span>, <span class="number">33</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">3L</span>, <span class="number">44</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">5L</span>, <span class="number">22</span>));</span><br><span class="line">testHarness.close();</span><br><span class="line"></span><br><span class="line">ConcurrentLinkedQueue&lt;Object&gt; output = testHarness.getOutput();</span><br><span class="line"><span class="keyword">for</span> (Object o : output) &#123;</span><br><span class="line">StreamRecord streamRecord = (StreamRecord) o;</span><br><span class="line">System.out.println(<span class="string">"Output element -&gt; "</span> + streamRecord.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; expectedOutput = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// ("book", 1L, 12)</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 1L, 12)]</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">1L</span>, <span class="number">12</span>, <span class="number">1L</span>));</span><br><span class="line"><span class="comment">// ("book", 2L, 19)</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 1L, 12)],[("book", 2L, 19)]</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// ("book", 4L, 11)</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 4L, 11)],[("book", 1L, 12)],[("book", 2L, 19)]</span></span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">4L</span>, <span class="number">11</span>, <span class="number">1L</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">1L</span>, <span class="number">12</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// UB ("book", 1L, 12)，撤回即将 ("book", 1L ,12) 从 sortedMap 中移除，("book", 2L, 19)的排序被更新为 2</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 4L, 11)],[("book", 2L, 19)]</span></span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// ("book", 5L, 11)</span></span><br><span class="line"><span class="comment">// sortedMap -&gt; [("book", 4L, 11),("book", 5L, 11)],[("book", 2L, 19)]，("book", 5L, 11) 的排序被更新为 2</span></span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">5L</span>, <span class="number">11</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// ("fruit", 4L, 33)</span></span><br><span class="line"><span class="comment">// ("fruit", 3L, 44)</span></span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">4L</span>, <span class="number">33</span>, <span class="number">1L</span>));</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">3L</span>, <span class="number">44</span>, <span class="number">2L</span>));</span><br><span class="line"><span class="comment">// ("fruit", 5L, 22)</span></span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">5L</span>, <span class="number">22</span>, <span class="number">1L</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">4L</span>, <span class="number">33</span>, <span class="number">2L</span>));</span><br><span class="line">assertorWithRowNumber.assertOutputEquals(<span class="string">"output wrong."</span>, expectedOutput, testHarness.getOutput());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Output element -&gt; +I&#123;row1=+I(book,1,12), row2=+I(1)&#125;</span><br><span class="line">Output element -&gt; +I&#123;row1=+I(book,2,19), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(book,4,11), row2=+I(1)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(book,1,12), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(book,2,19), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(book,5,11), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +I&#123;row1=+I(fruit,4,33), row2=+I(1)&#125;</span><br><span class="line">Output element -&gt; +I&#123;row1=+I(fruit,3,44), row2=+I(2)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(fruit,5,22), row2=+I(1)&#125;</span><br><span class="line">Output element -&gt; +U&#123;row1=+I(fruit,4,33), row2=+I(2)&#125;</span><br></pre></td></tr></table></figure><h2 id="UpdatableTopNFunction"><a href="#UpdatableTopNFunction" class="headerlink" title="UpdatableTopNFunction"></a>UpdatableTopNFunction</h2><p>支持更新流，是 RetractableTopNFunction 的简单实现版本，输入流中不能包含 DELETE 和 UPDATE_BEFORE 操作。</p><h3 id="UpdatableTopNFunctionTest"><a href="#UpdatableTopNFunctionTest" class="headerlink" title="UpdatableTopNFunctionTest"></a>UpdatableTopNFunctionTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tests for &#123;<span class="doctag">@link</span> UpdatableTopNFunction&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdatableTopNFunctionTest</span> <span class="keyword">extends</span> <span class="title">TopNFunctionTestBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractTopNFunction <span class="title">createFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RankType rankType,</span></span></span><br><span class="line"><span class="function"><span class="params">RankRange rankRange,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> generateUpdateBefore,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> outputRankNumber)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UpdatableTopNFunction(</span><br><span class="line">minTime.toMilliseconds(),</span><br><span class="line">maxTime.toMilliseconds(),</span><br><span class="line">inputRowType,</span><br><span class="line">rowKeySelector,</span><br><span class="line">sortKeyComparator,</span><br><span class="line">sortKeySelector,</span><br><span class="line">rankType,</span><br><span class="line">rankRange,</span><br><span class="line">generateUpdateBefore,</span><br><span class="line">outputRankNumber,</span><br><span class="line">cacheSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVariableRankRange</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractTopNFunction func = createFunction(RankType.ROW_NUMBER,</span><br><span class="line"><span class="comment">// TopN 的集合大小随着数据动态变化</span></span><br><span class="line"><span class="keyword">new</span> VariableRankRange(<span class="number">1</span>),</span><br><span class="line"><span class="keyword">true</span>,</span><br><span class="line"><span class="keyword">false</span>);</span><br><span class="line">OneInputStreamOperatorTestHarness&lt;RowData, RowData&gt; testHarness = createTestHarness(func);</span><br><span class="line">testHarness.open();</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">testHarness.processElement(updateAfterRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">18</span>));</span><br><span class="line">testHarness.processElement(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">44</span>));</span><br><span class="line">testHarness.processElement(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line">testHarness.processElement(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">22</span>));</span><br><span class="line">testHarness.close();</span><br><span class="line"></span><br><span class="line">ConcurrentLinkedQueue&lt;Object&gt; output = testHarness.getOutput();</span><br><span class="line"><span class="keyword">for</span> (Object o : output) &#123;</span><br><span class="line">StreamRecord streamRecord = (StreamRecord) o;</span><br><span class="line">System.out.println(<span class="string">"Output element -&gt; "</span> + streamRecord.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Object&gt; expectedOutput = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">expectedOutput.add(updateBeforeRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">19</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"book"</span>, <span class="number">2L</span>, <span class="number">18</span>));</span><br><span class="line">expectedOutput.add(insertRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">44</span>));</span><br><span class="line">expectedOutput.add(updateBeforeRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">44</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line">expectedOutput.add(updateBeforeRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">33</span>));</span><br><span class="line">expectedOutput.add(updateAfterRecord(<span class="string">"fruit"</span>, <span class="number">1L</span>, <span class="number">22</span>));</span><br><span class="line">assertorWithoutRowNumber</span><br><span class="line">.assertOutputEquals(<span class="string">"output wrong."</span>, expectedOutput, testHarness.getOutput());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Output element -&gt; +I(book,2,19)</span><br><span class="line">Output element -&gt; -U(book,2,19)</span><br><span class="line">Output element -&gt; +U(book,2,18)</span><br><span class="line">Output element -&gt; +I(fruit,1,44)</span><br><span class="line">Output element -&gt; -U(fruit,1,44)</span><br><span class="line">Output element -&gt; +U(fruit,1,33)</span><br><span class="line">Output element -&gt; -U(fruit,1,33)</span><br><span class="line">Output element -&gt; +U(fruit,1,22)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将基于 flink &lt;code&gt;release-1.11&lt;/code&gt; 源码，简单分析下 TopN function 的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink部署-flink-on-kubernetes</title>
    <link href="http://yoursite.com/2020/09/29/Flink%E9%83%A8%E7%BD%B2-flink-on-kubernetes/"/>
    <id>http://yoursite.com/2020/09/29/Flink部署-flink-on-kubernetes/</id>
    <published>2020-09-29T07:23:17.000Z</published>
    <updated>2020-09-29T09:13:38.017Z</updated>
    
    <content type="html"><![CDATA[<p>kubernetes 是目前非常流行的容器编排系统，在其之上可以运行 web 服务、大数据处理等各类应用。这些应用被打包在非常轻量的容器中，我们通过声明的方式来告知 kubernetes 要如何部署和扩容这些程序，并对外提供服务。flink on kubernetes 可以得到一个健壮和高可扩的数据处理应用，并且能够更安全的和其他服务共享一个 kubernetes 集群。</p><p>本文将记录使用 kubernetes 部署 flink 应用的步骤。</p><a id="more"></a><h2 id="Mac-安装-Docker"><a href="#Mac-安装-Docker" class="headerlink" title="Mac 安装 Docker"></a>Mac 安装 Docker</h2><p>Docker Desktop 下载地址：<a href="https://www.docker.com/get-started" target="_blank" rel="noopener">Docker 官网</a><br>注册 DockerID 并登录。</p><p>安装 docker 命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew install docker</span><br></pre></td></tr></table></figure><h2 id="Minikube-搭建-Kubernetes-实验环境"><a href="#Minikube-搭建-Kubernetes-实验环境" class="headerlink" title="Minikube 搭建 Kubernetes 实验环境"></a>Minikube 搭建 Kubernetes 实验环境</h2><p>可以参考：<a href="https://kubernetes.io/docs/setup/learning-environment/minikube/#quickstart" target="_blank" rel="noopener">Kubernetes 官网</a></p><h3 id="安装-Minikube"><a href="#安装-Minikube" class="headerlink" title="安装 Minikube"></a>安装 Minikube</h3><ol><li><p>校验 MacOS 是否支持虚拟化，运行如下命令出现 ‘VMX’：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sysctl -a | grep -E --color 'machdep.cpu.features|VMX'</span><br></pre></td></tr></table></figure></li><li><p>安装 kubectl 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl"</span><br><span class="line"><span class="meta">$</span> chmod +x ./kubectl</span><br><span class="line"><span class="meta">$</span> sudo mv ./kubectl /usr/local/bin/kubectl</span><br></pre></td></tr></table></figure><p> 或者直接使用 Homebrew 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew install kubectl </span><br><span class="line"><span class="meta">$</span> brew install kubernetes-cli</span><br></pre></td></tr></table></figure><p> 查看是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> kubectl version --client</span><br><span class="line">Client Version: version.Info&#123;Major:"1", Minor:"19", GitVersion:"v1.19.2", GitCommit:"f5743093fd1c663cb0cbc89748f730662345d44d", GitTreeState:"clean", BuildDate:"2020-09-16T13:41:02Z", GoVersion:"go1.15", Compiler:"gc", Platform:"darwin/amd64"&#125;</span><br></pre></td></tr></table></figure></li><li><p>安装 VirtualBox<br>VirtualBox 下载地址：<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">VirtualBox 官网</a></p></li></ol><ol start="4"><li><p>安装 minikube</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 &amp;&amp; chmod +x minikube</span><br><span class="line"><span class="meta">$</span> sudo mv minikube /usr/local/bin</span><br></pre></td></tr></table></figure><p> 或者直接使用 Homebrew 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> brew install minikube</span><br></pre></td></tr></table></figure></li><li><p>执行 minikube start<br>该命令会下载 kubelet 和 kubeadm 程序，并构建一个完整的 k8s 集群。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> minikube start</span><br></pre></td></tr></table></figure></li><li><p>查看 k8s pods<br>Minikube 已经将命令 kubectl 指向虚拟机中的 k8s 集群了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> kubectl get pods -A</span><br><span class="line">kube-system   coredns-f9fd979d6-xjht6                           1/1     Running   0          5h14m</span><br><span class="line">kube-system   etcd-minikube                                     1/1     Running   0          5h14m</span><br><span class="line">kube-system   kube-apiserver-minikube                           1/1     Running   0          5h14m</span><br><span class="line">kube-system   kube-controller-manager-minikube                  1/1     Running   0          5h14m</span><br><span class="line">kube-system   kube-proxy-ff8m8                                  1/1     Running   0          5h14m</span><br><span class="line">kube-system   kube-scheduler-minikube                           1/1     Running   0          5h14m</span><br><span class="line">kube-system   storage-provisioner                               1/1     Running   0          5h14m</span><br></pre></td></tr></table></figure></li></ol><h2 id="Flink-实时处理-demo"><a href="#Flink-实时处理-demo" class="headerlink" title="Flink 实时处理 demo"></a>Flink 实时处理 demo</h2><p>我们可以编写一个简单的实时处理脚本，该脚本会从某个端口中读取文本，分割为单词，并且每 5 秒钟打印一次每个单词出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; dataStream = env</span><br><span class="line">    .socketTextStream(<span class="string">"192.168.99.1"</span>, <span class="number">9999</span>)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Splitter())</span><br><span class="line">    .keyBy(<span class="number">0</span>)</span><br><span class="line">    .timeWindow(Time.seconds(<span class="number">5</span>))</span><br><span class="line">    .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">dataStream.print();</span><br><span class="line"></span><br><span class="line">env.execute(<span class="string">"Window WordCount"</span>);</span><br></pre></td></tr></table></figure><p>K8s 容器中的程序可以通过 IP 192.168.99.1 来访问 Minikube 宿主机上的服务。</p><p>demo 下载：<a href="flink-on-kubernetes-0.0.1-SNAPSHOT-jar-with-dependencies.jar">flink-on-kubernetes-0.0.1-SNAPSHOT-jar-with-dependencies.jar</a></p><h2 id="构建-Docker-容器镜像"><a href="#构建-Docker-容器镜像" class="headerlink" title="构建 Docker 容器镜像"></a>构建 Docker 容器镜像</h2><p>flink 提供了一个官方的容器镜像，可以从 <a href="https://hub.docker.com/_/flink?tab=tags&page=1&name=1.8.1-scala_2.12" target="_blank" rel="noopener">DockerHub</a> 上下载镜像。<br>官方镜像的 <a href="https://github.com/docker-flink/docker-flink/blob/master/1.8/scala_2.12-debian/Dockerfile" target="_blank" rel="noopener">Dockerfile</a>，以 <code>1.8.1-scala_2.12</code> 为例，大致内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jre</span><br><span class="line">ENV FLINK_HOME=/opt/flink</span><br><span class="line">ENV PATH=$FLINK_HOME/bin:$PATH</span><br><span class="line">RUN groupadd --system --gid=9999 flink &amp;&amp; \</span><br><span class="line">    useradd --system --home-dir $FLINK_HOME --uid=9999 --gid=flink flink</span><br><span class="line">WORKDIR $FLINK_HOME</span><br><span class="line"></span><br><span class="line">RUN useradd flink &amp;&amp; \</span><br><span class="line">  wget -O flink.tgz &quot;$FLINK_TGZ_URL&quot; &amp;&amp; \</span><br><span class="line">  tar -xf flink.tgz</span><br><span class="line">ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure><p>主要做了以下几件事情：</p><ul><li>将 OpenJDK 1.8 作为基础镜像</li><li>下载并安装 flink 至 /opt/flink 目录中</li><li>添加 flink 用户和组等</li></ul><p>下面我们以 flink:1.8.1-scala_2.12 作为基础镜像，编写新的 Dockerfile，将打包好的任务 jar 包放置进去。此外，新版 flink 已将 hadoop 依赖从官方发行版本中剥离，因此在打包镜像的时候也要包含进去。<br>Hadoop jar 下载：<a href="flink-shaded-hadoop-2-uber-2.8.3-7.0.jar">flink-shaded-hadoop-2-uber-2.8.3-7.0.jar</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM flink:1.8.1-scala_2.12</span><br><span class="line"></span><br><span class="line">ARG hadoop_jar</span><br><span class="line">ARG job_jar</span><br><span class="line"></span><br><span class="line">ENV FLINK_CONF=$FLINK_HOME/conf/flink-conf.yaml</span><br><span class="line"></span><br><span class="line">RUN set -x &amp;&amp; \</span><br><span class="line">  sed -i -e &quot;s/jobmanager\.heap\.size:.*/jobmanager.heap.size: 128m/g&quot; $FLINK_CONF &amp;&amp; \</span><br><span class="line">  sed -i -e &quot;s/taskmanager\.heap\.size:.*/taskmanager.heap.size: 256m/g&quot; $FLINK_CONF</span><br><span class="line"></span><br><span class="line">COPY --chown=flink:flink $hadoop_jar $job_jar $FLINK_HOME/lib/</span><br><span class="line"></span><br><span class="line">USER flink</span><br></pre></td></tr></table></figure><p>将 docker 命令行指向 Minikube 中的 Docker 服务，这样打印出来的镜像才能被 k8s 使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> eval $(minikube docker-env)</span><br></pre></td></tr></table></figure><p>移动到 Dockerfile 所在目录，开始构建镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker build \</span><br><span class="line">  --build-arg hadoop_jar=flink-shaded-hadoop-2-uber-2.8.3-7.0.jar \</span><br><span class="line">  --build-arg job_jar=flink-on-kubernetes-0.0.1-SNAPSHOT-jar-with-dependencies.jar \</span><br><span class="line">  --tag flink-on-kubernetes:0.0.1 .</span><br></pre></td></tr></table></figure><p>镜像打包完毕，可用于部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker image ls</span><br><span class="line">REPOSITORY                           TAG                                              IMAGE ID            CREATED             SIZE</span><br><span class="line">flink-on-kubernetes                  0.0.1                                            ed4dfaf07cfe        5 hours ago         618MB</span><br></pre></td></tr></table></figure><h2 id="部署-JobManager"><a href="#部署-JobManager" class="headerlink" title="部署 JobManager"></a>部署 JobManager</h2><p><code>jobmanager.yml</code> ：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;JOB&#125;-jobmanager</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">        instance:</span> <span class="string">$&#123;JOB&#125;-jobmanager</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">jobmanager</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">flink-on-kubernetes:0.0.1</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["/opt/flink/bin/standalone-job.sh"]</span></span><br><span class="line"><span class="attr">        args:</span> <span class="string">["start-foreground",</span></span><br><span class="line">               <span class="string">"-Djobmanager.rpc.address=$&#123;JOB&#125;-jobmanager"</span><span class="string">,</span></span><br><span class="line">               <span class="string">"-Dparallelism.default=1"</span><span class="string">,</span></span><br><span class="line">               <span class="string">"-Dblob.server.port=6124"</span><span class="string">,</span></span><br><span class="line">               <span class="string">"-Dqueryable-state.server.ports=6125"</span><span class="string">,</span></span><br><span class="line">               <span class="string">"-Dstate.savepoints.dir=hdfs://192.168.99.1:9000/flink/savepoints/"</span><span class="string">,</span></span><br><span class="line">               <span class="string">]</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6123</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">rpc</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6124</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">blob</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">6125</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">ui</span></span><br></pre></td></tr></table></figure><ul><li>${JOB} 变量可以使用 <code>envsubst</code> 命令来替换</li><li>容器的入口修改为 <code>standalone-job.sh</code></li><li>JobManager 的 rpc 地址修改为了 k8s Service 的名称，集群中的其他组件将通过这个名称来访问 JobManager。</li><li>为 Flink Blob Server &amp; Queryable State Server 指定默认端口号</li></ul><p>使用 <code>kubectl</code> 命令创建 JobManager pod，并查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> export JOB=flink-on-kubernetes</span><br><span class="line"><span class="meta">$</span> envsubst &lt;jobmanager.yml | kubectl create -f -</span><br><span class="line"><span class="meta">$</span> kubectl get pod</span><br><span class="line">NAME                                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">flink-on-kubernetes-jobmanager-dzhcs              1/1     Running   0          77m</span><br></pre></td></tr></table></figure><p>创建一个 k8s Service 把 JobManager 的端口开放出来，以便 TaskManager 前来注册。<br><code>service.yml</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;JOB&#125;-jobmanager</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">    instance:</span> <span class="string">$&#123;JOB&#125;-jobmanager</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">rpc</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6123</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">blob</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6124</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">query</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6125</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ui</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>使用 <code>kubectl</code> 命令创建 JobManager service，并查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> envsubst &lt;service.yml | kubectl create -f -</span><br><span class="line"><span class="meta">$</span>  kubectl get service</span><br><span class="line">NAME                             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                                                       AGE</span><br><span class="line">flink-on-kubernetes-jobmanager   NodePort    10.104.157.70   &lt;none&gt;        6123:30261/TCP,6124:31158/TCP,6125:30509/TCP,8081:30262/TCP   89m</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> minikube service $JOB-jobmanager --url</span><br><span class="line">http://192.168.99.100:30261</span><br><span class="line">http://192.168.99.100:31158</span><br><span class="line">http://192.168.99.100:30509</span><br><span class="line">http://192.168.99.100:30262</span><br></pre></td></tr></table></figure><p><img src="JobManager%E9%80%8F%E5%87%BA%E7%9A%84Dashboard.png" alt></p><h2 id="部署-TaskManager"><a href="#部署-TaskManager" class="headerlink" title="部署 TaskManager"></a>部署 TaskManager</h2><p><code>taskmanager.yml</code> ：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">$&#123;JOB&#125;-taskmanager</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">      instance:</span> <span class="string">$&#123;JOB&#125;-taskmanager</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">flink</span></span><br><span class="line"><span class="attr">        instance:</span> <span class="string">$&#123;JOB&#125;-taskmanager</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">taskmanager</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">flink-on-kubernetes:0.0.1</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">["/opt/flink/bin/taskmanager.sh"]</span></span><br><span class="line"><span class="attr">        args:</span> <span class="string">["start-foreground",</span> <span class="string">"-Djobmanager.rpc.address=$&#123;JOB&#125;-jobmanager"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>使用 <code>kubectl</code> 命令创建 TaskManager pod，并查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> kubectl get pod</span><br><span class="line">NAME                                              READY   STATUS    RESTARTS   AGE</span><br><span class="line">flink-on-kubernetes-jobmanager-dzhcs              1/1     Running   0          77m</span><br><span class="line">flink-on-kubernetes-taskmanager-64b7cc4bf-9t6cr   1/1     Running   2          77m</span><br></pre></td></tr></table></figure><p>至此，Flink 脚本集群已经在运行中了。在监听终端下输入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> nc -lk 9999</span><br><span class="line">hello world</span><br><span class="line">hello flink</span><br></pre></td></tr></table></figure><p>打开另一个终端，查看 TaskManager 的标准输出日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> kubectl logs -f -l instance=$JOB-taskmanager</span><br><span class="line">(hello,2)</span><br><span class="line">(flink,1)</span><br><span class="line">(world,1)</span><br></pre></td></tr></table></figure><p><img src="taskmanager%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kubernetes 是目前非常流行的容器编排系统，在其之上可以运行 web 服务、大数据处理等各类应用。这些应用被打包在非常轻量的容器中，我们通过声明的方式来告知 kubernetes 要如何部署和扩容这些程序，并对外提供服务。flink on kubernetes 可以得到一个健壮和高可扩的数据处理应用，并且能够更安全的和其他服务共享一个 kubernetes 集群。&lt;/p&gt;
&lt;p&gt;本文将记录使用 kubernetes 部署 flink 应用的步骤。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink源码剖析-flink-streaming-java_JobGraph</title>
    <link href="http://yoursite.com/2020/04/22/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-flink-streaming-java_JobGraph/"/>
    <id>http://yoursite.com/2020/04/22/Flink源码剖析-flink-streaming-java_JobGraph/</id>
    <published>2020-04-22T14:29:49.000Z</published>
    <updated>2020-04-22T16:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要围绕 Flink 源码中 <code>flink-streaming-java</code> 模块。介绍下 StreamGraph 转成 JobGraph 的过程等。</p><a id="more"></a><p>StreamGraph 和 JobGraph 都是在 Client 端生成的，也就是说我们可以在 IDE 中通过断点调试观察 StreamGraph 和 JobGraph 的生成过程。</p><h2 id="前置调用"><a href="#前置调用" class="headerlink" title="前置调用"></a>前置调用</h2><p>从 StreamExecutionEnvironment 中的 execute() 方法一直往下跟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Streaming 程序的提交入口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> execute(DEFAULT_JOB_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 StreamGraph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">execute</span><span class="params">(String jobName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Preconditions.checkNotNull(jobName, <span class="string">"Streaming Job name should not be null."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> execute(getStreamGraph(jobName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成 JobGraph ，提交任务，并响应 JobListeners</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">execute</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 异步执行</span></span><br><span class="line"><span class="keyword">final</span> JobClient jobClient = executeAsync(streamGraph);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> JobExecutionResult jobExecutionResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (configuration.getBoolean(DeploymentOptions.ATTACHED)) &#123;</span><br><span class="line">jobExecutionResult = jobClient.getJobExecutionResult(userClassloader).get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">jobExecutionResult = <span class="keyword">new</span> DetachedJobExecutionResult(jobClient.getJobID());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jobListeners.forEach(jobListener -&gt; jobListener.onJobExecuted(jobExecutionResult, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jobExecutionResult;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">jobListeners.forEach(jobListener -&gt; &#123;</span><br><span class="line">jobListener.onJobExecuted(<span class="keyword">null</span>, ExceptionUtils.stripExecutionException(t));</span><br><span class="line">&#125;);</span><br><span class="line">ExceptionUtils.rethrowException(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// never reached, only make javac happy</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们详细看看 StreamExecutionEnvironment 中的 executeAsync 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 execution.target 配置反射得到 PipelineExecutorFactory，拿出工厂类对应的 PipelineExecutor，执行其 execute 方法</span></span><br><span class="line"><span class="comment"> * execute的主要工作是将 StreamGraph 转成了 JobGraph，并创建相应的 ClusterClient 完成提交任务的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobClient <span class="title">executeAsync</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">checkNotNull(streamGraph, <span class="string">"StreamGraph cannot be null."</span>);</span><br><span class="line">checkNotNull(configuration.get(DeploymentOptions.TARGET), <span class="string">"No execution.target specified in your configuration file."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPI机制</span></span><br><span class="line"><span class="comment">// 根据flink Configuration中的"execution.target"加载 PipelineExecutorFactory</span></span><br><span class="line"><span class="comment">// PipelineExecutorFactory 的实现类在flink-clients包或者flink-yarn包里，因此需要在pom.xml中添加此依赖</span></span><br><span class="line"><span class="keyword">final</span> PipelineExecutorFactory executorFactory =</span><br><span class="line">executorServiceLoader.getExecutorFactory(configuration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射出的 PipelineExecutorFactory 类不能为空</span></span><br><span class="line">checkNotNull(</span><br><span class="line">executorFactory,</span><br><span class="line"><span class="string">"Cannot find compatible factory for specified execution.target (=%s)"</span>,</span><br><span class="line">configuration.get(DeploymentOptions.TARGET));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据加载到的 PipelineExecutorFactory 工厂类，获取其对应的 PipelineExecutor，</span></span><br><span class="line"><span class="comment">// 并执行 PipelineExecutor 的 execute() 方法，将 StreamGraph 转成 JobGraph</span></span><br><span class="line">CompletableFuture&lt;JobClient&gt; jobClientFuture = executorFactory</span><br><span class="line">.getExecutor(configuration)</span><br><span class="line">.execute(streamGraph, configuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步调用的返回结果</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">JobClient jobClient = jobClientFuture.get();</span><br><span class="line">jobListeners.forEach(jobListener -&gt; jobListener.onJobSubmitted(jobClient, <span class="keyword">null</span>));</span><br><span class="line"><span class="keyword">return</span> jobClient;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">jobListeners.forEach(jobListener -&gt; jobListener.onJobSubmitted(<span class="keyword">null</span>, t));</span><br><span class="line">ExceptionUtils.rethrow(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make javac happy, this code path will not be reached</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>executeAsync 有涉及到 PipelineExecutorFactory 和 PipelineExecutor 。<br>PipelineExecutorFactory 是通过 SPI ServiceLoader 加载的，我们看下 <code>flink-clients</code> 模块的 <code>META-INF.services</code> 文件：<br><img src="flink-clients%E6%A8%A1%E5%9D%97%E7%9A%84META-INF%E6%96%87%E4%BB%B6.png" alt></p><p>PipelineExecutorFactory 的实现子类，分别对应着 Flink 的不同部署模式，local、standalone、yarn、kubernets 等：<br><img src="PipelineExecutorFactory%E5%AD%90%E7%B1%BB.png" alt></p><p>这里我们只看下 LocalExecutorFactory 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalExecutorFactory</span> <span class="keyword">implements</span> <span class="title">PipelineExecutorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * execution.target 配置项对应的值为 "local"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompatibleWith</span><span class="params">(<span class="keyword">final</span> Configuration configuration)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> LocalExecutor.NAME.equalsIgnoreCase(configuration.get(DeploymentOptions.TARGET));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接 new 一个 LocalExecutor 返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PipelineExecutor <span class="title">getExecutor</span><span class="params">(<span class="keyword">final</span> Configuration configuration)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LocalExecutor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PipelineExecutor 的实现子类与 PipelineExecutorFactory 与工厂类一一对应，负责将 StreamGraph 转成 JobGraph，并生成 ClusterClient 执行任务的提交：<br><img src="PipelineExecutor%E5%AD%90%E7%B1%BB.png" alt></p><p>LocalExecutorFactory 对应的 LocalExecutor 实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalExecutor</span> <span class="keyword">implements</span> <span class="title">PipelineExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"local"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;JobClient&gt; <span class="title">execute</span><span class="params">(Pipeline pipeline, Configuration configuration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">checkNotNull(pipeline);</span><br><span class="line">checkNotNull(configuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we only support attached execution with the local executor.</span></span><br><span class="line">checkState(configuration.getBoolean(DeploymentOptions.ATTACHED));</span><br><span class="line"></span><br><span class="line"><span class="comment">// StreamGraph 转成 JobGraph</span></span><br><span class="line"><span class="keyword">final</span> JobGraph jobGraph = getJobGraph(pipeline, configuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// local 模式，本地启动一个 Mini Cluster</span></span><br><span class="line"><span class="keyword">final</span> MiniCluster miniCluster = startMiniCluster(jobGraph, configuration);</span><br><span class="line"><span class="comment">// 创建 MiniClusterClient ，准备提交任务</span></span><br><span class="line"><span class="keyword">final</span> MiniClusterClient clusterClient = <span class="keyword">new</span> MiniClusterClient(configuration, miniCluster);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">CompletableFuture&lt;JobID&gt; jobIdFuture = clusterClient.submitJob(jobGraph);</span><br><span class="line"></span><br><span class="line">jobIdFuture</span><br><span class="line">.thenCompose(clusterClient::requestJobResult)</span><br><span class="line">.thenAccept((jobResult) -&gt; clusterClient.shutDownCluster());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jobIdFuture.thenApply(jobID -&gt;</span><br><span class="line"><span class="keyword">new</span> ClusterClientJobClientAdapter&lt;&gt;(() -&gt; clusterClient, jobID));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> JobGraph <span class="title">getJobGraph</span><span class="params">(Pipeline pipeline, Configuration configuration)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里调用 FlinkPipelineTranslationUtil 的 getJobGraph() 方法</span></span><br><span class="line"><span class="keyword">return</span> FlinkPipelineTranslationUtil.getJobGraph(pipeline, configuration, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回归主题，我们看下 FlinkPipelineTranslationUtil 的 getJobGraph() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobGraph <span class="title">getJobGraph</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Pipeline pipeline,</span></span></span><br><span class="line"><span class="function"><span class="params">Configuration optimizerConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> defaultParallelism)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射得到 FlinkPipelineTranslator </span></span><br><span class="line">FlinkPipelineTranslator pipelineTranslator = getPipelineTranslator(pipeline);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pipelineTranslator.translateToJobGraph(pipeline,</span><br><span class="line">optimizerConfiguration,</span><br><span class="line">defaultParallelism);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FlinkPipelineTranslator <span class="title">getPipelineTranslator</span><span class="params">(Pipeline pipeline)</span> </span>&#123;</span><br><span class="line">PlanTranslator planToJobGraphTransmogrifier = <span class="keyword">new</span> PlanTranslator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (planToJobGraphTransmogrifier.canTranslate(pipeline)) &#123;</span><br><span class="line"><span class="keyword">return</span> planToJobGraphTransmogrifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FlinkPipelineTranslator streamGraphTranslator = reflectStreamGraphTranslator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实就是判断当前的 Pipeline 实例是不是 StreamGraph</span></span><br><span class="line"><span class="keyword">if</span> (!streamGraphTranslator.canTranslate(pipeline)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Translator "</span> + streamGraphTranslator + <span class="string">" cannot translate "</span></span><br><span class="line">+ <span class="string">"the given pipeline "</span> + pipeline + <span class="string">"."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> streamGraphTranslator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> FlinkPipelineTranslator <span class="title">reflectStreamGraphTranslator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; streamGraphTranslatorClass;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">streamGraphTranslatorClass = Class.forName(</span><br><span class="line"><span class="comment">// 因为这个类在 flink-streaming-java 模块中，FlinkPipelineTranslationUtil 在 flink-clients 模块中，</span></span><br><span class="line">    <span class="comment">// flink-clients 模块没有引入 flink-streaming-java 模块，所以只能通过反射拿到</span></span><br><span class="line"><span class="string">"org.apache.flink.streaming.api.graph.StreamGraphTranslator"</span>,</span><br><span class="line"><span class="keyword">true</span>,</span><br><span class="line">FlinkPipelineTranslationUtil.class.getClassLoader());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not load StreamGraphTranslator."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FlinkPipelineTranslator streamGraphTranslator;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">streamGraphTranslator =</span><br><span class="line">(FlinkPipelineTranslator) streamGraphTranslatorClass.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not instantiate StreamGraphTranslator."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> streamGraphTranslator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着走到 StreamGraphTranslator 的 translateToJobGraph 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamGraphTranslator</span> <span class="keyword">implements</span> <span class="title">FlinkPipelineTranslator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其实就是调用 StreamGraph 自己的 getJobGraph 方法生成 JobGraph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobGraph <span class="title">translateToJobGraph</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Pipeline pipeline,</span></span></span><br><span class="line"><span class="function"><span class="params">Configuration optimizerConfiguration,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> defaultParallelism)</span> </span>&#123;</span><br><span class="line">checkArgument(pipeline <span class="keyword">instanceof</span> StreamGraph,</span><br><span class="line"><span class="string">"Given pipeline is not a DataStream StreamGraph."</span>);</span><br><span class="line"></span><br><span class="line">StreamGraph streamGraph = (StreamGraph) pipeline;</span><br><span class="line"><span class="keyword">return</span> streamGraph.getJobGraph(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">translateToJSONExecutionPlan</span><span class="params">(Pipeline pipeline)</span> </span>&#123;</span><br><span class="line">checkArgument(pipeline <span class="keyword">instanceof</span> StreamGraph,</span><br><span class="line"><span class="string">"Given pipeline is not a DataStream StreamGraph."</span>);</span><br><span class="line"></span><br><span class="line">StreamGraph streamGraph = (StreamGraph) pipeline;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> streamGraph.getStreamingPlanAsJSON();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canTranslate</span><span class="params">(Pipeline pipeline)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pipeline <span class="keyword">instanceof</span> StreamGraph;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StreamGraph-到-JobGraph-的转换"><a href="#StreamGraph-到-JobGraph-的转换" class="headerlink" title="StreamGraph 到 JobGraph 的转换"></a>StreamGraph 到 JobGraph 的转换</h2><p>接着走到 StreamGraph 中的 getJobGraph() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JobGraph <span class="title">getJobGraph</span><span class="params">(@Nullable JobID jobID)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> StreamingJobGraphGenerator.createJobGraph(<span class="keyword">this</span>, jobID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着走到 StreamingJobGraphGenerator 的 createJobGraph() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入 StreamGraph，生成 JobGraph</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobGraph <span class="title">createJobGraph</span><span class="params">(StreamGraph streamGraph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createJobGraph(streamGraph, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobGraph <span class="title">createJobGraph</span><span class="params">(StreamGraph streamGraph, @Nullable JobID jobID)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StreamingJobGraphGenerator(streamGraph, jobID).createJobGraph();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心方法</span></span><br><span class="line"><span class="comment"> * StreamGraph 转 JobGraph 的整体流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> JobGraph <span class="title">createJobGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">preValidate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure that all vertices start immediately</span></span><br><span class="line"><span class="comment">// 设置调度模式，streaming 模式下，调度模式是所有节点一起启动</span></span><br><span class="line">jobGraph.setScheduleMode(streamGraph.getScheduleMode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 广度优先遍历 StreamGraph 并且为每个 SteamNode 生成一个唯一确定的 hash id</span></span><br><span class="line"><span class="comment">// Generate deterministic hashes for the nodes in order to identify them across</span></span><br><span class="line"><span class="comment">// submission iff they didn't change.</span></span><br><span class="line"><span class="comment">// 保证如果提交的拓扑没有改变，则每次生成的 hash id 都是一样的，这里只要保证 source 的顺序是确定的，就可以保证最后生产的 hash id 不变</span></span><br><span class="line"><span class="comment">// 它是利用 input 节点的 hash 值及该节点在 map 中位置（实际上是 map.size 算的）来计算确定的</span></span><br><span class="line">Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes = defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate legacy version hashes for backwards compatibility</span></span><br><span class="line"><span class="comment">// 这个设置主要是为了防止 hash 机制变化时出现不兼容的情况</span></span><br><span class="line">List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes = <span class="keyword">new</span> ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line"><span class="keyword">for</span> (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 最重要的函数，生成 JobVertex/JobEdge/IntermediateDataSet 等，并尽可能地将多个 StreamNode 节点 chain 在一起</span></span><br><span class="line">setChaining(hashes, legacyHashes, chainedOperatorHashes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将每个 JobVertex 的入边集合也序列化到该 JobVertex 的 StreamConfig 中 (出边集合已经在 setChaining 的时候写入了)</span></span><br><span class="line">setPhysicalEdges();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 根据 group name，为每个 JobVertex 指定所属的 SlotSharingGroup 以及设置 CoLocationGroup</span></span><br><span class="line">setSlotSharingAndCoLocation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 其他设置</span></span><br><span class="line"><span class="comment">// 设置 ManagedMemory 因子</span></span><br><span class="line">setManagedMemoryFraction(</span><br><span class="line">Collections.unmodifiableMap(jobVertices),</span><br><span class="line">Collections.unmodifiableMap(vertexConfigs),</span><br><span class="line">Collections.unmodifiableMap(chainedConfigs),</span><br><span class="line">id -&gt; streamGraph.getStreamNode(id).getMinResources(),</span><br><span class="line">id -&gt; streamGraph.getStreamNode(id).getManagedMemoryWeight());</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkpoint相关的配置</span></span><br><span class="line">configureCheckpointing();</span><br><span class="line"></span><br><span class="line"><span class="comment">// savepoint相关的配置</span></span><br><span class="line">jobGraph.setSavepointRestoreSettings(streamGraph.getSavepointRestoreSettings());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户的第三方依赖包就是在这里（cacheFile）传给 JobGraph</span></span><br><span class="line">JobGraphGenerator.addUserArtifactEntries(streamGraph.getUserArtifacts(), jobGraph);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the ExecutionConfig last when it has been finalized</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 将 StreamGraph 的 ExecutionConfig 序列化到 JobGraph 的配置中</span></span><br><span class="line">jobGraph.setExecutionConfig(streamGraph.getExecutionConfig());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalConfigurationException(<span class="string">"Could not serialize the ExecutionConfig."</span> +</span><br><span class="line"><span class="string">"This indicates that non-serializable types (like custom serializers) were registered"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jobGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要围绕 Flink 源码中 &lt;code&gt;flink-streaming-java&lt;/code&gt; 模块。介绍下 StreamGraph 转成 JobGraph 的过程等。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink源码剖析-flink-streaming-java_StreamGraph</title>
    <link href="http://yoursite.com/2020/04/22/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-flink-streaming-java_StreamGraph/"/>
    <id>http://yoursite.com/2020/04/22/Flink源码剖析-flink-streaming-java_StreamGraph/</id>
    <published>2020-04-21T16:06:00.000Z</published>
    <updated>2020-04-22T16:55:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要围绕 Flink 源码中 <code>flink-streaming-java</code> 模块。介绍如何使用 DataStream API 进行 Flink 流任务开发，<code>flink-streaming-java</code> 模块中的一些重要类，贯穿着介绍下从 DataStream<br>API 到 StreamGraph 的构建过程。</p><a id="more"></a><h2 id="DataStream-API使用一览"><a href="#DataStream-API使用一览" class="headerlink" title="DataStream API使用一览"></a>DataStream API使用一览</h2><p>使用 DataStream API 通常有以下步骤：</p><ol><li>如何创建 Environment(Local、Remote) 并设置属性</li></ol><ul><li>setParallelism(int)：StreamExecutionEnvironment</li><li>setMaxParallelism(int)：StreamExecutionEnvironment</li><li>setBufferTimeout(long)：StreamExecutionEnvironment</li><li>enableCheckpointing(long,CheckpointingMode)：StreamExecutionEnvironment</li><li>setStateBackend(StateBackend)：StreamExecutionEnvironment</li><li>setStreamTimeCharacteristic(TimeCharacteristic)：void</li></ul><ol start="2"><li>如何读取数据？添加 Source 数据源获得 DataStream</li></ol><ul><li>fromElements(OUT …): DataStreamSource<out>   …</out></li><li>readTextFile(String): DataStreamSource<string>  …</string></li><li>readFile(FileInputFormat<out>,String): DataStreamSource<out> …</out></out></li><li>socketTextStream(String ,int ,String ,long): DataStreamSource<string>  …</string></li><li>createInput(InputFormat&lt;OUT,?&gt;,TypeInformation<out>): DataStreamSource<out> …</out></out></li><li>addSource(SourceFunction<out>,TypeInformation<out>): DataStreamSource<out> …</out></out></out></li></ul><ol start="3"><li>如何操作转换数据？</li></ol><p><img src="DataStream_API%E6%93%8D%E4%BD%9C%E6%A6%82%E8%A7%88.png" alt></p><ul><li>Basic Transformations<br>map、filter、flatMap</li><li>KeyedStream Transformations<br>keyBy、aggregations、reduce</li><li>MultiStream Transformations<br>union、connect、coMap、coFlatMap、split、select</li></ul><p><img src="DataStream%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2.png" alt></p><ul><li>Distribution Transformations<br>物理分组：</li></ul><table><thead><tr><th>关系</th><th>表示</th><th>图示</th></tr></thead><tbody><tr><td>global</td><td>全部发往第1个task</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_global.png" alt></td></tr><tr><td>broadcast</td><td>广播，复制上游的数据发送到所有下游节点</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_broadcast.png" alt></td></tr><tr><td>forward</td><td>上下游并发度一样时一对一发送</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_forward.png" alt></td></tr><tr><td>shuffle</td><td>随机均匀分配</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_shuffle.png" alt></td></tr><tr><td>reblance</td><td>Round-Robin（轮流分配）</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_reblance.png" alt></td></tr><tr><td>rescale</td><td>Local Round-Robin (本地轮流分配)，<br>只会看到本机的实例</td><td><img src="%E7%89%A9%E7%90%86%E5%88%86%E7%BB%84_rescale.png" alt></td></tr><tr><td>partitionCustom</td><td>自定义单播</td><td></td></tr></tbody></table><ol start="4"><li>如何输出数据？添加 Sink</li></ol><ul><li>writeAsText(String path): DataStreamSink<t> …</t></li><li>writeAsCsv(String path): DataStreamSink<t> …</t></li><li>addSink(SinkFunction<t> sinkFunction): DataStreamSink<t></t></t></li></ul><ol start="5"><li>如何提交执行？<br>DataStream 通过不同的算子不停地在 DataStream 上实现转换过滤等逻辑，最终将结果输出到 DataSink 中。<br>在 StreamExecutionEnvironment 内部使用一个 <code>List&lt;StreamTransformation&lt;?&gt;&gt; transformations</code> 来保留生成 DataStream 的所有转换。</li></ol><ul><li>execute()：JobExecutionResult</li></ul><p>我们看下基于 Flink DataStream API 的自带 WordCount 示例：实时统计单词数量，每来一个计算一次并输出一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************************************************************</span></span><br><span class="line"><span class="comment">// PROGRAM</span></span><br><span class="line"><span class="comment">// *************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ParameterTool params = ParameterTool.fromArgs(args);</span><br><span class="line"><span class="comment">// 1. 设置运行环境</span></span><br><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.getConfig().setGlobalJobParameters(params);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置数据源读取数据</span></span><br><span class="line">DataStream&lt;String&gt; text;</span><br><span class="line"><span class="keyword">if</span> (params.has(<span class="string">"input"</span>)) &#123;</span><br><span class="line"><span class="comment">// read the text file from given input path</span></span><br><span class="line">text = env.readTextFile(params.get(<span class="string">"input"</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// get default test text data</span></span><br><span class="line">text = env.fromElements(<span class="keyword">new</span> String[] &#123;</span><br><span class="line"><span class="string">"miao,She is a programmer"</span>,</span><br><span class="line"><span class="string">"wu,He is a programmer"</span>,</span><br><span class="line"><span class="string">"zhao,She is a programmer"</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 进行一系列转换</span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; counts =</span><br><span class="line"><span class="comment">// split up the lines in pairs (2-tuples) containing: (word,1)</span></span><br><span class="line">text.flatMap(<span class="keyword">new</span> Tokenizer())</span><br><span class="line"><span class="comment">// group by the tuple field "0" and sum up tuple field "1"</span></span><br><span class="line">.keyBy(<span class="number">0</span>).sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 配置数据汇写出数据</span></span><br><span class="line"><span class="keyword">if</span> (params.has(<span class="string">"output"</span>)) &#123;</span><br><span class="line">counts.writeAsText(params.get(<span class="string">"output"</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Printing result to stdout. Use --output to specify output path."</span>);</span><br><span class="line">counts.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 提交执行</span></span><br><span class="line">env.execute(<span class="string">"Streaming WordCount"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *************************************************************************</span></span><br><span class="line"><span class="comment">// USER FUNCTIONS</span></span><br><span class="line"><span class="comment">// *************************************************************************</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tokenizer</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> </span>&#123;</span><br><span class="line"><span class="comment">// normalize and split the line</span></span><br><span class="line">String[] tokens = value.toLowerCase().split(<span class="string">"\\W+"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// emit the pairs</span></span><br><span class="line"><span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line"><span class="keyword">if</span> (token.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(token, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="StreamExecutionEnvironment"><a href="#StreamExecutionEnvironment" class="headerlink" title="StreamExecutionEnvironment"></a>StreamExecutionEnvironment</h3><p>StreamExecutionEnvironment 是 Flink 流处理任务执行的上下文，是我们编写 Flink 程序的入口。根据执行环境的不同，选择不同的 StreamExecutionEnvironment 类，<br>有 LocalStreamEnvironment、RemoteStreamEnvironment 等。如下图：<br><img src="StreamExecutionEnvironment%E5%AD%90%E7%B1%BB.png" alt></p><p>StreamExecutionEnvironment 依赖 ExecutionConfig 类来设置并行度等，依赖 CheckpointConfig 设置 Checkpointing 等相关属性。<br><img src="StreamExecutionEnvironment%E7%B1%BB%E5%9B%BE.png" alt></p><p>这里再补充说明下 StreamExecutionEnvironment类中的重要属性和方法：<br><img src="StreamExecutionEnvironment%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.png" alt></p><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>Transformation 代表了从一个或多个 DataStream 生成新 DataStream 的操作。在 DataStream 上通过 map 等算子不断进行转换，就得到了由 Transformation<br>构成的图。当需要执行的时候，底层的这个图就会被转换成 StreamGraph 。</p><p>Transformation 有很多子类，如 SourceTransformation、OneInputTransformation、TwoInputTransformation、SideOutputTransformation 等，分别对应了 DataStream 上的不同转换操作。</p><p><img src="Transformation%E5%AD%90%E7%B1%BB.png" alt></p><p>每一个 Transformation 都有一个关联 id，这个 id 是全局递增的，还有 uid、slotSharingGroup、parallelism 等信息。</p><p><img src="Transformation%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7.png" alt></p><p>查看 Transformation 的其中两个子类 OneInputTransformation、TwoInputTransformation 的实现，都对应有输入 Transformation，也正是基于此才能还原出 DAG 的拓扑结构。</p><p>Transformation 在运行时并不对应着一个物理转换操作，有一些操作只是逻辑层面上的，比如 split/select/partitioning 等。<br>Transformations 组成的 graph ，也就是我们写代码时的图结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> Source              Source</span><br><span class="line">    +                   +</span><br><span class="line">    |                   |</span><br><span class="line">    v                   v</span><br><span class="line">Rebalance          HashPartition</span><br><span class="line">    +                   +</span><br><span class="line">    |                   |</span><br><span class="line">    |                   |</span><br><span class="line">    +------&gt;Union&lt;------+</span><br><span class="line">              +</span><br><span class="line">              |</span><br><span class="line">              v</span><br><span class="line">            Split</span><br><span class="line">              +</span><br><span class="line">              |</span><br><span class="line">              v</span><br><span class="line">            Select</span><br><span class="line">              +</span><br><span class="line">              v</span><br><span class="line">             Map</span><br><span class="line">              +</span><br><span class="line">              |</span><br><span class="line">              v</span><br><span class="line">            Sink</span><br></pre></td></tr></table></figure><p>但是，在运行时将生成如下操作图，split/select/partitioning 等转换操作会被编码到边中，这个边连接 sources 和 map 操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Source              Source</span><br><span class="line">   +                   +</span><br><span class="line">   |                   |</span><br><span class="line">   |                   |</span><br><span class="line">   +-------&gt;Map&lt;-------+</span><br><span class="line">             +</span><br><span class="line">             |</span><br><span class="line">             v</span><br><span class="line">            Sink</span><br></pre></td></tr></table></figure><h3 id="DataStream"><a href="#DataStream" class="headerlink" title="DataStream"></a>DataStream</h3><p>一个 DataStream 就代表了同一种类型元素构成的数据流。通过对 DataStream 应用 map/filter 等操作，就可以将一个 DataStream 转换成另一个 DataStream 。<br>这个转换的过程就是根据不同的操作生成不同的 Transformation ，并将其加入到 StreamExecutionEnvironment 的 transformations 列表中。</p><p>DataStream 的子类包括 DataStreamSource、KeyedStream、IterativeStream、SingleOutputStreamOperator。</p><p><img src="DataStream%E5%AD%90%E7%B1%BB.png" alt></p><p>除了 DataStream 及其子类以外，其它的表征数据流的类还有 ConnectedStreams、WindowedStream、AllWindowedStream，这些会在后续的文章中陆续介绍。</p><p>DataStream 类中的重要属性和方法：</p><p><img src="DataStream%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.png" alt></p><p>下面我们看下 map 操作是如何被添加进来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">map</span><span class="params">(MapFunction&lt;T, R&gt; mapper, TypeInformation&lt;R&gt; outputType)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将 MapFunction 封装成 StreamMap 这个 StreamOperator</span></span><br><span class="line"><span class="keyword">return</span> transform(<span class="string">"Map"</span>, outputType, <span class="keyword">new</span> StreamMap&lt;&gt;(clean(mapper)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">transform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String operatorName,</span></span></span><br><span class="line"><span class="function"><span class="params">TypeInformation&lt;R&gt; outTypeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">OneInputStreamOperator&lt;T, R&gt; operator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> doTransform(operatorName, outTypeInfo, SimpleOperatorFactory.of(operator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们看下其中一个比较重要的方法 doTransform ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">doTransform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String operatorName,</span></span></span><br><span class="line"><span class="function"><span class="params">TypeInformation&lt;R&gt; outTypeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">StreamOperatorFactory&lt;R&gt; operatorFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the output type of the input Transform to coax out errors about MissingTypeInfo</span></span><br><span class="line">transformation.getOutputType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 Transformation</span></span><br><span class="line">OneInputTransformation&lt;T, R&gt; resultTransform = <span class="keyword">new</span> OneInputTransformation&lt;&gt;(</span><br><span class="line"><span class="keyword">this</span>.transformation,</span><br><span class="line">operatorName,</span><br><span class="line">operatorFactory,</span><br><span class="line">outTypeInfo,</span><br><span class="line">environment.getParallelism());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Transformation 封装进 SingleOutputStreamOperator 返回</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">SingleOutputStreamOperator&lt;R&gt; returnStream = <span class="keyword">new</span> SingleOutputStreamOperator(environment, resultTransform);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到 StreamExecutionEnvironment 的 transformations 列表中</span></span><br><span class="line">getExecutionEnvironment().addOperator(resultTransform);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> returnStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StreamOperator"><a href="#StreamOperator" class="headerlink" title="StreamOperator"></a>StreamOperator</h3><p>在操作 DataStream 的时候，比如 <code>DataStream.map(MapFunction&lt;T, R&gt; mapper)</code> 时，都会传入一个自定义的 Function 。那么这些信息是如何保存在 Transformation 中的呢？<br>这里就引入了一个新的接口 StreamOpertor ，DataStream 上的每一个 Transformation 都对应了一个 StreamOperator，StreamOperator 是运行时的具体实现，会决定 UDF 的调用方式。</p><p>StreamOperator 的类继承关系如下：</p><p><img src="StreamOperator%E5%AD%90%E7%B1%BB.png" alt></p><p>接口 StreamOpertor 定义了对一个具体的算子的生命周期的管理。StreamOperator 的两个子接口 OneInputStreamOperator 和 TwoInputStreamOperator 提供了数据流中具体元素的操作方法，而 AbstractUdfStreamOperator 抽象子类则提供了自定义处理函数对应的算子的基本实现：</p><p><img src="StreamOperator%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.png" alt></p><p>下面我们还是拿 map 举例，map 操作对应的 StreamOperator 为 StreamMap ，继承了 AbstractUdfStreamOperator 类，实现了 OneInputStreamOperator 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMap</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractUdfStreamOperator</span>&lt;<span class="title">OUT</span>, <span class="title">MapFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt;&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">OneInputStreamOperator</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StreamMap</span><span class="params">(MapFunction&lt;IN, OUT&gt; mapper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(mapper);</span><br><span class="line">chainingStrategy = ChainingStrategy.ALWAYS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">output.collect(element.replace(userFunction.map(element.getValue())));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，我们可以知道通过 DataStream -&gt; Function -&gt; StreamOperator -&gt; StreamTransformation 这种依赖关系，就可以完成 DataStream 的转换，并且可以保存数据流和应用在流上<br>的算子之间的关系。</p><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><img src="Function%E5%AD%90%E7%B1%BB.png" alt></p><h3 id="StreamGraph"><a href="#StreamGraph" class="headerlink" title="StreamGraph"></a>StreamGraph</h3><p>StreamGraph 是在 Client 端构造的。<br>了解 StreamGraph 之前我们首先要知道 StreamGraphGenerator 这个类，它会基于 StreamExecutionEnvironment 的 transformations 列表来生成 StreamGraph。</p><p>首先看下 StreamGraphGenerator 的 generate() 方法，这个方法会由触发程序执行的方法 StreamExecutionEnvironment.execute() 调用到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StreamGraph <span class="title">generate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">streamGraph = <span class="keyword">new</span> StreamGraph(executionConfig, checkpointConfig, savepointRestoreSettings);</span><br><span class="line">streamGraph.setStateBackend(stateBackend);</span><br><span class="line">streamGraph.setChaining(chaining);</span><br><span class="line">streamGraph.setScheduleMode(scheduleMode);</span><br><span class="line">streamGraph.setUserArtifacts(userArtifacts);</span><br><span class="line">streamGraph.setTimeCharacteristic(timeCharacteristic);</span><br><span class="line">streamGraph.setJobName(jobName);</span><br><span class="line">streamGraph.setBlockingConnectionsBetweenChains(blockingConnectionsBetweenChains);</span><br><span class="line"></span><br><span class="line">alreadyTransformed = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历 transformations 列表，递归调用 transform 方法。</span></span><br><span class="line"><span class="comment"> * 对于每一个 Transformation ，确保当前上游已经完成转换，转换成 StreamGraph 中的 StreamNode，并为上下游节点添加 StreamEdge</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (Transformation&lt;?&gt; transformation: transformations) &#123;</span><br><span class="line">transform(transformation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> StreamGraph builtStreamGraph = streamGraph;</span><br><span class="line"></span><br><span class="line">alreadyTransformed.clear();</span><br><span class="line">alreadyTransformed = <span class="keyword">null</span>;</span><br><span class="line">streamGraph = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> builtStreamGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在遍历 List<transformation> 生成 StreamGraph 时，会递归调用其 transform 方法。对于每一个 Transformation ，确保当前其上游已经完成转换。最终，部分 Transformation 节点被<br>转换为 StreamGraph 中的 StreamNode 节点，并会为上下游节点添加边 StreamEdge。下面看下 transform() 方法：</transformation></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;Integer&gt; <span class="title">transform</span><span class="params">(Transformation&lt;?&gt; transform)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line"><span class="keyword">return</span> alreadyTransformed.get(transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不同类型的 Transformation，分别调用对应的转换方法</span></span><br><span class="line"><span class="comment">// 只有 OneInputTransformation、TwoInputTransformation、SourceTransformation、SinkTransformation 会生成 StreamNode，</span></span><br><span class="line"><span class="comment">// 会生成 StreamNode.</span></span><br><span class="line"><span class="comment">// 像 Partitioning, split/select, union 这些是不包含物理转换操作的，会生成一个带有特定属性的虚拟节点，</span></span><br><span class="line"><span class="comment">// 当添加一条有虚拟节点指向下游节点的边时，会找到虚拟节点上游的物理节点，在两个物理节点之间添加边，并把虚拟转换操作的属性附着上去。</span></span><br><span class="line">Collection&lt;Integer&gt; transformedIds;</span><br><span class="line"><span class="keyword">if</span> (transform <span class="keyword">instanceof</span> OneInputTransformation&lt;?, ?&gt;) &#123;</span><br><span class="line">transformedIds = transformOneInputTransform((OneInputTransformation&lt;?, ?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> TwoInputTransformation&lt;?, ?, ?&gt;) &#123;</span><br><span class="line">transformedIds = transformTwoInputTransform((TwoInputTransformation&lt;?, ?, ?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SourceTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSource((SourceTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SinkTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSink((SinkTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> UnionTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformUnion((UnionTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SplitTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSplit((SplitTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SelectTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSelect((SelectTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> FeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformFeedback((FeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> CoFeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformCoFeedback((CoFeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> PartitionTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformPartition((PartitionTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SideOutputTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds = transformSideOutput((SideOutputTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown transformation: "</span> + transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> transformedIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于另外一部分 Transformation ，如 partitioning, split/select, union，并不包含真正的物理转换操作，是不会生成 StreamNode 的，而是生成一个带有特定属性的虚拟节点。<br>当添加一条有虚拟节点指向下游节点的边时，会找到虚拟节点上游的物理节点，在两个物理节点之间添加边，并把虚拟转换操作的属性附着上去。下面我们首先看下 transformOneInputTransform() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;IN, OUT&gt; <span class="function">Collection&lt;Integer&gt; <span class="title">transformOneInputTransform</span><span class="params">(OneInputTransformation&lt;IN, OUT&gt; transform)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先确保上游节点完成转换</span></span><br><span class="line">Collection&lt;Integer&gt; inputIds = transform(transform.getInput());</span><br><span class="line"></span><br><span class="line"><span class="comment">// the recursive call might have already transformed this</span></span><br><span class="line"><span class="comment">// 由于是递归调用的，可能已经完成了转换</span></span><br><span class="line"><span class="keyword">if</span> (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line"><span class="keyword">return</span> alreadyTransformed.get(transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定共享资源组，如果用户没有指定，默认是 default</span></span><br><span class="line">String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 StreamGraph 中添加 Operator，这一步会生成对应的 StreamNode</span></span><br><span class="line">streamGraph.addOperator(transform.getId(),</span><br><span class="line">slotSharingGroup,</span><br><span class="line">transform.getCoLocationGroupKey(),</span><br><span class="line">transform.getOperatorFactory(),</span><br><span class="line">transform.getInputType(),</span><br><span class="line">transform.getOutputType(),</span><br><span class="line">transform.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 stateKey</span></span><br><span class="line"><span class="keyword">if</span> (transform.getStateKeySelector() != <span class="keyword">null</span>) &#123;</span><br><span class="line">TypeSerializer&lt;?&gt; keySerializer = transform.getStateKeyType().createSerializer(executionConfig);</span><br><span class="line">streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 parallelism</span></span><br><span class="line"><span class="keyword">int</span> parallelism = transform.getParallelism() != ExecutionConfig.PARALLELISM_DEFAULT ?</span><br><span class="line">transform.getParallelism() : executionConfig.getParallelism();</span><br><span class="line">streamGraph.setParallelism(transform.getId(), parallelism);</span><br><span class="line">streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每一个物理节点的转换上</span></span><br><span class="line"><span class="comment">// 依次连接到上游 input 节点，创建 StreamEdge，在输入节点和当前节点之间建立边的连接</span></span><br><span class="line"><span class="keyword">for</span> (Integer inputId: inputIds) &#123;</span><br><span class="line">streamGraph.addEdge(inputId, transform.getId(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Collections.singleton(transform.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看下 StreamGraph 中对应的添加节点的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;IN, OUT&gt; <span class="function"><span class="keyword">void</span> <span class="title">addOperator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Integer vertexID,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable String slotSharingGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable String coLocationGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">StreamOperatorFactory&lt;OUT&gt; operatorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">TypeInformation&lt;IN&gt; inTypeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">TypeInformation&lt;OUT&gt; outTypeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">String operatorName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (operatorFactory.isStreamSource()) &#123;</span><br><span class="line"><span class="comment">// 从传入的 StreamOperatorFactory 得知当前 operator 代表的是 source 流。SourceStreamTask</span></span><br><span class="line">addNode(vertexID, slotSharingGroup, coLocationGroup, SourceStreamTask.class, operatorFactory, operatorName);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 上游节点输入流，OneInputStreamTask</span></span><br><span class="line">addNode(vertexID, slotSharingGroup, coLocationGroup, OneInputStreamTask.class, operatorFactory, operatorName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> StreamNode <span class="title">addNode</span><span class="params">(Integer vertexID,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable String slotSharingGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable String coLocationGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">// 表示该节点在 TM 中运行时的实际任务类型</span></span></span><br><span class="line"><span class="function"><span class="params">Class&lt;? extends AbstractInvokable&gt; vertexClass,</span></span></span><br><span class="line"><span class="function"><span class="params">StreamOperatorFactory&lt;?&gt; operatorFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">String operatorName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (streamNodes.containsKey(vertexID)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Duplicate vertexID "</span> + vertexID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造 StreamNode</span></span><br><span class="line">StreamNode vertex = <span class="keyword">new</span> StreamNode(</span><br><span class="line">vertexID,</span><br><span class="line">slotSharingGroup,</span><br><span class="line">coLocationGroup,</span><br><span class="line">operatorFactory,</span><br><span class="line">operatorName,</span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;OutputSelector&lt;?&gt;&gt;(),</span><br><span class="line">vertexClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存在 streamNodes 这个 map 中</span></span><br><span class="line">streamNodes.put(vertexID, vertex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们再看下 transformPartition() 非物理节点的转换方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;Integer&gt; <span class="title">transformPartition</span><span class="params">(PartitionTransformation&lt;T&gt; partition)</span> </span>&#123;</span><br><span class="line">Transformation&lt;T&gt; input = partition.getInput();</span><br><span class="line">List&lt;Integer&gt; resultIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历转换上游节点</span></span><br><span class="line">Collection&lt;Integer&gt; transformedIds = transform(input);</span><br><span class="line"><span class="keyword">for</span> (Integer transformedId: transformedIds) &#123;</span><br><span class="line"><span class="keyword">int</span> virtualId = Transformation.getNewNodeId();</span><br><span class="line"><span class="comment">// 添加虚拟的 Partition 节点</span></span><br><span class="line">streamGraph.addVirtualPartitionNode(</span><br><span class="line">transformedId, virtualId, partition.getPartitioner(), partition.getShuffleMode());</span><br><span class="line">resultIds.add(virtualId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resultIds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVirtualPartitionNode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Integer originalId,</span></span></span><br><span class="line"><span class="function"><span class="params">Integer virtualId,</span></span></span><br><span class="line"><span class="function"><span class="params">StreamPartitioner&lt;?&gt; partitioner,</span></span></span><br><span class="line"><span class="function"><span class="params">ShuffleMode shuffleMode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (virtualPartitionNodes.containsKey(virtualId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already has virtual partition node with id "</span> + virtualId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个虚拟节点到 virtualPartitionNodes 中，后续添加边的时候会连接到实际的物理节点</span></span><br><span class="line">virtualPartitionNodes.put(virtualId, <span class="keyword">new</span> Tuple3&lt;&gt;(originalId, partitioner, shuffleMode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的物理节点执行添加边的操作时，会判断上游是不是虚拟节点，如果是则会一直递归调用，将虚拟节点的信息添加到边中，直到连接到一个物理转换节点为止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEdgeInternal</span><span class="params">(Integer upStreamVertexID,</span></span></span><br><span class="line"><span class="function"><span class="params"> Integer downStreamVertexID,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span> typeNumber,</span></span></span><br><span class="line"><span class="function"><span class="params"> StreamPartitioner&lt;?&gt; partitioner,</span></span></span><br><span class="line"><span class="function"><span class="params"> List&lt;String&gt; outputNames,</span></span></span><br><span class="line"><span class="function"><span class="params"> OutputTag outputTag,</span></span></span><br><span class="line"><span class="function"><span class="params"> ShuffleMode shuffleMode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断是不是虚拟节点上的边，如果是，则找到虚拟节点上游对应的物理节点</span></span><br><span class="line"><span class="comment">// 在两个物理节点之间添加边，并把对应的 outputTag 或 StreamPartitioner 添加到 StreamEdge 中</span></span><br><span class="line"><span class="keyword">if</span> (virtualSideOutputNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (virtualSelectNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (virtualPartitionNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line"><span class="keyword">int</span> virtualId = upStreamVertexID;</span><br><span class="line">upStreamVertexID = virtualPartitionNodes.get(virtualId).f0;</span><br><span class="line"><span class="keyword">if</span> (partitioner == <span class="keyword">null</span>) &#123;</span><br><span class="line">partitioner = virtualPartitionNodes.get(virtualId).f1;</span><br><span class="line">&#125;</span><br><span class="line">shuffleMode = virtualPartitionNodes.get(virtualId).f2;</span><br><span class="line">addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, outputNames, outputTag, shuffleMode);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个物理节点</span></span><br><span class="line">StreamNode upstreamNode = getStreamNode(upStreamVertexID);</span><br><span class="line">StreamNode downstreamNode = getStreamNode(downStreamVertexID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If no partitioner was specified and the parallelism of upstream and downstream</span></span><br><span class="line"><span class="comment">// operator matches use forward partitioning, use rebalance otherwise.</span></span><br><span class="line"><span class="keyword">if</span> (partitioner == <span class="keyword">null</span> &amp;&amp; upstreamNode.getParallelism() == downstreamNode.getParallelism()) &#123;</span><br><span class="line">partitioner = <span class="keyword">new</span> ForwardPartitioner&lt;Object&gt;();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (partitioner == <span class="keyword">null</span>) &#123;</span><br><span class="line">partitioner = <span class="keyword">new</span> RebalancePartitioner&lt;Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (partitioner <span class="keyword">instanceof</span> ForwardPartitioner) &#123;</span><br><span class="line"><span class="keyword">if</span> (upstreamNode.getParallelism() != downstreamNode.getParallelism()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Forward partitioning does not allow "</span> +</span><br><span class="line"><span class="string">"change of parallelism. Upstream operation: "</span> + upstreamNode + <span class="string">" parallelism: "</span> + upstreamNode.getParallelism() +</span><br><span class="line"><span class="string">", downstream operation: "</span> + downstreamNode + <span class="string">" parallelism: "</span> + downstreamNode.getParallelism() +</span><br><span class="line"><span class="string">" You must use another partitioning strategy, such as broadcast, rebalance, shuffle or global."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shuffleMode == <span class="keyword">null</span>) &#123;</span><br><span class="line">shuffleMode = ShuffleMode.UNDEFINED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 StreamEdge，带着 outputTag 、StreamPartitioner 等属性</span></span><br><span class="line">StreamEdge edge = <span class="keyword">new</span> StreamEdge(upstreamNode, downstreamNode, typeNumber, outputNames, partitioner, outputTag, shuffleMode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别将 StreamEdge 添加到上游节点和下游节点</span></span><br><span class="line"><span class="comment">// 获取上游节点，添加 OutEdge</span></span><br><span class="line">getStreamNode(edge.getSourceId()).addOutEdge(edge);</span><br><span class="line">getStreamNode(edge.getTargetId()).addInEdge(edge);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StreamGraph 是 Flink 任务最接近用户逻辑的 DAG 表示，后面到具体执行时还会进行一系列转换。</p><h3 id="类之间的层级关系"><a href="#类之间的层级关系" class="headerlink" title="类之间的层级关系"></a>类之间的层级关系</h3><p><img src="DataStream_API%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB.png" alt></p><p>map 转换将用户自定义函数 MapFunction 包装到 StreamMap 这个 StreamOperator 中，再将 StreamMap 包装到 OneInputTransformation，最后该 transformation 会存到<br>StreamExecutionEnvironment 中。当调用 env.execute() 时，会遍历其中的 transformations 集合构造出 StreamGraph 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要围绕 Flink 源码中 &lt;code&gt;flink-streaming-java&lt;/code&gt; 模块。介绍如何使用 DataStream API 进行 Flink 流任务开发，&lt;code&gt;flink-streaming-java&lt;/code&gt; 模块中的一些重要类，贯穿着介绍下从 DataStream&lt;br&gt;API 到 StreamGraph 的构建过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="http://yoursite.com/2020/04/14/UML/"/>
    <id>http://yoursite.com/2020/04/14/UML/</id>
    <published>2020-04-14T08:58:11.000Z</published>
    <updated>2020-04-15T13:04:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Java开发中的软技能之一，UML图。UML 即统一建模语言，它是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。<br>UML 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。<br>我们知道开发一个软件系统，不光只有程序员参与，另外还有分析师、设计师、测试人员等等，为了让不同人能够理解交流这个软件系统，就诞生了这么一套语言。<br>这套语言是由图表组成的，最常用的有：用例图、类图、时序图、状态图、活动图、组件图和部署图等。大致可以将这些图归类为结构图和行为图：</p><ul><li>结构图是静态图，如类图、对象图等</li><li>行为图是动态图，像序列图、协作图等</li></ul><a id="more"></a><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。<br>许多项目立项文档、需求分析文档中，都会有关 UML 类图的涉及。类图基本上是一个系统的静态视图的图形表示，代表应用的不同方面，集合类图就表示整个系统。<br>画类图需要关注以下几点：</p><ul><li>类图中的名称应该是有意义的描述，并且是面向系统的</li><li>画类图前应该先确定每个元素之间的关系</li><li>类图中每个类职责（属性和方法）应该清晰标明</li><li>对于每个类的属性应改精简，不必要的属性将使图表变得复杂</li></ul><h3 id="可见性符号"><a href="#可见性符号" class="headerlink" title="可见性符号"></a>可见性符号</h3><p><code>+</code> public<br><code>#</code> protected<br><code>-</code> private</p><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><table><thead><tr><th>关系</th><th>表示</th><th>图示</th><th>解释</th><th>结构和语义</th></tr></thead><tbody><tr><td>泛化（Generalization）</td><td><img src="%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB.png" alt></td><td>A继承B，B为非抽象类</td><td>继承结构</td></tr><tr><td>实现（Realization）</td><td><img src="%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.png" alt></td><td>A实现B，B为抽象类或接口</td><td>继承结构</td></tr><tr><td>聚合（Aggregation）</td><td><img src="%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.png" alt></td><td>A聚合到B上，B由A组成</td><td>表示整体由部分构成的语义。<br> (不是强依赖：整体不存在了，部分仍然存在)</td></tr><tr><td>组合（Composition）</td><td><img src="%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt></td><td>A组成B，B由A组成</td><td>表示整体由部分构成的语义。<br> (强依赖：整体不存在了，部分也不存在了)</td></tr><tr><td>关联（Association）</td><td><img src="%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.png" alt></td><td>A知道B，但是B不知道A</td><td>不同类的对象之间的结构关系。<br> 不强调方向，表示对象间相互知道。</td></tr><tr><td>依赖（Dependence）</td><td><img src="%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA.png" alt></td><td><img src="%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt></td><td>A依赖于B</td><td>描述一个对象在运行期间会用到另一个对象的关系。<br> 应该保持单向依赖，杜绝双向依赖。</td></tr></tbody></table><p>首先，我们给出一张具有整体关系的 UML 类图，后面再逐步分解说明。</p><p><img src="UML%E7%B1%BB%E5%9B%BE%E6%95%B4%E4%BD%93%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><h4 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h4><p>泛化即 Java 中的继承关系，是类与类或者接口与接口之间最常见的关系。</p><p><img src="%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><p>两个子类 Fish 和 Cat 分别继承自 Animal。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> isPet;</span><br><span class="line"><span class="keyword">private</span> String state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String fishType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> hasFeet;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playToy</span><span class="params">(Doll doll)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h4><p>实现即 Java 中类对抽象类或接口的实现关系，是类与接口之间最常见的关系。</p><p><img src="%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ToyAction</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toyMoved</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doll</span> <span class="keyword">implements</span> <span class="title">ToyAction</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> Body body;</span><br><span class="line"><span class="keyword">public</span> Cloth cloth;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toyMoved</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h4><p>关联关系是一种比较强的关系，他们的关系是比较持久的、稳定的，而且双方的关系一般是平等的，分单向关联、双向关联等。<br>表现在代码层面，就是类 B 作为类 A 的属性，也可能是类 A 引用了一个类型为 B 的全局变量。如 Person 类，他拥有一个宠物猫，他们之间是关联关系。</p><p><img src="%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Cat pet;</span><br><span class="line"><span class="keyword">public</span> Head head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) 单向关联<br>用带箭头的实线表示，箭头指向被引用或被包含的类。上面演示的就是一个单向关联关系。</p><p>(2) 双向关联<br>用不带箭头的实线来连接两个类，所谓的双向关联就是双方各自持有对方类型的成员变量。例如 Customer 类中维护一个 Product[] 数组，表示一个顾客购买了哪些商品；在 Product 类中维护一个 Customer 类型的成员变量表示这个产品被哪个顾客所购买。</p><p><img src="%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><p>(3) 自关联<br>系统中可能会存在一些类的属性对象类型为该类本身，例如二叉树中的 TreeNode 定义。</p><p><img src="%E8%87%AA%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><h4 id="依赖（Dependence）"><a href="#依赖（Dependence）" class="headerlink" title="依赖（Dependence）"></a>依赖（Dependence）</h4><p>就是一个类 A 使用到了另一个类 B ，这种使用关系是具有偶然性的、临时性的、非常弱的，但是类 B 的变化会影响到 A。<br>表现在代码层面，就是类 B 作为参数被类 A 在某个 method 方法中使用。如 Cat 类的 playToy 方法的参数就引用了 Doll 类，因此他们是依赖关系。</p><p><img src="%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><h4 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h4><p>聚合关系强调的整体和部分、拥有的关系，即 has-a 的关系，其中部分可以脱离整体而存在，他们可以具有各自的生命周期。<br>如 Doll 类由 Body 和 Cloth 组成，即使失去了 Cloth，Doll 也可以正常存在。<br>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</p><p><img src="%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cloth</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h4><p>组合关系也是强调整体和部分的关系，不同的是部分不能脱离整体而存在，它体现的是一种 contains-a 的关系，这种关系比聚合更强，也成为强聚合。<br>整体的生命周期结束也就意味着部分的生命周期结束，如人和大脑。<br>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</p><p><img src="%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类关系强度：组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><p>下面我们在 idea 中构建这几个类，将这几个放到同一 package 下，看下 idea 自动生成的UML类图：<br><img src="idea%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84UML%E7%B1%BB%E5%9B%BE.png" alt></p><p>和我们给出整体关系 UML 类图基本一致，区别是聚合关系和组合关系都是用实心菱形表示的。</p><h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><p>是类图的一个具体实例。</p><h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><p>从用户的角度出发描述系统的功能、需求，展示系统外部的各类角色与系统内部的各种用例之间的关系。</p><h2 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h2><p>表示对象之间动态合作的关系。</p><h2 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h2><p>描述对象之间的协作关系。</p><h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>描述系统中各种活动的执行顺序。</p><h2 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h2><p>描述一类对象的所有可能的状态以及事件发生时状态的转移条件。</p><h2 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h2><p>定义系统中软硬件的物理体系结构。</p><h2 id="UML组件图"><a href="#UML组件图" class="headerlink" title="UML组件图"></a>UML组件图</h2><p>描述代码部件的物理结构以及各部件之间的依赖关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍Java开发中的软技能之一，UML图。UML 即统一建模语言，它是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。&lt;br&gt;UML 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。&lt;br&gt;我们知道开发一个软件系统，不光只有程序员参与，另外还有分析师、设计师、测试人员等等，为了让不同人能够理解交流这个软件系统，就诞生了这么一套语言。&lt;br&gt;这套语言是由图表组成的，最常用的有：用例图、类图、时序图、状态图、活动图、组件图和部署图等。大致可以将这些图归类为结构图和行为图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构图是静态图，如类图、对象图等&lt;/li&gt;
&lt;li&gt;行为图是动态图，像序列图、协作图等&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink源码剖析-flink-annotations</title>
    <link href="http://yoursite.com/2020/04/13/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-flink-annotations/"/>
    <id>http://yoursite.com/2020/04/13/Flink源码剖析-flink-annotations/</id>
    <published>2020-04-13T04:05:32.000Z</published>
    <updated>2020-04-14T06:35:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将先介绍下java注解的实现，再说明下Flink自定义的几个注解及其使用。</p><a id="more"></a><h2 id="java注解"><a href="#java注解" class="headerlink" title="java注解"></a>java注解</h2><p>注解在一定程度上是在把元数据与源代码文件结合在一起，而不是保存在外部文档中这一大的趋势下所催生的。注解可以提供用来完整的描述程序所需的信息，而这些信息是无法用Java来表达的。<br>因此，注解存储有关程序的额外信息，是可以由编译器来测试和验证的。注解还可以用来生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。通过使用注解，我们可以将这些元数据保存在Java源代码中，并利用 annotation API 为自己的注解构造处理工具，同时注解的优点还包括：更加干净易读的代码以及编译器类型检查等。</p><p>注解的使用场景：</p><ul><li>提供信息给编译器：编译器可以利用注解来探测错误和警告信息</li><li>编译阶段时的处理：软件工具可以利用注解信息来生成代码，HTML文档或其他相应处理</li><li>运行时的处理：某些注解可以在程序运行时接受代码的提取</li></ul><h3 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h3><ol><li><p>按运行机制划分<br>源码注解：只在源码中存在，编译成 .class 文件就不存在了<br>编译时注解：在源码和 .class 文件中都存在，像前面的 @Override、@Deprecated、@SuppressWarnings 都属于编译时注解<br>运行时注解：在运行阶段还有作用，甚至会影响运行逻辑，像 @Autowired 就属于运行时注解，它会在程序运行时把你的成员变量自动的注入进来</p></li><li><p>按来源划分<br>来自 JDK 的注解<br>来自第三方的注解<br>自定义注解</p></li><li><p>元注解</p></li></ol><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>负责注解的创建，是注解的注解。</p><p>元注解的类图关系如下：<br><img src="Annotation%E5%85%83%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9B%BE.png" alt></p><ol><li>@Target</li></ol><p>表示注解可以用在什么地方。ElementType可以是：</p><ul><li>TYPE：类，接口，枚举类上</li><li>FIELD：字段上，包括枚举实例</li><li>METHOD：方法上</li><li>PARAMETER：参数前</li><li>CONSTRUCTOR：构造函数上</li><li>LOCAL_VARIABLE：局部变量上</li><li>ANNOTATION_TYPE：注解类上</li><li>PACKAGE：包上</li><li>TYPE_PARAMETER：</li><li>TYPE_USE：<br>可以是某一个值或者以逗号分隔的形式指定多个值，如果想要将注解应用于所有的ElementType，也可以省去 @Target 元注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array of the kinds of elements an annotation type</span></span><br><span class="line"><span class="comment">     * can be applied to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@Retention</li></ol><p>表示需要在什么级别上保留该注解信息。RetentionPolicy可以是：</p><ul><li>SOURCE：注解将被编译器丢弃</li><li>CLASS：注解在class中可用，但会被VM丢弃</li><li>RUNTIME：VM在运行期也将保留注解，因此可以通过反射机制读取注解信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the retention policy.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the retention policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@Documented</li></ol><p>将此注解中的元素包含到javadoc中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Documented &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>@Inherited</li></ol><p>允许子类继承父类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>@Repeatable</li></ol><p>注解的值可以是多个，元素是一个容器注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the</span></span><br><span class="line"><span class="comment">     * repeatable annotation type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the containing annotation type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h3><ol><li>基本语法</li></ol><p>使用 @interface 关键字定义注解，在注解上添加元注解。一般还要为注解添加元素，没有元素的注解称为标识注解。<br>注解只有成员变量，没有方法。注解的成员变量在注解的定义中以”无形参的方法”形式来声明，其方法名定义了该成员变量的名字，返回值定义了该成员变量的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>注解元素可用的类型</li></ol><ul><li>所有基本类型（int,float,boolean等）</li><li>String</li><li>Class</li><li>enum</li><li>Annotation</li><li>以上类型的数组</li></ul><p>如果使用了其他类型，那编译器就会报错。也不允许使用任何包装类型。注解也可以作为元素的类型，也就是说注解可以嵌套。</p><ol start="3"><li>注解元素的默认值限制</li></ol><p>编译器对注解元素的默认值有些过分挑剔。首先，注解元素不能有不确定的值。也就是说，注解元素要么具有默认值，要么在使用注解时设置元素值。</p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>所有的注解都继承自 java.lang.annotation.Annotation 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 中有几种内置的注解：<br><img src="JDK%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3.png" alt></p><ol><li>@Override</li></ol><p>表示当前的方法定义将覆盖超类中的方法。如果不小心拼写错误或者方法签名对不上被覆盖的方法，编译器就会发出错误提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> javac Override.java</span><br><span class="line"><span class="meta">$</span> javap -c Override.class</span><br></pre></td></tr></table></figure><p>得到如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Override.java&quot;</span><br><span class="line">public interface java.lang.Override extends java.lang.annotation.Annotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出，注解的本质就是一个继承了 Annotation 接口的接口，是一种典型的标记式注解。<br>一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名，如果没有，自然不能编译通过。<br>编译器只能识别已经熟知的注解类，比如 JDK 内置的几个注解，而我们自定义的注解，编译器是不会知道这个注解的作用的，当然也不知道应该如何处理。</p><ol start="2"><li>@Deprecated</li></ol><p>依然是一种标记式注解，永久存在，可以修饰所有类型，被标记的类、方法、字段等已经不再被推荐使用了，可能下一个版本就会删除。当然，编译器并不会强制要求你做什么，只是会在对象上画出一道线，建议你使用某个替代者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@SuppressWarnings</li></ol><p>抑制告警。它有一个 value 属性需要主动传值，传入需要被抑制的警告类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下 Date 的构造函数是过时的，在 main() 方法上加上 @SuppressWarning(value = “deprecated”) 注解后，编译器就不会再对这种告警进行检查了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarning</span>(value = <span class="string">"deprecated"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的提取"><a href="#注解的提取" class="headerlink" title="注解的提取"></a>注解的提取</h3><p>解析一个类或方法的注解往往有两种形式：</p><ul><li>一种是编译期直接扫描：编译器在对java代码编译字节码的过程中会检测到某个类或方法被一些注解修饰，它就会对这些注解进行某些处理。</li><li>一种是运行期反射。</li></ul><p>上文中有创建注解 TestAnnotation ，下面我们来写一个注解的提取类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span>(<span class="string">"defaultValue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注解通过反射获取，通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</span></span><br><span class="line"><span class="keyword">boolean</span> hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);</span><br><span class="line"><span class="keyword">if</span> (hasAnnotation) &#123;</span><br><span class="line"><span class="comment">// 通过 getAnnotation() 方法来获取 Annotation 对象实例</span></span><br><span class="line">TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);</span><br><span class="line">System.out.println(<span class="string">"id:"</span> + testAnnotation.id());</span><br><span class="line">System.out.println(<span class="string">"msg:"</span> + testAnnotation.msg());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们前面说过，注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理生成了一个实现自定义注解（接口）的代理类。</p><p>运行 Test 类之前，先设置如下 VM 参数，让其生成代理类 class 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* jdk动态代理 设置此系统属性,让JVM生成的Proxy类写入文件.保存路径为：com/sun/proxy(如果不存在请手工创建) */</span><br><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</span><br><span class="line">/* cglib动态代理 设置此系统属性,让JVM生成的Proxy类写入文件.保存路径为：com/sun/proxy(如果不存在请手工创建) */</span><br><span class="line">-Dcglib.debugLocation=com/sun/proxy</span><br></pre></td></tr></table></figure><p>将生成的代理类 class 文件反编译成可视化文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd ./com/sun/proxy</span><br><span class="line"><span class="meta">$</span> javap -c \$Proxy1.class &gt; Proxy1</span><br></pre></td></tr></table></figure><p>查看代理类内容，代理类实现接口 TestAnnotation 并重写其所有方法，包括id()、msg()、value()以及接口 TestAnnotation 从 Annotation 接口继承而来的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public final class com.sun.proxy.$Proxy1 extends java.lang.reflect.Proxy implements org.apache.flink.annotation.TestAnnotation &#123;</span><br><span class="line">  public com.sun.proxy.$Proxy1(java.lang.reflect.InvocationHandler) throws ;</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: aload_1</span><br><span class="line">       2: invokespecial #8                  // Method java/lang/reflect/Proxy.&quot;&lt;init&gt;&quot;:(Ljava/lang/reflect/InvocationHandler;)V</span><br><span class="line">       5: return</span><br><span class="line"></span><br><span class="line">  public final boolean equals(java.lang.Object) throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final java.lang.String toString() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final java.lang.String msg() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final java.lang.Class annotationType() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final int id() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final int hashCode() throws ;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  public final java.lang.String value() throws ;</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #16                 // Field java/lang/reflect/Proxy.h:Ljava/lang/reflect/InvocationHandler;</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: getstatic     #81                 // Field m3:Ljava/lang/reflect/Method;</span><br><span class="line">       8: aconst_null</span><br><span class="line">       9: invokeinterface #28,  4           // InterfaceMethod java/lang/reflect/InvocationHandler.invoke:(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      14: checkcast     #52                 // class java/lang/String</span><br><span class="line">      17: areturn</span><br><span class="line">      18: athrow</span><br><span class="line">      19: astore_1</span><br><span class="line">      20: new           #42                 // class java/lang/reflect/UndeclaredThrowableException</span><br><span class="line">      23: dup</span><br><span class="line">      24: aload_1</span><br><span class="line">      25: invokespecial #45                 // Method java/lang/reflect/UndeclaredThrowableException.&quot;&lt;init&gt;&quot;:(Ljava/lang/Throwable;)V</span><br><span class="line">      28: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           0    18    18   Class java/lang/Error</span><br><span class="line">           0    18    18   Class java/lang/RuntimeException</span><br><span class="line">           0    18    19   Class java/lang/Throwable</span><br><span class="line"></span><br><span class="line">  static &#123;&#125; throws ;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 InvocationHandler 指的就是 AnnotationInvocationHandler，它是 Java 中专门用于处理注解的 handler，下面就来让我们看看这个类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6182022883658399397L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解元素属性的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line"></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类代理了 TestAnnotation 接口中的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        String member = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">        <span class="comment">// 如果当前调用的是 toString、equals、hashCode、annotationType。AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。</span></span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">"equals"</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">            paramTypes[<span class="number">0</span>] == Object.class)</span><br><span class="line">            <span class="keyword">return</span> equalsImpl(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">assert</span> paramTypes.length == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">"toString"</span>))</span><br><span class="line">            <span class="keyword">return</span> toStringImpl();</span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">"hashCode"</span>))</span><br><span class="line">            <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">        <span class="keyword">if</span> (member.equals(<span class="string">"annotationType"</span>))</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">        <span class="comment">// 从我们注解的 map 中获取这个注解属性对应的值，即通过方法名返回注解属性值。</span></span><br><span class="line">        Object result = memberValues.get(member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteAnnotationException(type, member);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">            <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">            result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><ol><li>可重复注解</li></ol><p>创建容器注解 Persons，容器注解本身也是一个注解，是用来存放其他注解的地方。它必须要有一个 value 属性，属性类型是一个被 @Repeatable 注解过的注解数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Persons &#123;</span><br><span class="line">Person[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @Repeatable 注解了 Person，而 @Repeatable 后面括号中的类是一个容器注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Person &#123;</span><br><span class="line"><span class="function">String <span class="title">role</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 Superman 这个类贴上多个角色标签。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Person</span>(role=<span class="string">"Painter"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"Musician"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"Actor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Superman</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试用例注解<br>实现一个注解，用来跟踪一个项目中的用例。如果一个方法实现了某个用例的需求，那么可以为此方法加上该注解。于是，项目经理通过计算已经实现的用例，就可以很好的掌控项目的进展。而且把实现方法和用例绑定，如果要更新或修改系统的业务逻辑，维护该项目的开发人员也可以很容易的在代码中找到对应的用例。</li></ol><p>定义 UseCase 注解，id 表示用例编号，description 设置了默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用例id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用例描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义需求实现类 PasswordUtils，每一个方法都对应一个需求用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">47</span> , description = <span class="string">"Passwords must contain at least one numeric"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password.matches(<span class="string">"\\w*\\d\\w*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(password).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">49</span>,description = <span class="string">"New passwords can't equal previously used ones"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkForNewPassword</span><span class="params">(List&lt;String&gt; prevPasswords, String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !prevPasswords.contains(password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有用来读取注解的工具，那注解也不会比注释更有用。使用注解的过程中，很重要的一部分就是创建与使用注解处理器。<br>下面实现了一个非常简单的注解处理器 UseCaseTracker ，将用它来读取 PasswordUtils 类，并使用反射机制查找 @UseCase 注解。<br>我们提供了一组 id 值，然后它会列出在 PasswordUtils 中找到的用例，以及缺失的用例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line"><span class="comment">// 返回指定类型的注解对象</span></span><br><span class="line">UseCase uc = m.getAnnotation(UseCase.class);</span><br><span class="line"><span class="keyword">if</span> (uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"Found Use Case: "</span> + uc.id() + <span class="string">" "</span> + uc.description());</span><br><span class="line">useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Integer i : useCases) &#123;</span><br><span class="line">System.out.println(<span class="string">"Warning: Missing use case-"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(useCases, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">50</span>);</span><br><span class="line">trackUseCases(useCases, PasswordUtils.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Found Use Case: 47 Passwords must contain at least one numeric</span><br><span class="line">Found Use Case: 48 no description</span><br><span class="line">Found Use Case: 49 New passwords can&apos;t equal previously used ones</span><br><span class="line">Warning: Missing use case-50</span><br></pre></td></tr></table></figure><ol start="3"><li>利用注解生成SQL语句</li></ol><p>定义表名注解，它告诉处理器，你需要把我这个类生成一个数据库 DDL 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DBTable &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库表表名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义数据库表字段约束的注解：是否为主键，是否可以为空，唯一性约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Constraints &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义表字段类型为 String 的注解：字符串长度，字段名， 字段约束。这里的字段约束就用到了嵌套注解的语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLString &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义表字段类型为 Integer 的注解：字段名，字段约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SQLInteger &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @Constraints</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 Member 类，应用了以上定义的注解。类的注解 @DBTable 给定了值 MEMBER，它将会用来作为表的名字。字段属性 firstName 和 lastName 都被注解为 @SQLString 类型，并分别设置了长度为 30 和 50。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DBTable</span>(name = <span class="string">"MEMBER"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SQLString</span>(len = <span class="number">30</span>)</span><br><span class="line">String firstName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SQLString</span>(len = <span class="number">50</span>)</span><br><span class="line">String lastName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SQLInteger</span></span><br><span class="line">Integer age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SQLString</span>(len = <span class="number">30</span>, constraints = <span class="meta">@Constraints</span>(primaryKey = <span class="keyword">true</span>))</span><br><span class="line">String handle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> memberCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现处理器 TableCreator ，它将读取一个类文件，检查其上的数据库表注解，并生成用来创建数据库表的 SQL 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">String className = Member.class.getName();</span><br><span class="line">Class&lt;?&gt; cl = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查类上是否带有 @DBTable 注解</span></span><br><span class="line">DBTable dbtable = cl.getAnnotation(DBTable.class);</span><br><span class="line"><span class="keyword">if</span> (dbtable == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"No DbTable annotations in class "</span> + className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取 @DBTable 注解的 name</span></span><br><span class="line">String tableName = dbtable.name();</span><br><span class="line"><span class="comment">// If the name is empty , use the Class name:</span></span><br><span class="line"><span class="keyword">if</span> (tableName.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">tableName = cl.getName().toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; columnDefs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 遍历 Member 类的所有字段</span></span><br><span class="line"><span class="keyword">for</span> (Field field : cl.getDeclaredFields()) &#123;</span><br><span class="line">String columnName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段属性上的所有注解</span></span><br><span class="line">Annotation[] annotations = field.getDeclaredAnnotations();</span><br><span class="line"><span class="keyword">if</span> (annotations.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// Not a db table column</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (annotations[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLInteger) &#123;</span><br><span class="line"><span class="comment">// 处理 @SQLInteger 注解的属性字段</span></span><br><span class="line">SQLInteger sInt = (SQLInteger) annotations[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Use field name if name not specified</span></span><br><span class="line"><span class="keyword">if</span> (sInt.name().length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">columnName = field.getName().toUpperCase();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">columnName = sInt.name();</span><br><span class="line">&#125;</span><br><span class="line">columnDefs.add(columnName + <span class="string">" INT"</span> + getConstraints(sInt.constraints()));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotations[<span class="number">0</span>] <span class="keyword">instanceof</span> SQLString) &#123;</span><br><span class="line"><span class="comment">// 处理 @SQLString 注解的属性字段</span></span><br><span class="line">SQLString sString = (SQLString) annotations[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Use field name if name not specified.</span></span><br><span class="line"><span class="keyword">if</span> (sString.name().length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">columnName = field.getName().toUpperCase();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">columnName = sString.name();</span><br><span class="line">&#125;</span><br><span class="line">columnDefs.add(columnName + <span class="string">" VARCHAR("</span> + sString.len() + <span class="string">")"</span> + getConstraints(sString.constraints()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder createCommand = <span class="keyword">new</span> StringBuilder(<span class="string">"CREATE TABLE "</span> + tableName + <span class="string">"("</span>);</span><br><span class="line"><span class="keyword">for</span> (String columnDef : columnDefs) &#123;</span><br><span class="line">createCommand.append(<span class="string">"\n    "</span> + columnDef + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Remove trailing comma</span></span><br><span class="line">String tableCreate = createCommand.substring(<span class="number">0</span>, (createCommand.length() - <span class="number">1</span>)) + <span class="string">");"</span>;</span><br><span class="line">System.out.println(<span class="string">"Table.Creation SQL for "</span> + className + <span class="string">" is :\n "</span> + tableCreate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getConstraints</span><span class="params">(Constraints con)</span> </span>&#123;</span><br><span class="line">String constraints = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (!con.allowNull()) &#123;</span><br><span class="line">constraints += <span class="string">" NOT NULL"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (con.primaryKey()) &#123;</span><br><span class="line">constraints += <span class="string">" PRIMARY KEY"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (con.unique()) &#123;</span><br><span class="line">constraints += <span class="string">" UNIQUE"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Table.Creation SQL for org.apache.flink.annotation.dbtable.Member is :</span><br><span class="line"> CREATE TABLE MEMBER(</span><br><span class="line">    FIRSTNAME VARCHAR(30),</span><br><span class="line">    LASTNAME VARCHAR(50),</span><br><span class="line">    AGE INT,</span><br><span class="line">    HANDLE VARCHAR(30) PRIMARY KEY);</span><br></pre></td></tr></table></figure><h2 id="flink中的注解"><a href="#flink中的注解" class="headerlink" title="flink中的注解"></a>flink中的注解</h2><p><img src="flink%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.png" alt></p><h3 id="docs相关注解"><a href="#docs相关注解" class="headerlink" title="docs相关注解"></a>docs相关注解</h3><ol><li>@ConfigGroup</li></ol><p>指定一组配置选项，组的名称将用作生成 HTML 文件名，keyPrefix 用于匹配配置项名称前缀。<br>如 @ConfigGroup(name = “firstGroup”, keyPrefix = “first”)，生成的 HTML 文件名为 firstGroup ，其中的配置项名称都是以 first 开头的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;&#125;)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigGroup &#123;</span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">keyPrefix</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@ConfigGroups</li></ol><p>允许一个配置类中的配置项可以按照配置项名称前缀分成不同的组，生成多个 HTML 文件。<br>如：<br>@ConfigGroups(groups = {<br>        @ConfigGroup(name = “firstGroup”, keyPrefix = “first”),<br>        @ConfigGroup(name = “secondGroup”, keyPrefix = “second”)})<br>可以从配置类生成 3 个 HTML 文件，分别为 firstGroup、secondGroup、default，具体可以接着往下看，下面会有示例说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigGroups &#123;</span><br><span class="line">ConfigGroup[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个示例来说明这两个注解的用途。<br>查看测试类 ConfigOptionsDocGeneratorTest 中应用到 @ConfigGroups 和 @ConfigGroup 的单测 <code>testCreatingMultipleGroups</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreatingMultipleGroups</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> List&lt;Tuple2&lt;ConfigGroup, String&gt;&gt; tables = ConfigOptionsDocGenerator.generateTablesForClass(</span><br><span class="line">TestConfigMultipleSubGroup.class);</span><br><span class="line"></span><br><span class="line">assertEquals(tables.size(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; tablesConverted = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Tuple2&lt;ConfigGroup, String&gt; table : tables) &#123;</span><br><span class="line">tablesConverted.put(table.f0 != <span class="keyword">null</span> ? table.f0.name() : <span class="string">"default"</span>, table.f1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestConfigMultipleSubGroup</code> 类 mock 了一个配置项类：<br>@ConfigGroup(name = “firstGroup”, keyPrefix = “first”) 将 key 以 first 开头的 ConfigOption 归为 firstGroup，<br>@ConfigGroup(name = “secondGroup”, keyPrefix = “second”) 将 key 以 second 开头的 ConfigOption 归为 secondGroup。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigGroups</span>(groups = &#123;</span><br><span class="line"><span class="meta">@ConfigGroup</span>(name = <span class="string">"firstGroup"</span>, keyPrefix = <span class="string">"first"</span>),</span><br><span class="line"><span class="meta">@ConfigGroup</span>(name = <span class="string">"secondGroup"</span>, keyPrefix = <span class="string">"second"</span>)&#125;)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigMultipleSubGroup</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;Integer&gt; firstOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"first.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is example description for the first option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;String&gt; secondOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"second.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This is long example description for the second option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;Integer&gt; thirdOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"third.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is example description for the third option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;String&gt; fourthOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"fourth.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This is long example description for the fourth option."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看下 <code>ConfigOptionsDocGenerator.generateTablesForClass(Class&lt;?&gt; optionsClass)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> List&lt;Tuple2&lt;ConfigGroup, String&gt;&gt; generateTablesForClass(Class&lt;?&gt; optionsClass) &#123;</span><br><span class="line"><span class="comment">// 获取 optionsClass 类上定义的 @ConfigGroups</span></span><br><span class="line">ConfigGroups configGroups = optionsClass.getAnnotation(ConfigGroups.class);</span><br><span class="line"><span class="comment">// 抽取 optionsClass 中的所有 ConfigOption 配置项</span></span><br><span class="line">List&lt;OptionWithMetaInfo&gt; allOptions = extractConfigOptions(optionsClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 @ConfigGroups 注解中的 ConfigGroup[] groups()</span></span><br><span class="line">List&lt;Tuple2&lt;ConfigGroup, String&gt;&gt; tables;</span><br><span class="line"><span class="keyword">if</span> (configGroups != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 解析 optionsClass 上的 ConfigGroup 注解，即是有分组的。另外一个是默认的 ConfigGroup</span></span><br><span class="line">tables = <span class="keyword">new</span> ArrayList&lt;&gt;(configGroups.groups().length + <span class="number">1</span>);</span><br><span class="line">Tree tree = <span class="keyword">new</span> Tree(configGroups.groups(), allOptions);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ConfigGroup group : configGroups.groups()) &#123;</span><br><span class="line">List&lt;OptionWithMetaInfo&gt; configOptions = tree.findConfigOptions(group);</span><br><span class="line"><span class="comment">// 按照 ConfigOption 的 key 进行排序</span></span><br><span class="line"> sortOptions(configOptions);</span><br><span class="line">tables.add(Tuple2.of(group, toHtmlTable(configOptions)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有 @ConfigGroup 前缀都匹配不上的其他 ConfigOption 归为 default 组</span></span><br><span class="line">List&lt;OptionWithMetaInfo&gt; configOptions = tree.getDefaultOptions();</span><br><span class="line">sortOptions(configOptions);</span><br><span class="line">tables.add(Tuple2.of(<span class="keyword">null</span>, toHtmlTable(configOptions)));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sortOptions(allOptions);</span><br><span class="line">tables = Collections.singletonList(Tuple2.of(<span class="keyword">null</span>, toHtmlTable(allOptions)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tables;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行单测 <code>testCreatingMultipleGroups</code> 的输出结果如下：<br>firstGroup 配置项组里的配置项名称都是以 first 为前缀的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>first.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is example description for the first option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>secondGroup 配置项组里的配置项名称都是以 second 为前缀的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>second.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>(none)<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>String<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is long example description for the second option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>TestConfigMultipleSubGroup 中的其他配置项都是没有分组的，默认都放到 default 组中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>fourth.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>(none)<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>String<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is long example description for the fourth option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>third.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is example description for the third option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Documentation 类中定义了修改文档生成器行为的注解结合，包括 @OverrideDefault、@CommonOption、@TableOption、@ExcludeFromDocumentation。下面依次介绍。</p><ol start="3"><li>@Documentation.OverrideDefault</li></ol><p>作用在 ConfigOption 上的注解，覆盖其默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OverrideDefault &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个示例来说明这个注解的用途。<br>查看测试类 ConfigOptionsDocGeneratorTest 中应用到 @Documentation.OverrideDefault 的单测 <code>testOverrideDefault</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOverrideDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String htmlTable = ConfigOptionsDocGenerator.generateTablesForClass(TestConfigGroupWithOverriddenDefault.class).get(<span class="number">0</span>).f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestConfigGroupWithOverriddenDefault</code> 类 mock 了一个配置项类，每个配置项都使用了 @Documentation.OverrideDefault 注解覆盖配置项的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigGroupWithOverriddenDefault</span> </span>&#123;</span><br><span class="line"><span class="meta">@Documentation</span>.OverrideDefault(<span class="string">"default_1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;Integer&gt; firstOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"first.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is example description for the first option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documentation</span>.OverrideDefault(<span class="string">"default_2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;String&gt; secondOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"second.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This is long example description for the second option."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行单测 <code>testOverrideDefault</code> 的输出结果如下：<br>将 firstOption 的默认值覆盖成了 default_1，secondOption 原先没有默认值，被设置成了 default_2。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>first.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>default_1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is example description for the first option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>second.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>default_2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>String<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is long example description for the second option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>@Documentation.CommonOption</li></ol><p>作用在 ConfigOption 上的注解，使其包含在 “Common Options” 片段中，<br>按 position 值排序，position 值小的配置项排在前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CommonOption &#123;</span><br><span class="line"><span class="keyword">int</span> POSITION_MEMORY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_PARALLELISM_SLOTS = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_FAULT_TOLERANCE = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_HIGH_AVAILABILITY = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> POSITION_SECURITY = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> <span class="keyword">default</span> Integer.MAX_VALUE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个示例来说明这个注解的用途。<br>查看测试类 ConfigOptionsDocGeneratorTest 中应用到 @Documentation.CommonOption 的单测 <code>testCommonOptions</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCommonOptions</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String projectRootDir = System.getProperty(<span class="string">"rootDir"</span>);</span><br><span class="line"><span class="keyword">final</span> String outputDirectory = TMP.newFolder().getAbsolutePath();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> OptionsClassLocation[] locations = <span class="keyword">new</span> OptionsClassLocation[] &#123;</span><br><span class="line"><span class="keyword">new</span> OptionsClassLocation(<span class="string">"flink-docs"</span>, TestCommonOptions.class.getPackage().getName())</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConfigOptionsDocGenerator.generateCommonSection(projectRootDir, outputDirectory, locations, <span class="string">"src/test/java"</span>);</span><br><span class="line">Formatter formatter = <span class="keyword">new</span> HtmlFormatter();</span><br><span class="line">String output = FileUtils.readFile(Paths.get(outputDirectory, ConfigOptionsDocGenerator.COMMON_SECTION_FILE_NAME).toFile(), StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestCommonOptions</code> 类 mock 了一个配置项类：<br>COMMON_OPTION 使用了 @Documentation.CommonOption 注解，position 使用默认值为 Integer.MAX_VALUE，<br>COMMON_POSITIONED_OPTION 也是用了 @Documentation.CommonOption 注解，position 值指定为2，这个配置项肯定排在 COMMON_OPTION 前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCommonOptions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documentation</span>.CommonOption</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfigOption&lt;Integer&gt; COMMON_OPTION = ConfigOptions</span><br><span class="line">.key(<span class="string">"first.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is the description for the common option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfigOption&lt;String&gt; GENERIC_OPTION = ConfigOptions</span><br><span class="line">.key(<span class="string">"second.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This is the description for the generic option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documentation</span>.CommonOption(position = <span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfigOption&lt;Integer&gt; COMMON_POSITIONED_OPTION = ConfigOptions</span><br><span class="line">.key(<span class="string">"third.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">3</span>)</span><br><span class="line">.withDescription(<span class="string">"This is the description for the positioned common option."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行单测 <code>testCommonOptions</code> 的输出结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>third.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is the description for the positioned common option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>first.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is the description for the common option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>@Documentation.TableOption</li></ol><p>作用于 table 配置项上，用于添加元数据标签，配置执行模式（批处理、流式处理、两者兼有）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TableOption &#123;</span><br><span class="line"><span class="function">ExecMode <span class="title">execMode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看下 <code>ConfigOptionsDocGenerator</code> 类中的 toHtmlString 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHtmlString</span><span class="params">(<span class="keyword">final</span> OptionWithMetaInfo optionWithMetaInfo)</span> </span>&#123;</span><br><span class="line">ConfigOption&lt;?&gt; option = optionWithMetaInfo.option;</span><br><span class="line">String defaultValue = stringifyDefault(optionWithMetaInfo);</span><br><span class="line">String type = typeToHtml(optionWithMetaInfo);</span><br><span class="line">Documentation.TableOption tableOption = optionWithMetaInfo.field.getAnnotation(Documentation.TableOption.class);</span><br><span class="line">StringBuilder execModeStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">if</span> (tableOption != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果 ConfigOption 上有 @Documentation.TableOption 注解，则读取它的 execMode 字段，拼接到 html 内容中。</span></span><br><span class="line">Documentation.ExecMode execMode = tableOption.execMode();</span><br><span class="line"><span class="keyword">if</span> (Documentation.ExecMode.BATCH_STREAMING.equals(execMode)) &#123;</span><br><span class="line">execModeStringBuilder.append(<span class="string">"&lt;br&gt; &lt;span class=\"label label-primary\"&gt;"</span>)</span><br><span class="line">.append(Documentation.ExecMode.BATCH.toString())</span><br><span class="line">.append(<span class="string">"&lt;/span&gt; &lt;span class=\"label label-primary\"&gt;"</span>)</span><br><span class="line">.append(Documentation.ExecMode.STREAMING.toString())</span><br><span class="line">.append(<span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">execModeStringBuilder.append(<span class="string">"&lt;br&gt; &lt;span class=\"label label-primary\"&gt;"</span>)</span><br><span class="line">.append(execMode.toString())</span><br><span class="line">.append(<span class="string">"&lt;/span&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span> +</span><br><span class="line"><span class="string">"        &lt;tr&gt;\n"</span> +</span><br><span class="line"><span class="string">"            &lt;td&gt;&lt;h5&gt;"</span> + escapeCharacters(option.key()) + <span class="string">"&lt;/h5&gt;"</span> + execModeStringBuilder.toString() + <span class="string">"&lt;/td&gt;\n"</span> +</span><br><span class="line"><span class="string">"            &lt;td style=\"word-wrap: break-word;\"&gt;"</span> + escapeCharacters(addWordBreakOpportunities(defaultValue)) + <span class="string">"&lt;/td&gt;\n"</span> +</span><br><span class="line"><span class="string">"            &lt;td&gt;"</span> + type + <span class="string">"&lt;/td&gt;\n"</span> +</span><br><span class="line"><span class="string">"            &lt;td&gt;"</span> + formatter.format(option.description()) + <span class="string">"&lt;/td&gt;\n"</span> +</span><br><span class="line"><span class="string">"        &lt;/tr&gt;\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>@Documentation.ExcludeFromDocumentation</li></ol><p>作用于 ConfigOption 配置项，用于从最终生成的 HTML 文档中移除配置项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ExcludeFromDocumentation &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The optional reason why the config option is excluded from documentation.</span></span><br><span class="line"><span class="comment"> * 解释下从文档中移除配置项的原因</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过一个示例来说明这个注解的用途。<br>查看测试类 ConfigOptionsDocGeneratorTest 中应用到 @Documentation.ExcludeFromDocumentation 的单测 <code>testConfigOptionExclusion</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfigOptionExclusion</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String htmlTable = ConfigOptionsDocGenerator.generateTablesForClass(TestConfigGroupWithExclusion.class).get(<span class="number">0</span>).f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestConfigGroupWithExclusion</code> 类 mock 了一个配置项类：<br>excludedOption 使用了 @Documentation.ExcludeFromDocumentation 注解，在生成的 HTML 文档中它将被移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfigGroupWithExclusion</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;Integer&gt; firstOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"first.option.a"</span>)</span><br><span class="line">.defaultValue(<span class="number">2</span>)</span><br><span class="line">.withDescription(<span class="string">"This is example description for the first option."</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documentation</span>.ExcludeFromDocumentation</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigOption&lt;String&gt; excludedOption = ConfigOptions</span><br><span class="line">.key(<span class="string">"excluded.option.a"</span>)</span><br><span class="line">.noDefaultValue()</span><br><span class="line">.withDescription(<span class="string">"This should not be documented."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行单测 <code>testConfigOptionExclusion</code> 的输出结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 20%"</span>&gt;</span>Key<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 15%"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 10%"</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"text-left"</span> <span class="attr">style</span>=<span class="string">"width: 55%"</span>&gt;</span>Description<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">h5</span>&gt;</span>first.option.a<span class="tag">&lt;/<span class="name">h5</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">"word-wrap: break-word;"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Integer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>This is example description for the first option.<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他标记注解"><a href="#其他标记注解" class="headerlink" title="其他标记注解"></a>其他标记注解</h3><p>关于这几种标记注解，源码中暂时还没有找到相关测试用例，后续补充。</p><ol><li>@Experimental</li></ol><p>表示标记对象是试验使用的注解，带有此注解的类是没有经过严格测试和不稳定的，可能在以后的版本中被修改或移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Experimental &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@Internal</li></ol><p>将稳定的公共的api注解为内部开发者api，内部开发者api是稳定的，面向Flink内部，可能随着版本变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Internal &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>@Public</li></ol><p>标注类为开放的，稳定的。<br>类、方法、属性被这个这个注解修饰时，表示在小版本迭代(1.0,1.1,1.2)中，都维持稳定，应用程序将根据同一大版本进行编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Public &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>@PublicEvolving</li></ol><p>带有此注解的类和方法用于公共使用，并且具有稳定的行为。但是，它们的接口和签名不被认为是稳定的，并且当跨版本时可能会变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PublicEvolving &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>@VisibleForTesting</li></ol><p>标注有些方法、属性、构造函数、类等在 test 阶段可见，用于测试。<br>例如，当方法是 private 的，不打算在外部去调用的，但是有些内部测试需要访问它，所以加上 VisibleForTesting 注解进行内部测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR &#125;)</span><br><span class="line"><span class="meta">@Internal</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> VisibleForTesting &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将先介绍下java注解的实现，再说明下Flink自定义的几个注解及其使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink源码剖析-flink-metrics</title>
    <link href="http://yoursite.com/2020/04/05/Flink%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-Flink-Metrics/"/>
    <id>http://yoursite.com/2020/04/05/Flink源码剖析-Flink-Metrics/</id>
    <published>2020-04-04T18:31:00.000Z</published>
    <updated>2020-04-14T08:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将详细介绍下Flink中的指标实现，包括自带的指标名和如何自定义指标。还会介绍下现在已经支持的reporter，如jmx、slf4j、influxdb、graphite、prometheus、pushgateway等。<br>最后介绍下flink指标平台化实践。</p><a id="more"></a><h2 id="flink-metrics-core"><a href="#flink-metrics-core" class="headerlink" title="flink-metrics-core"></a>flink-metrics-core</h2><ul><li>Metric：<br><img src="Metric%E7%B1%BB%E5%9B%BE.png" alt></li></ul><p>指标类型有Gauge、Count、Meter、Histogram。</p><ul><li><p>MetricConfig：<br><img src="MetricConfig%E7%B1%BB%E5%9B%BE.png" alt></p></li><li><p>MetricGroup：<br><img src="MetricGroup%E7%B1%BB%E5%9B%BE.png" alt></p></li></ul><p>Metric 在 flink 内部以 Group 的方式组织，有多层结构，Metric Group + Metric Name 是 Metric 的唯一标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskManagerMetricGroup</span><br><span class="line">    •TaskManagerJobMetricGroup</span><br><span class="line">        •TaskMetricGroup</span><br><span class="line">            •TaskIOMetricGroup</span><br><span class="line">            •OperatorMetricGroup</span><br><span class="line">                •$&#123;User-defined Group&#125; / $&#123;User-defined Metrics&#125;</span><br><span class="line">                •OperatorIOMetricGroup</span><br><span class="line">•JobManagerMetricGroup</span><br><span class="line">    •JobManagerJobMetricGroup</span><br></pre></td></tr></table></figure><p>可以根据需要埋点自定义指标。</p><ul><li><p>添加一个统计脏数据的指标，指标名为flink_taskmanager_job_task_operator_dtDirtyData ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 RichFunction 中 getRuntimeContext() </span></span><br><span class="line">dirtyDataCounter = runtimeContext.getMetricGroup().counter(MetricConstant.DT_DIRTY_DATA_COUNTER);</span><br></pre></td></tr></table></figure></li><li><p>添加一个消费延迟指标，自定了两层Group，分别是topic、partition，指标名为flink_taskmanager_job_task_operator_topic_partition_dtTopicPartitionLag ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(TopicPartition topicPartition : assignedPartitions)&#123;</span><br><span class="line">    MetricGroup metricGroup = getRuntimeContext().getMetricGroup().addGroup(DT_TOPIC_GROUP, topicPartition.topic())</span><br><span class="line">                    .addGroup(DT_PARTITION_GROUP, String.valueOf(topicPartition.partition()));</span><br><span class="line">    metricGroup.gauge(DT_TOPIC_PARTITION_LAG_GAUGE, <span class="keyword">new</span> KafkaTopicPartitionLagMetric(subscriptionState, topicPartition));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MetricReporter：<br><img src="MetricReporter%E7%B1%BB%E5%9B%BE.png" alt><br>flink 内置了多种指标 reporter ，如jmx、slf4j、graphite、prometheus、influxdb、statsd、datadog等。</p></li></ul><h2 id="指标-Reporters"><a href="#指标-Reporters" class="headerlink" title="指标 Reporters"></a>指标 Reporters</h2><h3 id="flink-metrics-dropwizard"><a href="#flink-metrics-dropwizard" class="headerlink" title="flink-metrics-dropwizard"></a>flink-metrics-dropwizard</h3><p>只是将flink内部定义的指标<code>org.apache.flink.metrics.Metric</code>和dropwizard中定义的指标<code>com.codahale.metrics.Metric</code>接口和子类互相包装转换。<br>并且实现了 ScheduledDropwizardReporter ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_HOST = <span class="string">"host"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_PORT = <span class="string">"port"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_PREFIX = <span class="string">"prefix"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_CONVERSION_RATE = <span class="string">"rateConversion"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_CONVERSION_DURATION = <span class="string">"durationConversion"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dropwizard 包中的 MetricRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MetricRegistry registry;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dropwizard 包中的 ScheduledReporter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> ScheduledReporter reporter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Gauge&lt;?&gt;, String&gt; gauges = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Counter, String&gt; counters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Histogram, String&gt; histograms = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Meter, String&gt; meters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加指标，添加指标，需要将flink内部的Metric转换成dropwizard中的Metric，</span></span><br><span class="line"><span class="comment"> * 再注册到 dropwizard 的 MetricRegistry 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyOfAddedMetric</span><span class="params">(Metric metric, String metricName, MetricGroup group)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String fullName = group.getMetricIdentifier(metricName, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Counter) &#123;</span><br><span class="line">counters.put((Counter) metric, fullName);</span><br><span class="line">registry.register(fullName, <span class="keyword">new</span> FlinkCounterWrapper((Counter) metric));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Gauge) &#123;</span><br><span class="line">gauges.put((Gauge&lt;?&gt;) metric, fullName);</span><br><span class="line">registry.register(fullName, FlinkGaugeWrapper.fromGauge((Gauge&lt;?&gt;) metric));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Histogram) &#123;</span><br><span class="line">Histogram histogram = (Histogram) metric;</span><br><span class="line">histograms.put(histogram, fullName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (histogram <span class="keyword">instanceof</span> DropwizardHistogramWrapper) &#123;</span><br><span class="line">registry.register(fullName, ((DropwizardHistogramWrapper) histogram).getDropwizardHistogram());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">registry.register(fullName, <span class="keyword">new</span> FlinkHistogramWrapper(histogram));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Meter) &#123;</span><br><span class="line">Meter meter = (Meter) metric;</span><br><span class="line">meters.put(meter, fullName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (meter <span class="keyword">instanceof</span> DropwizardMeterWrapper) &#123;</span><br><span class="line">registry.register(fullName, ((DropwizardMeterWrapper) meter).getDropwizardMeter());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">registry.register(fullName, <span class="keyword">new</span> FlinkMeterWrapper(meter));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.warn(<span class="string">"Cannot add metric of type &#123;&#125;. This indicates that the reporter "</span> +</span><br><span class="line"><span class="string">"does not support this metric type."</span>, metric.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * report 时直接从 dropwizard 的 MetricRegistry 中捞取所有指标，执行 ScheduledReporter 的 report 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// we do not need to lock here, because the dropwizard registry is</span></span><br><span class="line"><span class="comment">// internally a concurrent map</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">final</span> SortedMap&lt;String, com.codahale.metrics.Gauge&gt; gauges = registry.getGauges();</span><br><span class="line"><span class="keyword">final</span> SortedMap&lt;String, com.codahale.metrics.Counter&gt; counters = registry.getCounters();</span><br><span class="line"><span class="keyword">final</span> SortedMap&lt;String, com.codahale.metrics.Histogram&gt; histograms = registry.getHistograms();</span><br><span class="line"><span class="keyword">final</span> SortedMap&lt;String, com.codahale.metrics.Meter&gt; meters = registry.getMeters();</span><br><span class="line"><span class="keyword">final</span> SortedMap&lt;String, com.codahale.metrics.Timer&gt; timers = registry.getTimers();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reporter.report(gauges, counters, histograms, meters, timers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ScheduledReporter <span class="title">getReporter</span><span class="params">(MetricConfig config)</span></span>;</span><br></pre></td></tr></table></figure><p>只有<code>flink-metrics-graphite</code>模块会引用这个模块，直接复用 dropwizard 包提供的 GraphiteReporter 功能。</p><h3 id="flink-metrics-graphite"><a href="#flink-metrics-graphite" class="headerlink" title="flink-metrics-graphite"></a>flink-metrics-graphite</h3><p>GraphiteReporter 继承了 flink-metrics-dropwizard 模块中的 ScheduledDropwizardReporter。<br>只需要实现其中的 getReporter() 抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScheduledReporter <span class="title">getReporter</span><span class="params">(MetricConfig config)</span> </span>&#123;</span><br><span class="line">String host = config.getString(ARG_HOST, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">int</span> port = config.getInteger(ARG_PORT, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (host == <span class="keyword">null</span> || host.length() == <span class="number">0</span> || port &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid host/port configuration. Host: "</span> + host + <span class="string">" Port: "</span> + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String prefix = config.getString(ARG_PREFIX, <span class="keyword">null</span>);</span><br><span class="line">String conversionRate = config.getString(ARG_CONVERSION_RATE, <span class="keyword">null</span>);</span><br><span class="line">String conversionDuration = config.getString(ARG_CONVERSION_DURATION, <span class="keyword">null</span>);</span><br><span class="line">String protocol = config.getString(ARG_PROTOCOL, <span class="string">"TCP"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复用 dropwizard 包提供的 GraphiteReporter</span></span><br><span class="line">com.codahale.metrics.graphite.GraphiteReporter.Builder builder =</span><br><span class="line">com.codahale.metrics.graphite.GraphiteReporter.forRegistry(registry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (prefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.prefixedWith(prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conversionRate != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.convertRatesTo(TimeUnit.valueOf(conversionRate));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conversionDuration != <span class="keyword">null</span>) &#123;</span><br><span class="line">builder.convertDurationsTo(TimeUnit.valueOf(conversionDuration));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Protocol prot;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">prot = Protocol.valueOf(protocol);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">log.warn(<span class="string">"Invalid protocol configuration: "</span> + protocol + <span class="string">" Expected: TCP or UDP, defaulting to TCP."</span>);</span><br><span class="line">prot = Protocol.TCP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"Configured GraphiteReporter with &#123;host:&#123;&#125;, port:&#123;&#125;, protocol:&#123;&#125;&#125;"</span>, host, port, prot);</span><br><span class="line"><span class="keyword">switch</span>(prot) &#123;</span><br><span class="line"><span class="keyword">case</span> UDP:</span><br><span class="line"><span class="keyword">return</span> builder.build(<span class="keyword">new</span> GraphiteUDP(host, port));</span><br><span class="line"><span class="keyword">case</span> TCP:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> builder.build(<span class="keyword">new</span> Graphite(host, port));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li>复制 flink-metrics-graphite-xxx.jar 到 $FLINK_HOME/lib 下</li><li>在 flink-conf.yml 增加如下配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metrics.reporter.grph.class:</span> <span class="string">org.apache.flink.metrics.graphite.GraphiteReporter</span></span><br><span class="line"><span class="string">metrics.reporter.grph.host:</span> <span class="string">localhost</span>  <span class="comment"># Graphite server host</span></span><br><span class="line"><span class="string">metrics.reporter.grph.port:</span> <span class="number">2003</span>       <span class="comment"># Graphite server port</span></span><br><span class="line"><span class="string">metrics.reporter.grph.protocol:</span> <span class="string">TCP</span>    <span class="comment"># protocol to use (TCP/UDP)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="flink-metrics-influxdb"><a href="#flink-metrics-influxdb" class="headerlink" title="flink-metrics-influxdb"></a>flink-metrics-influxdb</h3><h4 id="influxdb基本概念"><a href="#influxdb基本概念" class="headerlink" title="influxdb基本概念"></a>influxdb基本概念</h4><p>使用方法参考：<a href="https://www.jianshu.com/p/a1344ca86e9b" target="_blank" rel="noopener">时序数据库 Influxdb 使用详解</a><br>为了方便理解 InfluxdbReporter 的实现，这里简单说下 Influxdb 中的几个概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name: census</span><br><span class="line">-————————————</span><br><span class="line">time                     butterflies     honeybees     location   scientist</span><br><span class="line">2015-08-18T00:00:00Z      12                23           1         langstroth</span><br><span class="line">2015-08-18T00:00:00Z      1                 30           1         perpetua</span><br><span class="line">2015-08-18T00:06:00Z      11                28           1         langstroth</span><br><span class="line">2015-08-18T00:06:00Z      3                 28           1         perpetua</span><br><span class="line">2015-08-18T05:54:00Z      2                 11           2         langstroth</span><br><span class="line">2015-08-18T06:00:00Z      1                 10           2         langstroth</span><br><span class="line">2015-08-18T06:06:00Z      8                 23           2         perpetua</span><br><span class="line">2015-08-18T06:12:00Z      7                 22           2         perpetua</span><br></pre></td></tr></table></figure><ul><li><p>timestamp<br>既然是时间序列数据库，influxdb 的数据都有一列名为 time 的列。</p></li><li><p>field key,field value,field set<br>bufferflies 和 honeybees 为 field key，它们为String类型，用于存储元数据。<br>数据 12-7 为 bufferflies 的field value，数据 23-22 为 honeybees 的field value。field value可以为String,float,integer或boolean类型。<br>field key 和 field value 对组成的集合称之为 field set，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">butterflies = 12 honeybees = 23</span><br><span class="line">butterflies = 1 honeybees = 30</span><br><span class="line">butterflies = 11 honeybees = 28</span><br><span class="line">butterflies = 3 honeybees = 28</span><br><span class="line">butterflies = 2 honeybees = 11</span><br><span class="line">butterflies = 1 honeybees = 10</span><br><span class="line">butterflies = 8 honeybees = 23</span><br><span class="line">butterflies = 7 honeybees = 22</span><br></pre></td></tr></table></figure></li></ul><p>在 influxdb 中，field 是必须的，但是字段是没有索引的，如果字段作为查询条件，会扫描所有符合查询条件的所有字段值。相当于SQL的没有索引的列。    </p><ul><li>tag key,tag value,tag set<br>location 和 scientist 是两个tag，location 有两个 tag value：1和2，scientist 有两个 tag value：langstroth 和 perpetua。<br>tag key 和 tag value 对组成的集合称之为 tag set，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location = 1, scientist = langstroth</span><br><span class="line">location = 2, scientist = langstroth</span><br><span class="line">location = 1, scientist = perpetua</span><br><span class="line">location = 2, scientist = perpetua</span><br></pre></td></tr></table></figure></li></ul><p>在 influxdb 中，tag 是可选的，但 tag 相当于SQL中有索引的列，因此强烈建议使用。</p><ul><li><p>measurement<br>指标项，是 fields，tags 以及 time 列的容器。</p></li><li><p>retention policy<br>数据保留策略，默认是 autogen，表示数据一直保留永不过期，副本数量为1。</p></li><li><p>series<br>指共享同一个 retention policy，measurement 以及 tag set 的数据集合，如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">｜ Arbitrary series number ｜ Retention policy ｜ Measurement ｜ Tag set ｜</span><br><span class="line">｜ ----------------------- ｜ ---------------- ｜ ----------- ｜ ------------------------------- ｜</span><br><span class="line">｜        series 1         ｜       autogen    ｜     census  ｜ location=1,scientist=langstroth ｜</span><br><span class="line">｜        series 2         ｜       autogen    ｜     census  ｜ location=2,scientist=perpetua   ｜</span><br><span class="line">｜        series 3         ｜       autogen    ｜     census  ｜ location=1,scientist=langstroth ｜</span><br><span class="line">｜        series 4         ｜       autogen    ｜     census  ｜ location=2,scientist=perpetua   ｜</span><br></pre></td></tr></table></figure><ul><li>point<br>指的是同一个series中具有相同时间的 field set，points 相当于SQL中的数据行。如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name: census</span><br><span class="line">-----------------</span><br><span class="line">time                  butterflies    honeybees   location    scientist</span><br><span class="line">2015-08-18T00:00:00Z       1            30           1        perpetua</span><br></pre></td></tr></table></figure><ul><li>database</li></ul><p>一个数据库可以有多个 measurement,retention policy,continuous queries以及user。提供InfluxQL语言查询和修改数据。</p><h4 id="Reporter实现"><a href="#Reporter实现" class="headerlink" title="Reporter实现"></a>Reporter实现</h4><p>InfluxdbReporter的详细类图如下，包括继承以及依赖关系：<br><img src="InfluxdbReporter%E7%B1%BB%E5%9B%BE.png" alt></p><ul><li><p>MeasurementInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指标项名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tag key 和 tag value对集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; tags;</span><br></pre></td></tr></table></figure></li><li><p>MeasurementInfoProvider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 metricName 和 MetricGroup，将该指标项封装成 MeasurementInfo 返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MeasurementInfo <span class="title">getMetricInfo</span><span class="params">(String metricName, MetricGroup group)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MeasurementInfo(getScopedName(metricName, group), getTags(group));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>InfluxdbReporterOptions<br>连接 influxdb 写指标的配置项，类似正常写RDBMS需要的配置</p></li><li><p>MetricMapper<br>将 MeasurementInfo 转成 influxdb 中的 Point</p></li><li><p>InfluxdbReporter extends AbstractReporter</p></li></ul><p>构造函数中设置 MeasurementInfoProvider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InfluxdbReporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置 MeasurementInfoProvider</span></span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">new</span> MeasurementInfoProvider());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open() 方法中要根据指标配置文件初始化 InfluxDB 操作类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据配置项初始化得到 InfluxDB 操作类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(MetricConfig config)</span> </span>&#123;</span><br><span class="line">String host = getString(config, HOST);</span><br><span class="line"><span class="keyword">int</span> port = getInteger(config, PORT);</span><br><span class="line"><span class="keyword">if</span> (!isValidHost(host) || !NetUtils.isValidClientPort(port)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid host/port configuration. Host: "</span> + host + <span class="string">" Port: "</span> + port);</span><br><span class="line">&#125;</span><br><span class="line">String database = getString(config, DB);</span><br><span class="line"><span class="keyword">if</span> (database == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"'"</span> + DB.key() + <span class="string">"' configuration option is not set"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String url = String.format(<span class="string">"http://%s:%d"</span>, host, port);</span><br><span class="line">String username = getString(config, USERNAME);</span><br><span class="line">String password = getString(config, PASSWORD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.database = database;</span><br><span class="line"><span class="keyword">this</span>.retentionPolicy = getString(config, RETENTION_POLICY);</span><br><span class="line"><span class="keyword">this</span>.consistency = getConsistencyLevel(config, CONSISTENCY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> connectTimeout = getInteger(config, CONNECT_TIMEOUT);</span><br><span class="line"><span class="keyword">int</span> writeTimeout = getInteger(config, WRITE_TIMEOUT);</span><br><span class="line"><span class="comment">// 使用 okhttp 包中提供的 HttpClient</span></span><br><span class="line">OkHttpClient.Builder client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">.connectTimeout(connectTimeout, TimeUnit.MILLISECONDS)</span><br><span class="line">.writeTimeout(writeTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span>) &#123;</span><br><span class="line">influxDB = InfluxDBFactory.connect(url, username, password, client);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">influxDB = InfluxDBFactory.connect(url, client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"Configured InfluxDBReporter with &#123;host:&#123;&#125;, port:&#123;&#125;, db:&#123;&#125;, retentionPolicy:&#123;&#125; and consistency:&#123;&#125;&#125;"</span>,</span><br><span class="line">host, port, database, retentionPolicy, consistency.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractReporter 中的 notifyOfAddedMetric() 方法中添加指标时将 flink 内部定义的 Metric 转成 MeasurementInfo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyOfAddedMetric</span><span class="params">(Metric metric, String metricName, MetricGroup group)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> MetricInfo metricInfo = metricInfoProvider.getMetricInfo(metricName, group);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Counter) &#123;</span><br><span class="line">counters.put((Counter) metric, metricInfo);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Gauge) &#123;</span><br><span class="line">gauges.put((Gauge&lt;?&gt;) metric, metricInfo);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Histogram) &#123;</span><br><span class="line">histograms.put((Histogram) metric, metricInfo);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Meter) &#123;</span><br><span class="line">meters.put((Meter) metric, metricInfo);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.warn(<span class="string">"Cannot add unknown metric type &#123;&#125;. This indicates that the reporter "</span> +</span><br><span class="line"><span class="string">"does not support this metric type."</span>, metric.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>report()方法要将 MeasurementInfo 转成 influxdb 中的 Point 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BatchPoints report = buildReport();</span><br><span class="line"><span class="keyword">if</span> (report != <span class="keyword">null</span>) &#123;</span><br><span class="line">influxDB.write(report);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将指标信息封装成 influxdb 中的 BatchPoints</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> BatchPoints</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BatchPoints <span class="title">buildReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 取当前时间点</span></span><br><span class="line">Instant timestamp = Instant.now();</span><br><span class="line">BatchPoints.Builder report = BatchPoints.database(database);</span><br><span class="line"><span class="comment">// 设置保留策略</span></span><br><span class="line">report.retentionPolicy(retentionPolicy);</span><br><span class="line">report.consistency(consistency);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Gauge&lt;?&gt;, MeasurementInfo&gt; entry : gauges.entrySet()) &#123;</span><br><span class="line"><span class="comment">// MeasurementInfo -&gt; Point</span></span><br><span class="line">report.point(MetricMapper.map(entry.getValue(), timestamp, entry.getKey()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Counter, MeasurementInfo&gt; entry : counters.entrySet()) &#123;</span><br><span class="line">report.point(MetricMapper.map(entry.getValue(), timestamp, entry.getKey()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Histogram, MeasurementInfo&gt; entry : histograms.entrySet()) &#123;</span><br><span class="line">report.point(MetricMapper.map(entry.getValue(), timestamp, entry.getKey()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Meter, MeasurementInfo&gt; entry : meters.entrySet()) &#123;</span><br><span class="line">report.point(MetricMapper.map(entry.getValue(), timestamp, entry.getKey()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ConcurrentModificationException | NoSuchElementException e) &#123;</span><br><span class="line"><span class="comment">// ignore - may happen when metrics are concurrently added or removed</span></span><br><span class="line"><span class="comment">// report next time</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> report.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><ul><li>复制 flink-metrics-influxdb-xxx.jar 到 $FLINK_HOME/lib 下</li><li>在 flink-conf.yml 增加如下配置：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metrics.reporter.influxdb.class:</span> <span class="string">org.apache.flink.metrics.influxdb.InfluxdbReporter</span></span><br><span class="line"><span class="string">metrics.reporter.influxdb.host:</span> <span class="string">localhost</span>           <span class="comment"># the InfluxDB server host</span></span><br><span class="line"><span class="string">metrics.reporter.influxdb.port:</span> <span class="number">8086</span>                <span class="comment"># (optional) the InfluxDB server port, defaults to 8086</span></span><br><span class="line"><span class="string">metrics.reporter.influxdb.db:</span> <span class="string">flink</span>                 <span class="comment"># the InfluxDB database to store metrics</span></span><br><span class="line"><span class="string">metrics.reporter.influxdb.username:</span> <span class="string">flink-metrics</span>   <span class="comment"># (optional) InfluxDB username</span></span><br><span class="line"><span class="string">metrics.reporter.influxdb.password:</span> <span class="string">qwerty</span>          <span class="comment"># (optional) InfluxDB username’s password</span></span><br><span class="line"><span class="string">metrics.reporter.influxdb.retentionPolicy:</span> <span class="string">one_hour</span> <span class="comment"># (optional) InfluxDB retention policy</span></span><br></pre></td></tr></table></figure><h3 id="flink-metrics-prometheus"><a href="#flink-metrics-prometheus" class="headerlink" title="flink-metrics-prometheus"></a>flink-metrics-prometheus</h3><h4 id="prometheus基本概念"><a href="#prometheus基本概念" class="headerlink" title="prometheus基本概念"></a>prometheus基本概念</h4><h4 id="Reporter实现-1"><a href="#Reporter实现-1" class="headerlink" title="Reporter实现"></a>Reporter实现</h4><p>Prometheus Reporter的详细类图如下，包括继承以及依赖关系：<br><img src="PrometheusReporter%E7%B1%BB%E5%9B%BE.png" alt></p><ul><li>AbstractPrometheusReporter<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyOfAddedMetric</span><span class="params">(<span class="keyword">final</span> Metric metric, <span class="keyword">final</span> String metricName, <span class="keyword">final</span> MetricGroup group)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维度key集合</span></span><br><span class="line">List&lt;String&gt; dimensionKeys = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 维度value集合</span></span><br><span class="line">List&lt;String&gt; dimensionValues = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, String&gt; dimension : group.getAllVariables().entrySet()) &#123;</span><br><span class="line"><span class="keyword">final</span> String key = dimension.getKey();</span><br><span class="line">dimensionKeys.add(CHARACTER_FILTER.filterCharacters(key.substring(<span class="number">1</span>, key.length() - <span class="number">1</span>)));</span><br><span class="line">dimensionValues.add(labelValueCharactersFilter.filterCharacters(dimension.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String scopedMetricName = getScopedName(metricName, group);</span><br><span class="line"><span class="keyword">final</span> String helpString = metricName + <span class="string">" (scope: "</span> + getLogicalScope(group) + <span class="string">")"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Collector collector;</span><br><span class="line">Integer count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (collectorsWithCountByMetricName.containsKey(scopedMetricName)) &#123;</span><br><span class="line"><span class="keyword">final</span> AbstractMap.SimpleImmutableEntry&lt;Collector, Integer&gt; collectorWithCount = collectorsWithCountByMetricName.get(scopedMetricName);</span><br><span class="line">collector = collectorWithCount.getKey();</span><br><span class="line">count = collectorWithCount.getValue();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">collector = createCollector(metric, dimensionKeys, dimensionValues, scopedMetricName, helpString);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 注册当前的 collector 到 CollectorRegistry.defaultRegistry 中</span></span><br><span class="line">collector.register();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.warn(<span class="string">"There was a problem registering metric &#123;&#125;."</span>, metricName, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">addMetric(metric, dimensionValues, collector);</span><br><span class="line">collectorsWithCountByMetricName.put(scopedMetricName, <span class="keyword">new</span> AbstractMap.SimpleImmutableEntry&lt;&gt;(collector, count + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将 Metric 转成 prometheus 的 Collector</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collector <span class="title">createCollector</span><span class="params">(Metric metric, List&lt;String&gt; dimensionKeys, List&lt;String&gt; dimensionValues, String scopedMetricName, String helpString)</span> </span>&#123;</span><br><span class="line">Collector collector;</span><br><span class="line"><span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Gauge || metric <span class="keyword">instanceof</span> Counter || metric <span class="keyword">instanceof</span> Meter) &#123;</span><br><span class="line">collector = io.prometheus.client.Gauge</span><br><span class="line">.build()</span><br><span class="line">.name(scopedMetricName)</span><br><span class="line">.help(helpString)</span><br><span class="line">.labelNames(toArray(dimensionKeys))</span><br><span class="line">.create();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Histogram) &#123;</span><br><span class="line">collector = <span class="keyword">new</span> HistogramSummaryProxy((Histogram) metric, scopedMetricName, helpString, dimensionKeys, dimensionValues);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.warn(<span class="string">"Cannot create collector for unknown metric type: &#123;&#125;. This indicates that the metric type is not supported by this reporter."</span>,</span><br><span class="line">metric.getClass().getName());</span><br><span class="line">collector = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> collector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 取出 Metric 中的值，为 Collector 设置 label values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addMetric</span><span class="params">(Metric metric, List&lt;String&gt; dimensionValues, Collector collector)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Gauge) &#123;</span><br><span class="line">((io.prometheus.client.Gauge) collector).setChild(gaugeFrom((Gauge) metric), toArray(dimensionValues));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Counter) &#123;</span><br><span class="line">((io.prometheus.client.Gauge) collector).setChild(gaugeFrom((Counter) metric), toArray(dimensionValues));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Meter) &#123;</span><br><span class="line">((io.prometheus.client.Gauge) collector).setChild(gaugeFrom((Meter) metric), toArray(dimensionValues));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Histogram) &#123;</span><br><span class="line">((HistogramSummaryProxy) collector).addChild((Histogram) metric, dimensionValues);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.warn(<span class="string">"Cannot add unknown metric type: &#123;&#125;. This indicates that the metric type is not supported by this reporter."</span>,</span><br><span class="line">metric.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：从Gauge中取值时不支持返回值为String：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">io.prometheus.client.Gauge.<span class="function">Child <span class="title">gaugeFrom</span><span class="params">(Gauge gauge)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> io.prometheus.client.Gauge.Child() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Object value = gauge.getValue();</span><br><span class="line"><span class="comment">// 注意：这里只支持 Gauge 的返回值为 Double、Number、Boolean 的，暂时不支持String</span></span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">log.debug(<span class="string">"Gauge &#123;&#125; is null-valued, defaulting to 0."</span>, gauge);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">double</span>) value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line"><span class="keyword">return</span> ((Number) value).doubleValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line"><span class="keyword">return</span> ((Boolean) value) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.debug(<span class="string">"Invalid type for Gauge &#123;&#125;: &#123;&#125;, only number types and booleans are supported by this reporter."</span>,</span><br><span class="line">gauge, value.getClass().getName());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如 LatestCompletedCheckpointExternalPathGauge 这个指标，用来记录上次完成的 checkpoint 路径，它的返回值是 String 类型，在向 PrometheusPushgateway 推送的时候会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LatestCompletedCheckpointExternalPathGauge</span> <span class="keyword">implements</span> <span class="title">Gauge</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CompletedCheckpointStats completed = latestCompletedCheckpoint;</span><br><span class="line"><span class="keyword">if</span> (completed != <span class="keyword">null</span> &amp;&amp; completed.getExternalPath() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> completed.getExternalPath();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"n/a"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">20:06:36.782 [Flink-MetricRegistry-thread-1] DEBUG org.apache.flink.metrics.prometheus.PrometheusPushGatewayReporter - Invalid type for Gauge org.apache.flink.runtime.checkpoint.CheckpointStatsTracker$LatestCompletedCheckpointExternalPathGauge@78b86b65: java.lang.String, only number types and booleans are supported by this reporter.</span><br><span class="line">20:06:36.810 [Flink-MetricRegistry-thread-1] WARN org.apache.flink.metrics.prometheus.PrometheusPushGatewayReporter - Failed to push metrics to PushGateway with jobName flinkSql_KUDUside_KUDUsink_20200324110200_69196657381606602020032420061183311.</span><br><span class="line">java.io.IOException: Response code from http://xx.xx.xx.xx:8891/metrics/job/flinkSql_KUDUside_KUDUsink_20200324110200_69196657381606602020032420061183311 was 200</span><br><span class="line">at org.apache.flink.shaded.io.prometheus.client.exporter.PushGateway.doRequest(PushGateway.java:297)</span><br><span class="line">at org.apache.flink.shaded.io.prometheus.client.exporter.PushGateway.push(PushGateway.java:105)</span><br><span class="line">at org.apache.flink.metrics.prometheus.PrometheusPushGatewayReporter.report(PrometheusPushGatewayReporter.java:76)</span><br><span class="line">at org.apache.flink.runtime.metrics.MetricRegistryImpl$ReporterTask.run(MetricRegistryImpl.java:436)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><ul><li><p>PrometheusPushGatewayReporterOptions<br>连接 PrometheusPushGateway 写指标的配置项</p></li><li><p>PrometheusPushGatewayReporter</p></li></ul><p>open() 方法中要根据指标配置文件初始化 PushGateway 操作类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据配置项初始化得到 PushGateway 操作类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(MetricConfig config)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.open(config);</span><br><span class="line"></span><br><span class="line">String host = config.getString(HOST.key(), HOST.defaultValue());</span><br><span class="line"><span class="keyword">int</span> port = config.getInteger(PORT.key(), PORT.defaultValue());</span><br><span class="line">String configuredJobName = config.getString(JOB_NAME.key(), JOB_NAME.defaultValue());</span><br><span class="line"><span class="keyword">boolean</span> randomSuffix = config.getBoolean(RANDOM_JOB_NAME_SUFFIX.key(), RANDOM_JOB_NAME_SUFFIX.defaultValue());</span><br><span class="line">deleteOnShutdown = config.getBoolean(DELETE_ON_SHUTDOWN.key(), DELETE_ON_SHUTDOWN.defaultValue());</span><br><span class="line">groupingKey = parseGroupingKey(config.getString(GROUPING_KEY.key(), GROUPING_KEY.defaultValue()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (host == <span class="keyword">null</span> || host.isEmpty() || port &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid host/port configuration. Host: "</span> + host + <span class="string">" Port: "</span> + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (randomSuffix) &#123;</span><br><span class="line"><span class="keyword">this</span>.jobName = configuredJobName + <span class="keyword">new</span> AbstractID();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.jobName = configuredJobName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pushGateway = <span class="keyword">new</span> PushGateway(host + <span class="string">':'</span> + port);</span><br><span class="line">log.info(<span class="string">"Configured PrometheusPushGatewayReporter with &#123;host:&#123;&#125;, port:&#123;&#125;, jobName:&#123;&#125;, randomJobNameSuffix:&#123;&#125;, deleteOnShutdown:&#123;&#125;, groupingKey:&#123;&#125;&#125;"</span>,</span><br><span class="line">host, port, jobName, randomSuffix, deleteOnShutdown, groupingKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>report() 方法中调用 pushgateway 的 push() 方法，直接走HTTP将指标推送出去了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 使用 PushGateway 的 push 方法，走 HTTP 协议，将指标推送到 PushGateway</span></span><br><span class="line">pushGateway.push(CollectorRegistry.defaultRegistry, jobName, groupingKey);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.warn(<span class="string">"Failed to push metrics to PushGateway with jobName &#123;&#125;, groupingKey &#123;&#125;."</span>, jobName, groupingKey, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PrometheusReporter</li></ul><p>open() 方法中要根据指标配置文件初始化一个HttpServer，让 Prometheus 来拉取：<br>注意：PrometheusReporter 类没有实现 Scheduled 接口，没有 report() 方法，因为它的指标是拉的，不是主动推的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据配置项初始化一个 HttpServer，让 Prometheus 来拉取指标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(MetricConfig config)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.open(config);</span><br><span class="line"></span><br><span class="line">String portsConfig = config.getString(ARG_PORT, DEFAULT_PORT);</span><br><span class="line">Iterator&lt;Integer&gt; ports = NetUtils.getPortRangeFromString(portsConfig);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ports.hasNext()) &#123;</span><br><span class="line"><span class="keyword">int</span> port = ports.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// internally accesses CollectorRegistry.defaultRegistry</span></span><br><span class="line">httpServer = <span class="keyword">new</span> HTTPServer(port);</span><br><span class="line"><span class="keyword">this</span>.port = port;</span><br><span class="line">log.info(<span class="string">"Started PrometheusReporter HTTP server on port &#123;&#125;."</span>, port);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123; <span class="comment">//assume port conflict</span></span><br><span class="line">log.debug(<span class="string">"Could not start PrometheusReporter HTTP server on port &#123;&#125;."</span>, port, ioe);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (httpServer == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not start PrometheusReporter HTTP server on any configured port. Ports: "</span> + portsConfig);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><ul><li><p>复制 flink-metrics-prometheus-xxx.jar 到 $FLINK_HOME/lib 下</p></li><li><p>如果使用 PrometheusReporter ，则在 flink-conf.yml 增加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metrics.reporter.prom.class:</span> <span class="string">org.apache.flink.metrics.prometheus.PrometheusReporter</span></span><br><span class="line"><span class="string">metrics.reporter.prom.port:</span> <span class="number">9249</span></span><br></pre></td></tr></table></figure></li><li><p>如果使用 PrometheusPushGatewayReporter ，则在 flink-conf.yml 增加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metrics.reporter.promgateway.class:</span> <span class="string">org.apache.flink.metrics.prometheus.PrometheusPushGatewayReporter</span></span><br><span class="line"><span class="string">metrics.reporter.promgateway.host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="string">metrics.reporter.promgateway.port:</span> <span class="number">9091</span></span><br><span class="line"><span class="string">metrics.reporter.promgateway.jobName:</span> <span class="string">myJob</span></span><br><span class="line"><span class="string">metrics.reporter.promgateway.randomJobNameSuffix:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">metrics.reporter.promgateway.deleteOnShutdown:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="flink-metrics-jmx"><a href="#flink-metrics-jmx" class="headerlink" title="flink-metrics-jmx"></a>flink-metrics-jmx</h3><h4 id="jmx基本概念"><a href="#jmx基本概念" class="headerlink" title="jmx基本概念"></a>jmx基本概念</h4><p>JMX（Java Management Extensions）是一个应用程序植入管理功能的框架。JMX 是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。</p><p>JMX 架构图如下：<br><img src="JMX%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt></p><h4 id="Reporter实现-2"><a href="#Reporter实现-2" class="headerlink" title="Reporter实现"></a>Reporter实现</h4><ul><li>JMXReporter：<br><img src="JMXReporter%E7%B1%BB%E5%9B%BE.png" alt></li></ul><p>首先通过 <code>ManagementFactory.getPlatformMBeanServer()</code> 获取JVM中全局唯一的 MBeanServer 单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">JMXReporter(<span class="meta">@Nullable</span> <span class="keyword">final</span> String portsConfig) &#123;</span><br><span class="line"><span class="comment">// 获取 MBeanServer 单例</span></span><br><span class="line"><span class="keyword">this</span>.mBeanServer = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line"><span class="comment">// 存放注册指标的Map</span></span><br><span class="line"><span class="keyword">this</span>.registeredMetrics = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (portsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">Iterator&lt;Integer&gt; ports = NetUtils.getPortRangeFromString(portsConfig);</span><br><span class="line"></span><br><span class="line">JMXServer successfullyStartedServer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (ports.hasNext() &amp;&amp; successfullyStartedServer == <span class="keyword">null</span>) &#123;</span><br><span class="line">JMXServer server = <span class="keyword">new</span> JMXServer();</span><br><span class="line"><span class="keyword">int</span> port = ports.next();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建并启动 Registry 和 JMXConnectorServer</span></span><br><span class="line">server.start(port);</span><br><span class="line">LOG.info(<span class="string">"Started JMX server on port "</span> + port + <span class="string">"."</span>);</span><br><span class="line">successfullyStartedServer = server;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123; <span class="comment">//assume port conflict</span></span><br><span class="line">LOG.debug(<span class="string">"Could not start JMX server on port "</span> + port + <span class="string">"."</span>, ioe);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">server.stop();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">LOG.debug(<span class="string">"Could not stop JMX server."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (successfullyStartedServer == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not start JMX server on any configured port. Ports: "</span> + portsConfig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.jmxServer = successfullyStartedServer;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.jmxServer = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">LOG.info(<span class="string">"Configured JMXReporter with &#123;port:&#123;&#125;&#125;"</span>, portsConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JMXRreporter中的MetricMBean：<br><img src="JMXRreporter%E4%B8%AD%E7%9A%84MetricMBean%E7%B1%BB%E5%9B%BE.png" alt></li></ul><p>添加指标项时，需要将 flink 中的 Metric 对象转换成 MetricBean ，再注册到 MBeanServer 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyOfAddedMetric</span><span class="params">(Metric metric, String metricName, MetricGroup group)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> String domain = generateJmxDomain(metricName, group);</span><br><span class="line"><span class="keyword">final</span> Hashtable&lt;String, String&gt; table = generateJmxTable(group.getAllVariables());</span><br><span class="line"></span><br><span class="line">AbstractBean jmxMetric;</span><br><span class="line">ObjectName jmxName;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">jmxName = <span class="keyword">new</span> ObjectName(domain, table);</span><br><span class="line">&#125; <span class="keyword">catch</span> (MalformedObjectNameException e) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * There is an implementation error on our side if this occurs. Either the domain was modified and no longer</span></span><br><span class="line"><span class="comment"> * conforms to the JMX domain rules or the table wasn't properly generated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LOG.debug(<span class="string">"Implementation error. The domain or table does not conform to JMX rules."</span> , e);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 flink 中的 Metric 转成 MBean</span></span><br><span class="line"><span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Gauge) &#123;</span><br><span class="line">jmxMetric = <span class="keyword">new</span> JmxGauge((Gauge&lt;?&gt;) metric);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Counter) &#123;</span><br><span class="line">jmxMetric = <span class="keyword">new</span> JmxCounter((Counter) metric);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Histogram) &#123;</span><br><span class="line">jmxMetric = <span class="keyword">new</span> JmxHistogram((Histogram) metric);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (metric <span class="keyword">instanceof</span> Meter) &#123;</span><br><span class="line">jmxMetric = <span class="keyword">new</span> JmxMeter((Meter) metric);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">LOG.error(<span class="string">"Cannot add unknown metric type: &#123;&#125;. This indicates that the metric type "</span> +</span><br><span class="line"><span class="string">"is not supported by this reporter."</span>, metric.getClass().getName());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">// 注册到 MetricBean 到 MBeanServer 中</span></span><br><span class="line">mBeanServer.registerMBean(jmxMetric, jmxName);</span><br><span class="line">registeredMetrics.put(metric, jmxName);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NotCompliantMBeanException e) &#123;</span><br><span class="line"><span class="comment">// implementation error on our side</span></span><br><span class="line">LOG.debug(<span class="string">"Metric did not comply with JMX MBean rules."</span>, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstanceAlreadyExistsException e) &#123;</span><br><span class="line">LOG.warn(<span class="string">"A metric with the name "</span> + jmxName + <span class="string">" was already registered."</span>, e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">LOG.warn(<span class="string">"Failed to register metric"</span>, t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><ul><li>在 flink-conf.yml 增加如下配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metrics.reporter.jmx.factory.class:</span> <span class="string">org.apache.flink.metrics.jmx.JMXReporterFactory</span></span><br><span class="line"><span class="string">metrics.reporter.jmx.port:</span> <span class="number">8789</span>  <span class="comment"># 如果有多个 TM 在同一台机器，端口可以设置成范围 9250-9260</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="flink-metrics-slf4j"><a href="#flink-metrics-slf4j" class="headerlink" title="flink-metrics-slf4j"></a>flink-metrics-slf4j</h3><p>Slf4jReporter 继承了 flink-metrics-core 模块中的 AbstractReporter，复用其添加移除指标的方法。<br>report() 方法的逻辑其实就是遍历所有的指标项，拼接成字符串，打印到日志文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// initialize with previous size to avoid repeated resizing of backing array</span></span><br><span class="line"><span class="comment">// pad the size to allow deviations in the final string, for example due to different double value representations</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder((<span class="keyword">int</span>) (previousSize * <span class="number">1.1</span>));</span><br><span class="line"></span><br><span class="line">builder</span><br><span class="line">.append(lineSeparator)</span><br><span class="line">.append(<span class="string">"=========================== Starting metrics report ==========================="</span>)</span><br><span class="line">.append(lineSeparator);</span><br><span class="line"></span><br><span class="line">builder</span><br><span class="line">.append(lineSeparator)</span><br><span class="line">.append(<span class="string">"-- Counters -------------------------------------------------------------------"</span>)</span><br><span class="line">.append(lineSeparator);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Counter, String&gt; metric : counters.entrySet()) &#123;</span><br><span class="line">builder</span><br><span class="line">.append(metric.getValue()).append(<span class="string">": "</span>).append(metric.getKey().getCount())</span><br><span class="line">.append(lineSeparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">builder</span><br><span class="line">.append(lineSeparator)</span><br><span class="line">.append(<span class="string">"-- Gauges ---------------------------------------------------------------------"</span>)</span><br><span class="line">.append(lineSeparator);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Gauge&lt;?&gt;, String&gt; metric : gauges.entrySet()) &#123;</span><br><span class="line">builder</span><br><span class="line">.append(metric.getValue()).append(<span class="string">": "</span>).append(metric.getKey().getValue())</span><br><span class="line">.append(lineSeparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">builder</span><br><span class="line">.append(lineSeparator)</span><br><span class="line">.append(<span class="string">"-- Meters ---------------------------------------------------------------------"</span>)</span><br><span class="line">.append(lineSeparator);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Meter, String&gt; metric : meters.entrySet()) &#123;</span><br><span class="line">builder</span><br><span class="line">.append(metric.getValue()).append(<span class="string">": "</span>).append(metric.getKey().getRate())</span><br><span class="line">.append(lineSeparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">builder</span><br><span class="line">.append(lineSeparator)</span><br><span class="line">.append(<span class="string">"-- Histograms -----------------------------------------------------------------"</span>)</span><br><span class="line">.append(lineSeparator);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Histogram, String&gt; metric : histograms.entrySet()) &#123;</span><br><span class="line">HistogramStatistics stats = metric.getKey().getStatistics();</span><br><span class="line">builder</span><br><span class="line">.append(metric.getValue()).append(<span class="string">": count="</span>).append(stats.size())</span><br><span class="line">.append(<span class="string">", min="</span>).append(stats.getMin())</span><br><span class="line">.append(<span class="string">", max="</span>).append(stats.getMax())</span><br><span class="line">.append(<span class="string">", mean="</span>).append(stats.getMean())</span><br><span class="line">.append(<span class="string">", stddev="</span>).append(stats.getStdDev())</span><br><span class="line">.append(<span class="string">", p50="</span>).append(stats.getQuantile(<span class="number">0.50</span>))</span><br><span class="line">.append(<span class="string">", p75="</span>).append(stats.getQuantile(<span class="number">0.75</span>))</span><br><span class="line">.append(<span class="string">", p95="</span>).append(stats.getQuantile(<span class="number">0.95</span>))</span><br><span class="line">.append(<span class="string">", p98="</span>).append(stats.getQuantile(<span class="number">0.98</span>))</span><br><span class="line">.append(<span class="string">", p99="</span>).append(stats.getQuantile(<span class="number">0.99</span>))</span><br><span class="line">.append(<span class="string">", p999="</span>).append(stats.getQuantile(<span class="number">0.999</span>))</span><br><span class="line">.append(lineSeparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">builder</span><br><span class="line">.append(lineSeparator)</span><br><span class="line">.append(<span class="string">"=========================== Finished metrics report ==========================="</span>)</span><br><span class="line">.append(lineSeparator);</span><br><span class="line">LOG.info(builder.toString());</span><br><span class="line"></span><br><span class="line">previousSize = builder.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h4><ul><li>复制 flink-metrics-slf4j-xxx.jar 到 $FLINK_HOME/lib 下</li><li>在 flink-conf.yml 增加如下配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metrics.reporter.slf4j.class:</span> <span class="string">org.apache.flink.metrics.slf4j.Slf4jReporter</span></span><br><span class="line"><span class="string">metrics.reporter.slf4j.interval:</span> <span class="number">60</span> <span class="string">SECONDS</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="flink-metrics-statsd"><a href="#flink-metrics-statsd" class="headerlink" title="flink-metrics-statsd"></a>flink-metrics-statsd</h3><h4 id="statsd基本概念"><a href="#statsd基本概念" class="headerlink" title="statsd基本概念"></a>statsd基本概念</h4><p>statsd 从狭义上讲，其实就是一个监听 UDP（Default）/TCP的守护程序。<br>statsd 系统包括三部分：客户端（client）、服务器（server）和后端（backend）<br>StatsDReporter 相当于 statsd 系统的客户端，将 metrics 上报给 statsd server，statsd server 聚合这些 metrics 之后，定时发送给 backend，<br>backend 则负责存储这些时间序列数据，并通过适当的图表工具展示。</p><p>statsd 经常与 graphite 一起使用，statsd 负责收集并聚合测量值，之后将数据传给 graphite ，graphite 以时间序列为依据存储数据，并绘制图表。</p><h4 id="Reporter实现-3"><a href="#Reporter实现-3" class="headerlink" title="Reporter实现"></a>Reporter实现</h4><p>这里我们只关注下发送 UDP 数据包的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// statsd 的协议其实非常简单，每一行就是一条数据，g 表示 Gauge</span></span><br><span class="line"><span class="comment">// 如 "system.load.1min:0.5|g"，表示某一时刻系统1分钟的负载为0.5</span></span><br><span class="line">String formatted = String.format(<span class="string">"%s:%s|g"</span>, name, value);</span><br><span class="line"><span class="keyword">byte</span>[] data = formatted.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">// 默认通过 socket 发送 UDP 数据包到 StatsD</span></span><br><span class="line"><span class="comment">// 因为 UDP 比 TCP 更快，不想为了追踪应用的表现而减慢其速度</span></span><br><span class="line">socket.send(<span class="keyword">new</span> DatagramPacket(data, data.length, <span class="keyword">this</span>.address));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">LOG.error(<span class="string">"unable to send packet to statsd at '&#123;&#125;:&#123;&#125;'"</span>, address.getHostName(), address.getPort());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-5"><a href="#配置-5" class="headerlink" title="配置"></a>配置</h4><ul><li>复制 flink-metrics-statsd-xxx.jar 到 $FLINK_HOME/lib 下</li><li>在 flink-conf.yml 增加如下配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metrics.reporter.stsd.class:</span> <span class="string">org.apache.flink.metrics.statsd.StatsDReporter</span></span><br><span class="line"><span class="string">metrics.reporter.stsd.host:</span> <span class="string">localhost</span>    <span class="comment"># the StatsD server host</span></span><br><span class="line"><span class="string">metrics.reporter.stsd.port:</span> <span class="number">8125</span>         <span class="comment"># the StatsD server port</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="flink-metrics-datadog"><a href="#flink-metrics-datadog" class="headerlink" title="flink-metrics-datadog"></a>flink-metrics-datadog</h3><p>datadog这里就不详细说了，其实就是添加指标时将 flink 中的 Metric 转成 DMetric<br>汇报时将 DMetric 指标封装成 DatadogHttpRequest，使用 HttpClient 发送出去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DatadogHttpRequest request = <span class="keyword">new</span> DatadogHttpRequest();</span><br><span class="line"></span><br><span class="line">List&lt;Gauge&gt; gaugesToRemove = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Gauge, DGauge&gt; entry : gauges.entrySet()) &#123;</span><br><span class="line">DGauge g = entry.getValue();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Will throw exception if the Gauge is not of Number type</span></span><br><span class="line"><span class="comment">// Flink uses Gauge to store many types other than Number</span></span><br><span class="line">g.getMetricValue();</span><br><span class="line">request.addGauge(g);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">LOGGER.info(<span class="string">"The metric &#123;&#125; will not be reported because only number types are supported by this reporter."</span>, g.getMetric());</span><br><span class="line">gaugesToRemove.add(entry.getKey());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">LOGGER.debug(<span class="string">"The metric &#123;&#125; will not be reported because it threw an exception."</span>, g.getMetric(), e);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">LOGGER.info(<span class="string">"The metric &#123;&#125; will not be reported because it threw an exception."</span>, g.getMetric());</span><br><span class="line">&#125;</span><br><span class="line">gaugesToRemove.add(entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">gaugesToRemove.forEach(gauges::remove);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DCounter c : counters.values()) &#123;</span><br><span class="line">request.addCounter(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DMeter m : meters.values()) &#123;</span><br><span class="line">request.addMeter(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">client.send(request);</span><br><span class="line">LOGGER.debug(<span class="string">"Reported series with size &#123;&#125;."</span>, request.getSeries().getSeries().size());</span><br><span class="line">&#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">LOGGER.warn(<span class="string">"Failed reporting metrics to Datadog because of socket timeout: &#123;&#125;."</span>, e.getMessage());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">LOGGER.warn(<span class="string">"Failed reporting metrics to Datadog."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-6"><a href="#配置-6" class="headerlink" title="配置"></a>配置</h4><ul><li>复制 flink-metrics-datadog-xxx.jar 到 $FLINK_HOME/lib 下</li><li>在 flink-conf.yml 增加如下配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">metrics.reporter.dghttp.class:</span> <span class="string">org.apache.flink.metrics.datadog.DatadogHttpReporter</span></span><br><span class="line"><span class="string">metrics.reporter.dghttp.apikey:</span> <span class="string">xxx</span>                   <span class="comment"># the Datadog API key</span></span><br><span class="line"><span class="comment">#(optional) the global tags that will be applied to metrics when sending to Datadog. Tags should be separated by comma only</span></span><br><span class="line"><span class="string">metrics.reporter.dghttp.tags:</span> <span class="string">myflinkapp,prod</span> </span><br><span class="line"><span class="string">metrics.reporter.dghttp.proxyHost:</span> <span class="string">my.web.proxy.com</span>   <span class="comment">#(optional) The proxy host to use when sending to Datadog</span></span><br><span class="line"><span class="string">metrics.reporter.dghttp.proxyPort:</span> <span class="number">8080</span>               <span class="comment">#(optional) The proxy port to use when sending to Datadog, defaults to 8080</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="flink中的指标项"><a href="#flink中的指标项" class="headerlink" title="flink中的指标项"></a>flink中的指标项</h2><p>在看 flink 指标项时，可以</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><table><thead><tr><th align="left">指标名</th></tr></thead><tbody><tr><td align="left">flink_taskmanager_job_task_operator_dtNumBytesIn</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtNumBytesInRate</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtNumRecordsIn</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtNumRecordsInRate</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtNumRecordsInResolve</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtNumRecordsInResolveRate</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtNumRecordsOut</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtNumRecordsOutRate</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtDirtyData</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_topic_partition_dtTopicPartitionLag</td></tr><tr><td align="left">flink_taskmanager_job_task_operator_dtEventDelay</td></tr></tbody></table><h3 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h3><table><thead><tr><th align="left">指标名</th></tr></thead><tbody><tr><td align="left">flink_jobmanager_job_lastCheckpointDuration</td></tr><tr><td align="left">flink_jobmanager_job_lastCheckpointSize</td></tr><tr><td align="left">flink_jobmanager_job_numberOfFailedCheckpoints</td></tr></tbody></table><h3 id="Watermark"><a href="#Watermark" class="headerlink" title="Watermark"></a>Watermark</h3><table><thead><tr><th>指标名</th></tr></thead><tbody><tr><td>flink_taskmanager_job_task_operator_currentInputWatermark</td></tr><tr><td>flink_taskmanager_job_task_operator_currentOutputWatermark</td></tr><tr><td>flink_taskmanager_job_task_operator_numLateRecordsDropped</td></tr></tbody></table><h3 id="BackPressure"><a href="#BackPressure" class="headerlink" title="BackPressure"></a>BackPressure</h3><table><thead><tr><th>指标名</th></tr></thead><tbody><tr><td>flink_taskmanager_job_task_buffers_inPoolUsage</td></tr><tr><td>flink_taskmanager_job_task_buffers_outPoolUsage</td></tr><tr><td>flink_taskmanager_job_task_buffers_inputQueueLength</td></tr><tr><td>flink_taskmanager_job_task_buffers_outputQueueLength</td></tr></tbody></table><h3 id="Kafka-Connector"><a href="#Kafka-Connector" class="headerlink" title="Kafka Connector"></a>Kafka Connector</h3><table><thead><tr><th>指标名</th></tr></thead><tbody><tr><td>flink_taskmanager_job_task_operator_commitsFailed</td></tr><tr><td>flink_taskmanager_job_task_operator_KafkaConsumer_topic_partition_currentOffsets</td></tr><tr><td>flink_taskmanager_job_task_operator_KafkaConsumer_records_lag_max</td></tr></tbody></table><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><table><thead><tr><th>指标名</th></tr></thead><tbody><tr><td>flink_jobmanager_Status_JVM_CPU_Load</td></tr><tr><td>flink_jobmanager_Status_JVM_CPU_Time</td></tr><tr><td>flink_jobmanager_Status_JVM_GarbageCollector_PS_MarkSweep_Count</td></tr><tr><td>flink_jobmanager_Status_JVM_GarbageCollector_PS_MarkSweep_Time</td></tr><tr><td>flink_jobmanager_Status_JVM_GarbageCollector_PS_Scavenge_Count</td></tr><tr><td>flink_jobmanager_Status_JVM_GarbageCollector_PS_Scavenge_Time</td></tr><tr><td>flink_jobmanager_Status_JVM_Memory_Heap_Max</td></tr><tr><td>flink_jobmanager_Status_JVM_Memory_Heap_Used</td></tr><tr><td>flink_jobmanager_Status_JVM_Memory_NonHeap_Max</td></tr><tr><td>flink_jobmanager_Status_JVM_Memory_NonHeap_Used</td></tr><tr><td>flink_jobmanager_Status_JVM_Threads_Count</td></tr><tr><td>flink_taskmanager_Status_JVM_CPU_Load</td></tr><tr><td>flink_taskmanager_Status_JVM_CPU_Time</td></tr><tr><td>flink_taskmanager_Status_JVM_GarbageCollector_G1_Old_Generation_Count</td></tr><tr><td>flink_taskmanager_Status_JVM_GarbageCollector_G1_Old_Generation_Time</td></tr><tr><td>flink_taskmanager_Status_JVM_GarbageCollector_G1_Young_Generation_Count</td></tr><tr><td>flink_taskmanager_Status_JVM_GarbageCollector_G1_Young_Generation_Time</td></tr><tr><td>flink_taskmanager_Status_JVM_Memory_Heap_Max</td></tr><tr><td>flink_taskmanager_Status_JVM_Memory_Heap_Used</td></tr><tr><td>flink_taskmanager_Status_JVM_Memory_NonHeap_Max</td></tr><tr><td>flink_taskmanager_Status_JVM_Memory_NonHeap_Used</td></tr><tr><td>flink_taskmanager_Status_JVM_Threads_Count</td></tr></tbody></table><h2 id="指标平台化实践"><a href="#指标平台化实践" class="headerlink" title="指标平台化实践"></a>指标平台化实践</h2><p>首先，参考：<a href="https://miaowenting.gitee.io/miaowenting.gitee.io/2020/02/04/Monitor-with-Prometheus-And-Grafana/" target="_blank" rel="noopener">Monitor with Prometheus And Grafana</a>，<br>安装 Prometheus、pushgateway、Grafana 服务，以及学习如何在Grafana中添加指标项图标。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将详细介绍下Flink中的指标实现，包括自带的指标名和如何自定义指标。还会介绍下现在已经支持的reporter，如jmx、slf4j、influxdb、graphite、prometheus、pushgateway等。&lt;br&gt;最后介绍下flink指标平台化实践。&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>插件化技术</title>
    <link href="http://yoursite.com/2020/03/29/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2020/03/29/插件化技术/</id>
    <published>2020-03-29T02:37:10.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍代码设计中的插件化实现。涉及到的关键技术点 <code>自定义ClassLoader</code> 和 <code>ServiceLoader</code> 。<br>接着，会说下插件化技术的典型应用场景。</p><a id="more"></a><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>参考：<a href="https://miaowenting.gitee.io/miaowenting.gitee.io/2020/02/09/JVM/#more" target="_blank" rel="noopener">JVM</a> 中关于<code>3.2 类的生命周期</code> 介绍。</p><h3 id="显式与隐式加载"><a href="#显式与隐式加载" class="headerlink" title="显式与隐式加载"></a>显式与隐式加载</h3><p>显式：在代码中通过调用 ClassLoader 加载 class 对象，如直接使用 Class.forName(name) 或 this.getClass().getClassLoader().loadClass() 加载 class 对象<br>隐式：通过虚拟机自动加载到内存中，如在加载某个类的 class 文件时，该类的 class 文件中引用了另外一个类的对象，此时额外引用的类将通过 JVM 自动加载到内存中</p><p>一段源程序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(hello());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成字节码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac demo.java</span><br></pre></td></tr></table></figure><p>对class文件反汇编：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javap -v -l -c demo.class &gt; Demo.txt</span><br><span class="line"></span><br><span class="line">-v: 不仅会输出行号、本地变量表信息、反编译汇编代码，还会输出当前类用到的常量池等信息</span><br><span class="line">-l: 输出行号和本地变量表信息</span><br><span class="line">-c: 会对当前 class 字节码进行反编译生成汇编代码</span><br></pre></td></tr></table></figure><p>通过文件编译工具来查看demo.txt的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Classfile /private/tmp/Demo.class</span><br><span class="line">  Last modified 2020-4-4; size 464 bytes</span><br><span class="line">  MD5 checksum 2b2ee02c5a47ef7f4ed5388443f76800</span><br><span class="line">  Compiled from &quot;Demo.java&quot;</span><br><span class="line">public class Demo</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = Methodref          #5.#20         // Demo.hello:()I</span><br><span class="line">   #4 = Methodref          #21.#22        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #5 = Class              #23            // Demo</span><br><span class="line">   #6 = Class              #24            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               hello</span><br><span class="line">  #12 = Utf8               ()I</span><br><span class="line">  #13 = Utf8               main</span><br><span class="line">  #14 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #15 = Utf8               SourceFile</span><br><span class="line">  #16 = Utf8               Demo.java</span><br><span class="line">  #17 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #18 = Class              #25            // java/lang/System</span><br><span class="line">  #19 = NameAndType        #26:#27        // out:Ljava/io/PrintStream;</span><br><span class="line">  #20 = NameAndType        #11:#12        // hello:()I</span><br><span class="line">  #21 = Class              #28            // java/io/PrintStream</span><br><span class="line">  #22 = NameAndType        #29:#30        // println:(I)V</span><br><span class="line">  #23 = Utf8               Demo</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">  #25 = Utf8               java/lang/System</span><br><span class="line">  #26 = Utf8               out</span><br><span class="line">  #27 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #28 = Utf8               java/io/PrintStream</span><br><span class="line">  #29 = Utf8               println</span><br><span class="line">  #30 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public Demo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  static int hello();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=0</span><br><span class="line">         0: iconst_1</span><br><span class="line">         1: istore_0</span><br><span class="line">         2: iconst_2</span><br><span class="line">         3: istore_1</span><br><span class="line">         4: iload_0</span><br><span class="line">         5: iload_1</span><br><span class="line">         6: iadd</span><br><span class="line">         7: istore_2</span><br><span class="line">         8: iload_2</span><br><span class="line">         9: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 2</span><br><span class="line">        line 5: 4</span><br><span class="line">        line 6: 8</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">    stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: invokestatic  #3                  // Method hello:()I</span><br><span class="line">         6: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 9</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下 <code>#1 = Methodref          #6.#17         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code>：<br>执行类的构造方法时，首先会执行父类的构造方法，java.lang.Object是任何类的父类，<br>所以这边会首先执行 Object 类的构造方法，#1 会引用 #6、#17 对应的符号常量。</p><p>在JVM中表示两个class对象是否为同一个类对象存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。</li></ul><h3 id="Launcher启动类"><a href="#Launcher启动类" class="headerlink" title="Launcher启动类"></a>Launcher启动类</h3><p>Launcher启动类图：<br><img src="Launcher%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%9B%BE.png" alt></p><h3 id="加载器类型"><a href="#加载器类型" class="headerlink" title="加载器类型"></a>加载器类型</h3><ul><li>启动类加载器，由C++实现，没有父类。</li><li>拓展类加载器(ExtClassLoader)，由Java语言实现，父类加载器为null</li><li>系统类加载器(AppClassLoader)，由Java语言实现，父类加载器为ExtClassLoader</li><li>自定义类加载器，父类加载器肯定为AppClassLoader。</li></ul><p>加载器之间的类图关系：<br><img src="ClassLoader%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB.png" alt></p><h4 id="loadClass-String"><a href="#loadClass-String" class="headerlink" title="loadClass(String)"></a>loadClass(String)</h4><p>将类加载请求到来时，先从缓存中查找该类对象，如果不存在就走双亲委派模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            <span class="comment">// 首先判断这个 class 是否已经加载成功，只判断全限定名是否相同</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 先通过父类加载器查找，递归下去，直到 BootstrapClassLoader</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果父加载器为null，则用 BootstrapClassLoader 去加载</span></span><br><span class="line">                        <span class="comment">// 这也解释了 ExtClassLoader 的parent为null，但仍然说 BootstrapClassLoader 是它的父加载器</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果向上委托父加载没有加载成功，则通过 findClass(String) 查找</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                <span class="comment">// 生成最终的Class对象，对应着验证、准备、解析的过程</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="findClass-String"><a href="#findClass-String" class="headerlink" title="findClass(String)"></a>findClass(String)</h4><p>不建议直接覆盖 loadClass() 去打破双亲委派模式，建议把自定义逻辑写在 findClass() 中，findClass() 方法通常是和 defineClass() 方法一起使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="defineClass-byte-b-int-off-int-len"><a href="#defineClass-byte-b-int-off-int-len" class="headerlink" title="defineClass(byte[] b,int off,int len)"></a>defineClass(byte[] b,int off,int len)</h4><p>将byte字节流解析成JVM 能够识别的Class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                        ProtectionDomain protectionDomain)</span><br><span class="line">       <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">   &#123;</span><br><span class="line">       protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">       String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">       Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">       postDefineClass(c, protectionDomain);</span><br><span class="line">       <span class="keyword">return</span> c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="resolveClass-Class-lt-gt-c"><a href="#resolveClass-Class-lt-gt-c" class="headerlink" title="resolveClass(Class&lt;?&gt; c)"></a>resolveClass(Class&lt;?&gt; c)</h4><p>对应链接阶段，它是native方法，主要对字节码进行验证，为类变量分配内存并设置初始值，将字节码文件中的符号引用转换为直接引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">       resolveClass0(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><p>为什么要自定义ClassLoader呢？</p><ul><li>当 class 文件不在 classpath 路径下，默认系统类加载无法找到该 class 文件，此时需要实现一个自定义的 ClassLoader 来加载特定路径下的 class 文件生成 Class 对象</li><li>当一个 class 文件是通过网络传输并且可能会进行相应的加密操作时，需要先对 class 文件进行相应的解密后再加载到 JVM 内存中</li><li>当需要实现热部署功能时，一个 class 文件通过不同的类加载器产生不同 class 对象从而实现热部署功能</li></ul><p>自定义FileClassLoader：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mwt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-04-03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASS_FILE_SUFFIX = <span class="string">".class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mLibpath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileClassLoader</span><span class="params">(String mLibpath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mLibpath = mLibpath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        String classFileName = getClassFileName(name);</span><br><span class="line">        File file = <span class="keyword">new</span> File(mLibpath, classFileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    bos.write(len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] data = bos.toByteArray();</span><br><span class="line">            is.close();</span><br><span class="line">            bos.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取java类对应的class文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getClassFileName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = name.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name + CLASS_FILE_SUFFIX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name.substring(index + <span class="number">1</span>) + CLASS_FILE_SUFFIX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>在Java应用中存在着很多服务提供者接口，Service Provider Interface，这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等。这些SPI的接口属于Java核心库，一般存在于rt.jar中，<br>由 Bootstrap 类加载器加载，而 SPI 的第三方实现代码则是作为 Java 应用所依赖的jar包被存放在 classpath 路径下。SPI 接口中的代码经常需要加载第三方实现类并调用其相关方法，但 SPI 的核心接口类是由 Bootstrap 类加载器加载，由于双亲委派模式的存在，Bootstrap 类加载器也无法反向委托 AppClassLoader 加载 SPI 的实现类。<br>此时，就需要一种特殊的类加载来加载第三方的类库，而线程上下文加载器就是很好的选择，可以破坏双亲委派模型。</p><p>如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器。<br>如在Launcher类中，会将AppClassLoader设置到当前线程上下文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now create the class loader to use to launch the application</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">            <span class="string">"Could not create application class loader"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Also set the context class loader for the primordial thread.</span></span><br><span class="line">    <span class="comment">// 设置AppClassLoader为线程上下文类加载器</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br></pre></td></tr></table></figure><h3 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h3><p>首先看下 ServiceLoader 的成员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 指明了路径是在"META-INF/services“下</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line">  <span class="comment">// 表示正在加载的服务的类或接口</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">  <span class="comment">// 使用的类加载器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">  <span class="comment">// 创建ServiceLoader时获取的访问控制上下文</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">  <span class="comment">// 缓存的服务提供者集合</span></span><br><span class="line">  <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 内部使用的迭代器，用于类的懒加载，只有在迭代时才加载</span></span><br><span class="line">  <span class="comment">// ServiceLoader 的实际加载过程是交给 LazyIterator 来做的</span></span><br><span class="line">  <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用其静态的load方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">  ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">  <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             ClassLoader loader)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注下LazyIterator中的nextService方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">  String cn = nextName;</span><br><span class="line">  nextName = <span class="keyword">null</span>;</span><br><span class="line">  Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在迭代器的next中才会进行真正的类加载</span></span><br><span class="line">    c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">    fail(service,</span><br><span class="line">                  <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">    fail(service,</span><br><span class="line">                  <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    S p = service.cast(c.newInstance());</span><br><span class="line">    providers.put(cn, p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">    fail(service,</span><br><span class="line">                  <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                  x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">  <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><img src="JDBC%E9%A9%B1%E5%8A%A8%E5%8C%85%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt></p><p>DriverManager类的static块中会加载所用的Driver实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DriverManager是Java核心包rt.jar的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"><span class="comment">//省略不必要的代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();<span class="comment">//执行该方法</span></span><br><span class="line">        println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//loadInitialDrivers方法</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sun.misc.Providers()</span><br><span class="line">     AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//加载外部的Driver的实现类</span></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">              <span class="comment">//省略不必要的代码......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ServiceLoader中的load方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过线程上下文类加载器加载，默认情况下就是AppClassLoader</span></span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不同的数据库驱动包中的 META-INF/services 目录下都会有一个名为 <code>java.sql.Driver</code> 的文件，记录Driver的实现类。<br>Mysql驱动包中：<br><img src="MySQL%E7%9A%84SPI%E9%A9%B1%E5%8A%A8%E7%B1%BB.png" alt></p><p>Oracle驱动包中：<br><img src="Oracle%E7%9A%84SPI%E9%A9%B1%E5%8A%A8%E7%B1%BB.png" alt></p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="Flink中的插件化应用"><a href="#Flink中的插件化应用" class="headerlink" title="Flink中的插件化应用"></a>Flink中的插件化应用</h3><h3 id="DataX插件加载原理"><a href="#DataX插件加载原理" class="headerlink" title="DataX插件加载原理"></a>DataX插件加载原理</h3><p>插件的加载都是使用ClassLoader动态加载。 为了避免类的冲突，对于每个插件的加载，对应着独立的加载器。加载器由JarLoader实现，插件的加载接口由LoadUtil类负责。当要加载一个插件时，需要实例化一个JarLoader，然后切换thread class loader之后，才加载插件。</p><ul><li><p>自定义JarLoader<br>JarLoader 继承 URLClassLoader，扩充了可以加载目录的功能。可以从指定的目录下，把传入的路径，及其子路径、以及路径中的jar文件加入到classpath。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JarLoader</span><span class="params">(String[] paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(paths, JarLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JarLoader</span><span class="params">(String[] paths, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用getURLS，获取所有的jar包路径</span></span><br><span class="line">        <span class="keyword">super</span>(getURLs(paths), parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的jar包</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> URL[] getURLs(String[] paths) &#123;</span><br><span class="line">        <span class="comment">// 获取包括子目录的所有目录路径</span></span><br><span class="line">        List&lt;String&gt; dirs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">            dirs.add(path);</span><br><span class="line">            <span class="comment">// 获取path目录和其子目录的所有目录路径</span></span><br><span class="line">            JarLoader.collectDirs(path, dirs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历目录，获取jar包的路径</span></span><br><span class="line">        List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String path : dirs) &#123;</span><br><span class="line">            urls.addAll(doGetURLs(path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> urls.toArray(<span class="keyword">new</span> URL[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归的方式，获取所有目录</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collectDirs</span><span class="params">(String path, List&lt;String&gt; collector)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// path为空，终止</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == path || StringUtils.isBlank(path)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// path不为目录，终止</span></span><br><span class="line">        File current = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!current.exists() || !current.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完子文件，终止</span></span><br><span class="line">        <span class="keyword">for</span> (File child : current.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!child.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            collector.add(child.getAbsolutePath());</span><br><span class="line">            collectDirs(child.getAbsolutePath(), collector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="title">doGetURLs</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        File jarPath = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="comment">// 只寻找文件以.jar结尾的文件</span></span><br><span class="line">        FileFilter jarFilter = <span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">".jar"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        File[] allJars = <span class="keyword">new</span> File(path).listFiles(jarFilter);</span><br><span class="line">        List&lt;URL&gt; jarURLs = <span class="keyword">new</span> ArrayList&lt;URL&gt;(allJars.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allJars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jarURLs.add(allJars[i].toURI().toURL());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> DataXException.asDataXException(</span><br><span class="line">                        FrameworkErrorCode.PLUGIN_INIT_ERROR,</span><br><span class="line">                        <span class="string">"系统加载jar包出错"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jarURLs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>LoadUtil类<br>LoadUtil管理着插件的加载器，调用getJarLoader返回插件对应的加载器。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadUtil</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载器的HashMap, Key由插件类型和名称决定, 格式为plugin.&#123;pulginType&#125;.&#123;pluginName&#125;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, JarLoader&gt; jarLoaderCenter = <span class="keyword">new</span> HashMap&lt;String, JarLoader&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> JarLoader <span class="title">getJarLoader</span><span class="params">(PluginType pluginType, String pluginName)</span> </span>&#123;</span><br><span class="line">        Configuration pluginConf = getPluginConf(pluginType, pluginName);</span><br><span class="line"></span><br><span class="line">        JarLoader jarLoader = jarLoaderCenter.get(generatePluginKey(pluginType,</span><br><span class="line">                pluginName));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == jarLoader) &#123;</span><br><span class="line">            <span class="comment">// 构建加载器JarLoader</span></span><br><span class="line">            <span class="comment">// 获取jar所在的目录</span></span><br><span class="line">            String pluginPath = pluginConf.getString(<span class="string">"path"</span>);</span><br><span class="line">            jarLoader = <span class="keyword">new</span> JarLoader(<span class="keyword">new</span> String[]&#123;pluginPath&#125;);</span><br><span class="line">            <span class="comment">//添加到HashMap中</span></span><br><span class="line">            jarLoaderCenter.put(generatePluginKey(pluginType, pluginName),</span><br><span class="line">                    jarLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jarLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String pluginTypeNameFormat = <span class="string">"plugin.%s.%s"</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 生成HashMpa的key值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">generatePluginKey</span><span class="params">(PluginType pluginType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            String pluginName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(pluginTypeNameFormat, pluginType.toString(),</span><br><span class="line">                pluginName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当获取类加载器，就可以调用 LoadUtil 来加载插件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载插件类</span></span><br><span class="line"><span class="comment">// pluginType 代表插件类型</span></span><br><span class="line"><span class="comment">// pluginName 代表插件名称</span></span><br><span class="line"><span class="comment">// pluginRunType 代表着运行类型，Job或者Task</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Class&lt;? extends AbstractPlugin&gt; loadPluginClass(</span><br><span class="line">    PluginType pluginType, String pluginName,</span><br><span class="line">    ContainerType pluginRunType) &#123;</span><br><span class="line">    <span class="comment">// 获取插件配置</span></span><br><span class="line">    Configuration pluginConf = getPluginConf(pluginType, pluginName);</span><br><span class="line">    <span class="comment">// 获取插件对应的ClassLoader</span></span><br><span class="line">    JarLoader jarLoader = LoadUtil.getJarLoader(pluginType, pluginName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载插件的class</span></span><br><span class="line">        <span class="keyword">return</span> (Class&lt;? extends AbstractPlugin&gt;) jarLoader</span><br><span class="line">            .loadClass(pluginConf.getString(<span class="string">"class"</span>) + <span class="string">"$"</span></span><br><span class="line">                       + pluginRunType.value());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> DataXException.asDataXException(FrameworkErrorCode.RUNTIME_ERROR, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ClassLoaderSwapper类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderSwapper</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存切换之前的加载器</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader storeClassLoader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">setCurrentThreadClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存切换前的加载器</span></span><br><span class="line">        <span class="keyword">this</span>.storeClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">// 切换加载器到classLoader</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.storeClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">restoreCurrentThreadClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ClassLoader classLoader = Thread.currentThread()</span><br><span class="line">                .getContextClassLoader();</span><br><span class="line">        <span class="comment">// 切换到原来的加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.storeClassLoader);</span><br><span class="line">        <span class="comment">// 返回切换之前的类加载器</span></span><br><span class="line">        <span class="keyword">return</span> classLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换类加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">ClassLoaderSwapper classLoaderSwapper = ClassLoaderSwapper.newCurrentThreadClassLoaderSwapper();</span><br><span class="line"></span><br><span class="line">ClassLoader classLoader1 = <span class="keyword">new</span> URLClassLoader();</span><br><span class="line"><span class="comment">// 切换加载器classLoader1</span></span><br><span class="line">classLoaderSwapper.setCurrentThreadClassLoader(classLoader1);</span><br><span class="line">Class&lt;? extends MyClass&gt; myClass = classLoader1.loadClass(<span class="string">"MyClass"</span>);</span><br><span class="line"><span class="comment">// 切回加载器</span></span><br><span class="line">classLoaderSwapper.restoreCurrentThreadClassLoader();</span><br></pre></td></tr></table></figure><h3 id="解决大数据引擎及版本众多问题"><a href="#解决大数据引擎及版本众多问题" class="headerlink" title="解决大数据引擎及版本众多问题"></a>解决大数据引擎及版本众多问题</h3><h3 id="WMRouter中对ServiceLoader的改进与使用"><a href="#WMRouter中对ServiceLoader的改进与使用" class="headerlink" title="WMRouter中对ServiceLoader的改进与使用"></a>WMRouter中对ServiceLoader的改进与使用</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍代码设计中的插件化实现。涉及到的关键技术点 &lt;code&gt;自定义ClassLoader&lt;/code&gt; 和 &lt;code&gt;ServiceLoader&lt;/code&gt; 。&lt;br&gt;接着，会说下插件化技术的典型应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>朋友只是人生过客</title>
    <link href="http://yoursite.com/2020/03/28/%E6%9C%8B%E5%8F%8B%E5%8F%AA%E6%98%AF%E4%BA%BA%E7%94%9F%E8%BF%87%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/03/28/朋友只是人生过客/</id>
    <published>2020-03-28T13:03:17.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>散了很好啊 就是<br>人的每一分钟都在变化<br>所以也要接受别人有变化</p><a id="more"></a><p>如果那个人跟你一日为友就终身为友<br>你应该心里很紧张才对 就是<br>怎么啦 我们两个都从此不变化了吗<br>所以 如果有了变化<br>然后人际关系跟着有了变化<br>他（她）是你某一阶段最好的朋友<br>然后他当完了他该当的朋友<br>他就去当别人的朋友了<br>就接受人生的变化是最好的态度</p><p>不要轻易去依赖一个人<br>它会成为你的习惯<br>当分别来临时<br>你失去的不是某个人<br>而是某一种精神寄托<br>无论何时何地<br>都要学会独立行走<br>它会让你走的更坦然<br>更处变不惊</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;散了很好啊 就是&lt;br&gt;人的每一分钟都在变化&lt;br&gt;所以也要接受别人有变化&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>关于数据中台的思考与总结</title>
    <link href="http://yoursite.com/2020/03/24/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/03/24/关于数据中台的思考与总结/</id>
    <published>2020-03-24T12:52:27.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将总结下数据中台的相关理论知识。<br>Flink平台化需要改进的点等等。</p><p>参考：<br>《数据中台》</p><a id="more"></a><h2 id="数据中台"><a href="#数据中台" class="headerlink" title="数据中台"></a>数据中台</h2><p><img src="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E4%BA%A7%E5%93%81%E6%9E%B6%E6%9E%84.png" alt></p><h3 id="数据汇聚"><a href="#数据汇聚" class="headerlink" title="数据汇聚"></a>数据汇聚</h3><p>数据汇聚是数据中台必须提供的核心工具，把各种异构网络、异构数据源的数据方便地采集到数据中台中进行集中存储，为后续的加工建模做准备。数据汇聚方式一般有数据库同步、埋点、网络爬虫、消息队列等；从汇聚的时效性来分，有离线批量汇聚和实时采集。</p><ul><li>数据采集工具<br>Canal、DataX、Sqoop</li></ul><h3 id="数据开发"><a href="#数据开发" class="headerlink" title="数据开发"></a>数据开发</h3><p>数据开发模块主要面向开发人员、分析人员，提供离线、实时、算法开发工具。</p><h4 id="离线开发"><a href="#离线开发" class="headerlink" title="离线开发"></a>离线开发</h4><ol><li>作业调度</li></ol><ul><li>依赖调度：所有父作业运行完成后，当前作业才能开始运行。图64中的作业B，只有父作业A和C运行完成后，才能开始被调度。</li><li>时间调度：可指定作业的调度开始时间。图64中的作业B，只有到达05：00后才能开始被调度。</li></ul><ol start="2"><li><p>基线控制<br>在大数据离线作业中，作业执行时间较长，经常遇到急着用数据发现数据还没出来的情况。采用算法对作业完成时间进行智能预测，根据预测，当作业无法正常产出且动态调整无法完成时，调度中心会及时通过监控告警通知运维值班人员提前介入处理，为大数据作业执行留出充裕的时间。</p></li><li><p>异构存储<br>企业内部的存储计算引擎呈多元化趋势。离线开发中心针对每种类型的计算引擎会开发不同的组件，例如，针对Oracle开发Oracle插件，针对Hadoop体系分别开发出Hive、Spark、MR等插件。用户在界面新建各种作业类型，在执行时自动根据作业的类型寻找相应的插件来运行作业。</p></li><li><p>代码校验<br>对于常见的SQL任务类型，SQL检查器会做好严格的管控，做到事前发现问题。</p></li><li><p>多环境级联<br>通过环境级联的方式灵活支持企业的各类环境需求，方便对资源、权限进行控制和隔离。每个环境有独立的Hive数据库、Yarn调度队列，甚至不同的Hadoop集群。常见的环境如下：</p></li></ol><ul><li>单一环境：只有一个生产环境，内部管理简单。</li><li>经典环境：开发环境中存放脱敏数据、供开发测试使用，上生产环境走发布流程，用于真实数据生产。<br>任务、资源和函数必须在开发环境下进行新建、修改或删除，再经过提交、创建发布包、同意发布三个操作后，才能同步到生产环境。</li><li>复杂环境：企业有外部人员和内部人员，会给外部人员提供一个脱敏管控的环境，外部人员开发完的数据模型经过测试后发布到内部开发环境。</li></ul><ol start="6"><li><p>推荐依赖<br>随着业务的不断深入，数据开发人员需要开发的作业会不断累加。既能保证准确找到需要定位的上游作业，又能保证不会形成环路。<br><img src="%E4%BE%9D%E8%B5%96%E6%8E%A8%E8%8D%90.png" alt><br>获取推荐依赖的核心原理在于上下游作业输入和输出的表级血缘依赖图；<br>通过血缘分析当前作业的输入和输出，找到合适的上游作业；<br>对合适的作业进行环路检测，剔除存在闭环的作业；<br>返回合适的节点列表。</p></li><li><p>数据权限<br>企业内部计算引擎多样化，数据权限管理面临如下问题：</p></li></ol><ul><li>部分引擎拥有独立的权限管理系统（例如Oracle、HANA、LibrA），导致权限申请需要到每一种引擎上单独操作，让使用变得复杂。</li><li>同一种计算引擎，不同厂商的权限系统有多种，例如Hadoop自身无数据权限系统，由不同厂商各自去实现，目前主要有两种策略：<br>RBAC（Role-Based Access Control）：如Cloudera用的是Sentry，华为的FI也是类似的机制<br>PBAC（Policy-Based Access Control）：如Hortonworks用的Ranger</li><li>数据权限是由大数据集群或数据库运维人员管理的，开发人员无法直接操作或者接触，所有的权限申请都需要运维人员开通，造成运维人员负担过重。在实际开发中，一般需要运维人员把整个库的权限授权给某个开发负责人，然后库里面的表、字段、函数的权限管理由开发负责人负责就行。<br>数据权限管理中心提供界面化操作，数据申请方直接在页面上进行各种权限的申请，数据管理方在界面上审核权限，执行同意或拒绝操作。同时，所有权限的申请、审批都会有记录，便于进行权限审计。在统一数据权限服务中，会对接底层的各种权限管理系统，例如Sentry、Ranger、Oracle，同时对数据权限管理中心提供服务，执行权限的申请、授权、撤销等操作。</li></ul><h4 id="实时开发"><a href="#实时开发" class="headerlink" title="实时开发"></a>实时开发</h4><ol><li>元数据管理</li><li>SQL驱动</li><li>组件化开发</li></ol><h3 id="智能运维"><a href="#智能运维" class="headerlink" title="智能运维"></a>智能运维</h3><p>任务的管理、代码发布、运维、监控、告警等一系列集成工具，方便使用，提升效率。重跑、重跑下游、补数据。</p><h3 id="数据体系"><a href="#数据体系" class="headerlink" title="数据体系"></a>数据体系</h3><p>有了数据汇聚、数据开发模块，中台已经具备传统数据仓库（后面简称：数仓）平台的基本能力，可以做数据的汇聚以及各种数据开发，就可以建立企业的数据体系。之前说数据体系是中台的血肉，开发、管理、使用的都是数据。</p><p>中台数据体系应具备以下特征：</p><ul><li>覆盖全域数据：数据集中建设、覆盖所有业务过程数据，业务中台在数据体系中总能找到需要的数据。</li><li>结构层次清晰：纵向的数据分层、横向主题域、业务过程划分，让整个层次结构清晰易理解。</li><li>数据准确一致：定义一致性指标，统一命名、统一业务含义、统一计算口径，并有专业团队负责建模，保证数据的准确一致。</li><li>性能提升：统一的规划设计，选用合理的数据模型，清晰的定义并统一规范，并且考虑使用场景，使整体性能更好。</li><li>降低成本：数据体系的建设使得数据能被业务共享，这避免了大量烟囱式的重复建设，节约了计算、存储和人力成本。</li><li>方便易用：易用的总体原则是越往后越能方便地直接使用数据，把一些复杂的处理尽可能前置，必要时做适当的冗余处理。</li></ul><p>不同行业的数据体系建设：</p><ul><li><p>地产行业<br><img src="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%9C%B0%E4%BA%A7%E8%A1%8C%E4%B8%9A%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB.png" alt></p></li><li><p>证券行业<br><img src="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E8%AF%81%E5%88%B8%E8%A1%8C%E4%B8%9A%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB.png" alt></p></li><li><p>零售行业<br><img src="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E9%9B%B6%E5%94%AE%E8%A1%8C%E4%B8%9A%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB.png" alt></p></li><li><p>制造行业<br><img src="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E5%88%B6%E9%80%A0%E8%A1%8C%E4%B8%9A%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB.png" alt></p></li><li><p>传媒行业<br><img src="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E4%BC%A0%E5%AA%92%E8%A1%8C%E4%B8%9A%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB.png" alt></p></li><li><p>检务行业<br><img src="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%A3%80%E5%8A%A1%E8%A1%8C%E4%B8%9A%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB.png" alt></p></li></ul><ol><li>贴源数据层ODS<br>对各业务系统数据进行采集、汇聚，尽可能保留原始业务流程数据，与业务系统基本保持一致，仅做简单整合、非结构化数据结构化处理或者增加标识数据日期描述信息，不做深度清洗加工。<br>表名：ODS_系统简称_业务系统表名<br>字段名：与业务系统字段名保持一致，字段类型也尽可能保持一致<br>对于数据量比较大的业务表，采用增量同步的方式，则要同时建立增量表和全量表，增量表命名加后缀：ODS_系统简称_业务系统表名_delta。<br>对于日志、文件等半结构数据，不仅要存储原始数据，还要存储结构化之后的数据。</li></ol><p>使用DataX同步数据步骤：<br>1）确定业务系统源表与贴源数据层目标表<br>2）配置数据字段映射关系，目标表可能会增加采集日期、分区、原系统标识等必要信息，业务相关内容不做转换<br>3）如果是增量同步或着有条件的同步部分数据，则配置数据同步条件<br>4）清理目标表对应数据<br>5）启动同步任务，往贴源数据层目标表导入数据<br>6）验证任务是否可以正确运行，并且采集到准确数据<br>7）发布采集任务，加入生产调度，并配置相关限速、容错、质量监控、告警机制</p><ol start="2"><li>统一数仓层DW</li></ol><ul><li>明细数据层DWD</li><li>汇总数据层DWS<br>与传统数据仓库功能基本一致，对全历史业务过程数据进行建模存储。对来源于业务系统的数据进行重新组织。业务系统是按照业务流程方便操作的方式来组织数据的，而统一数仓层从业务易理解的视角来重新组织，定义一致的指标、维度，各业务板块、业务域按照统一规范独立建设，从而形成统一规范的标准业务数据体系。</li></ul><ol start="3"><li><p>标签数据层TDM<br>面向对象建模，对跨业务板块、跨数据域的特定对象数据进行整合，通过IDMapping把各个业务板块、各个业务过程中的同一对象的数据打通，形成对象的全域标签体系，方便深度分析、挖掘、应用。<br><img src="%E5%AE%A2%E6%88%B7%E6%A0%87%E7%AD%BE%E4%BD%93%E7%B3%BB.png" alt></p></li><li><p>应用数据层ADS<br>按照业务的需要从统一数仓层、标签数据层抽取数据，并面向业务的特殊需要加工业务特定数据，以满足业务及性能需求，向特定应用组装应用数据。</p></li></ol><h3 id="数据资产管理"><a href="#数据资产管理" class="headerlink" title="数据资产管理"></a>数据资产管理</h3><p>数据资产管理包括对数据资产目录、元数据、数据质量、数据血缘、数据生命周期等进行管理和展示，以一种更直观的方式展现企业的数据资产，提升企业的数据意识。<br>数据资产对上支持以价值挖掘和业务赋能为导向的数据应用开发，对下依托大数据平台实现数据全生命周期的管理，并对企业数据资产的价值、质量进行评估，促进企业数据资产不断自我完善，持续向业务输出动力。</p><h4 id="数据治理"><a href="#数据治理" class="headerlink" title="数据治理"></a>数据治理</h4><p>传统的数据治理通常包含数据标准管理、元数据管理、数据质量管理、数据安全管理、数据生命周期管理等内容。</p><h3 id="数据服务体系"><a href="#数据服务体系" class="headerlink" title="数据服务体系"></a>数据服务体系</h3><p>前面利用数据汇聚、数据开发建设企业的数据资产，利用数据管理展现企业的数据资产，但是并没有发挥数据的价值。数据服务体系就是把数据变为一种服务能力，通过数据服务让数据参与到业务，<br>快速开发企业的业务中台等。</p><h4 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h4><p>输入特定的查询条件，返回该条件下的数据，以API形式供上层应用调用。<br>1）支持配置查询标识，底层数据组织一般会对该标识建立索引，以加快查询速度<br>2）支持配置过滤项<br>3）支持查询结果配置，包括数据排序规则和分页规则。</p><h4 id="分析服务"><a href="#分析服务" class="headerlink" title="分析服务"></a>分析服务</h4><p>借助分析组件高效的大数据分析能力，对数据进行关联分析，分析结果通过API形式供上层应用调用。<br>1）支持多源数据接入：企业的数据经过清洗加工转换成数据资产后，最终通过服务作用于业务系统，基于企业异构存储的现状，要求分析服务能够支持与Hive、ES、Greenplum、MySQL、Oracle、本地文件等多种数据源进行连接。<br>2）高性能即席查询：随着企业数据爆发式增长，传统的数据分析工具遇到分析能力的瓶颈，也就是对大数据量的分析越来越乏力。因此，这就要求分析服务内置高速计算引擎，以对数据进行高性能的即席计算，实现亿级数据毫秒级（至多秒级）分析和计算，减少用户等待时间。<br>3）多维数据分析<br>分析服务除了支持常规的数据分析、上卷下钻、切片切块之外，还应该支持多维的数据分析以及深层次的数据挖掘，发现数据背后的关联关系。<br>4）灵活对接业务系统</p><h4 id="推荐服务"><a href="#推荐服务" class="headerlink" title="推荐服务"></a>推荐服务</h4><p>按约定的格式提供历史日志行为数据和实时访问数据，推荐模型就会生成相应的推荐API，从而为上层应用提供推荐服务。<br>推荐服务即所谓的千人千面，对不同的人对物的行为进行数据挖掘，构建每个人与物之间的关系程度，来推荐人、物以满足用户的兴趣爱好，以提升用户对业务的粘性。每个人打开手机淘宝看到的内容都不一样，这就是一种基于人的兴趣爱好的推荐服务能力。<br>1）支持不同行业的推荐：不同行业背后的推荐逻辑是有区别的<br>2）支持不同场景的推荐：以内容资讯为例，在用户冷启动场景下，应该推荐哪些资讯？在用户已有浏览行为的场景下，又该为其推荐哪些资讯？<br>3）支持推荐效果优化：从导入的原始数据开始，经过推荐组件生成推荐数据，再根据用户的浏览数据不断修正推荐模型，从而使推荐效果不断优化</p><h4 id="圈人服务"><a href="#圈人服务" class="headerlink" title="圈人服务"></a>圈人服务</h4><p>从全量用户数据中，基于标签组合筛选符合指定特征条件的人群，并通过API形式供上层应用调用。<br>1）支持人群圈选：通过SQL代码或标签取值组合等多种方式，实现人员查找，帮用户找到对的人群<br>2）支持人群计量：营销部门或者广告公司使用圈人服务圈选出目标人群后，往往还要考虑人群量是否符合预期，因为预算有限，不可能不计成本的对人群进行营销。<br>3）支持多渠道对接：将人群名单导出到相应的下游系统。最简单的名单导出方式是先下载文件，再由业务人员导入相应的业务系统中。或者直接对接到短信系统、微信投放接口、营销活动系统等。</p><h2 id="离线平台"><a href="#离线平台" class="headerlink" title="离线平台"></a>离线平台</h2><h3 id="苏宁"><a href="#苏宁" class="headerlink" title="苏宁"></a>苏宁</h3><p><a href="https://www.infoq.cn/article/suning-big-data" target="_blank" rel="noopener">苏宁大数据离线任务开发调度平台实践</a><br><a href="https://www.infoq.cn/article/xTvBg1_9iUL0z5Pjf0Os" target="_blank" rel="noopener">苏宁大数据离线任务开发调度平台实践：任务调度模块架构设计</a></p><p>苏宁离线平台产品功能图：<br><img src="%E8%8B%8F%E5%AE%81%E7%A6%BB%E7%BA%BF%E5%B9%B3%E5%8F%B0%E4%BA%A7%E5%93%81%E5%8A%9F%E8%83%BD%E5%9B%BE.png" alt></p><p>苏宁调度模块功能图：<br><img src="%E8%8B%8F%E5%AE%81%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E5%9B%BE.png" alt></p><p>苏宁离线平台整体架构图：<br><img src="%E8%8B%8F%E5%AE%81%E7%A6%BB%E7%BA%BF%E5%B9%B3%E5%8F%B0%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt></p><p>跨任务流依赖的实现：<br>FTP事件机制，即在 FTP 服务器上建立标识文件，一个事件对应一个标识文件地址，当 FTP 服务器上的标识文件生成的时候，我们认为业务系统已经完成作业，需要触发平台任务执行。</p><p>“华佗”平台，实施任务诊断：<br><img src="%E8%8B%8F%E5%AE%81%E5%8D%8E%E4%BD%97%E5%B9%B3%E5%8F%B0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E8%AF%8A%E6%96%AD.png" alt></p><p>立即触发的任务，放入DelayQueue的队列头部<br>周期调度的任务，使用Quartz<br>依赖触发的任务，使用zk，各个子节点监听自己的父节点，所有父节点执行完毕则可触发执行</p><h2 id="实时平台"><a href="#实时平台" class="headerlink" title="实时平台"></a>实时平台</h2><h3 id="美团点评"><a href="#美团点评" class="headerlink" title="美团点评"></a>美团点评</h3><p><img src="%E7%9B%91%E6%8E%A7%E8%AE%BE%E8%AE%A1_%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84.png" alt></p><p>使用了Grafana，可以内嵌到自己的平台。</p><h3 id="bilibili"><a href="#bilibili" class="headerlink" title="bilibili"></a>bilibili</h3><p> SQL化编程</p><p> DAG拖拽编程</p><p> 一体化托管运维</p><p>实时平台由实时传输和实时计算两部分组成，平台底层统一管理元数据、血缘、权限以及作业运维等。实时传输主要负责将数据传入到大数据体系中。实时计算基于 BSQL 提供各种应用场景支持。</p><p>如下图所示，实时传输有 APP 日志、数据库 Binlog、服务端日志或系统日志。bilibili 内部的 Lancer 系统解决数据落地到 Kafka 或 HDFS。计算体系主要围绕 Saber 构建一套 BSQL，底层基于 YARN 进行调度管理。</p><p>上层核心基于 Flink 构建运行池。再向上一层满足多种维表场景，包括 MySQL、Redis、HBase。状态（State）部分在 RocksDB 基础上，还扩展了 MapDB、Redis。Flink 需要 IO 密集是很麻烦的问题，因为 Flink 的资源调度体系内有内存和 CPU，但 IO 单位未做统一管理。当某一个作业对 IO 有强烈的需求时，需要分配很多以 CPU 或内存为单位的资源，且未必能够很好的满足 IO 的扩展。所以本质上 bilibili 现阶段是将 IO 密集的资源的 State 转移到 Redis 上做缓解。数据经过 BSQL 计算完成之后传输到实时数仓，如 Kafka、HBase、ES 或 MySQL、TiDB。最终到 AI 或 BI、报表以及日志中心。<br><img src="%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%9B%BE_bilibili.png" alt></p><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul><li>AI工程方向，解决了广告、搜索、推荐的流式Joiner和维表Joiner</li><li>实时计算的特征支持，支持 Player 以及 CDN 的质量监控。包括直播、PCU、卡顿率、CDN 质量等；</li><li>用户增长，即如何借助实时计算进行渠道分析、调整渠道投放效果；</li><li>实时 ETL，包括 Boss 实时播报、实时大屏、看板等。</li></ul><h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><p>目前网易流计算覆盖了绝大多数场景，包括广告、电商大屏、ETL、数据分析、推荐、风控、搜索、直播等。</p><h4 id="事件管理"><a href="#事件管理" class="headerlink" title="事件管理"></a>事件管理</h4><p>对于分布式平台的任务操作而言，当前任务启动过程中只允许一个人操作，而不允许两个人同时操作，这就需要以下几个模块来共同配合：</p><ul><li>Server：事件执行的发起者，接受事件的请求，进行数据校验，拼装，将事件发送给 Kernel 执行。</li><li>Kernel：事件具体逻辑的执行者，根据请求向集群发送指令(Shell 脚本方式)。</li><li>Admin：事件执行结果的确认者，根据事件类型，获取事件的最终结果，保证结果的正确性。</li></ul><p><img src="%E4%BA%8B%E4%BB%B6%E7%AE%A1%E7%90%86_%E7%BD%91%E6%98%93.png" alt></p><p>以启动场景为例：</p><p>首先，Server 会接收到来自用户的启动请求，之后会创建一个分布式锁，Admin 会监控这个锁。</p><p>然后， Server 向 Kernel 提交任务，提交之后会立即返回，返回之后就会立即更新数据库中的状态，将状态更新为启动中，这样在页面上用户就能够看到任务是启动中的状态了。</p><p>接下来，Server 就会等待内核的 Shell 脚本的执行结果，如果 Shell 脚本执行成功了，就会去写 Zookeeper，写完 Zookeeper 之后 Admin 模块就会马上检测到 Zookeeper 节点有状态发生了修改，Admin 会立即去获取 YARN 上的任务状态，如果获取到任务状态是运行中，就将数据库的任务状态更新为运行中，这会在前端看到任务就已经是运行状态了。</p><p>最后一步是 Admin 更为完数据库之后，会释放掉 Zookeeper 上的锁，其他人这时候就可以操作这个任务了。</p><p>Server、Kernel 和 Admin 这三个模块都是不可靠的，那么如何保证其稳定和高可用呢？Server 可以通过部署多个，水平扩展来实现，Kernel 则会由 Server 来进行监听，当发现 Kernel 挂了，可以由 Server 重新拉起或者重新创建。而 Admin 的高可用则是通过热备来实现的，如果主 Admin 挂掉了，可以马上迁移到备 Admin，备 Admin 可以迅速将元数据以及任务信息全部加载进来接替工作，进而实现高可用。</p><h4 id="平台任务状态管理"><a href="#平台任务状态管理" class="headerlink" title="平台任务状态管理"></a>平台任务状态管理</h4><p>平台的任务状态主要由 Server 和 Admin 来控制。Server 主要控制初始状态的执行，Admin 则主要负责控制所有与 YARN 相关的状态交互。</p><p><img src="%E5%B9%B3%E5%8F%B0%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E5%9B%BE_%E7%BD%91%E6%98%93.png" alt></p><h4 id="任务调试"><a href="#任务调试" class="headerlink" title="任务调试"></a>任务调试</h4><p>SQL 类型的任务支持调试功能，用户可以根据不同的 source 表和 dim 表，上传不同的 csv 文件作为输入数据，进行调试。调试执行由指定的 kernel 来完成，sloth-server 负责组装请求，调用 kernel，返回结果，搜集日志。</p><p><img src="%E4%BB%BB%E5%8A%A1%E8%B0%83%E8%AF%95_%E7%BD%91%E6%98%93.png" alt></p><h4 id="日志检索"><a href="#日志检索" class="headerlink" title="日志检索"></a>日志检索</h4><p>在 YARN 集群的每个节点上面部署 Filebeat，通过 Filebeat 将节点上面的任务日志写入到 Kafka 消息队列中，然后通过 Logstash 进行解析处理，之后写入 ES 集群中。主要用于两个用途，一个是通过界面 Kibana 来提供给开发和运维人员使用，另外一个就是将运行时状态的任务日志直接在界面上展示供用户进行搜索和查看。<br><img src="%E6%97%A5%E5%BF%97%E6%A3%80%E7%B4%A2_%E7%BD%91%E6%98%93.png" alt></p><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>在监控方面，使用的是 influxdb metric report 组件对于指标进行监控。时序数据库使用的是网易自研的 ntsdb 时序数据库，其能够支持动态扩展和高可用等功能。监控指标的使用方式有两种：<br>一种是通过 Grafana 的界面来查看指标；<br>另外一种是报警模块会从Ntsdb中获取相关指标数据并进行监控报警。</p><p><img src="%E7%9B%91%E6%8E%A7_%E7%BD%91%E6%98%93.png" alt></p><h4 id="报警"><a href="#报警" class="headerlink" title="报警"></a>报警</h4><p>Sloth 流计算平台支持常见的任务失败，数据滞留延迟，failover 报警，也支持用户自定义规则报警，包括对于输入 QPS、输出 QPS，户自定义延迟的监控等。以输入 QPS 为例，可以设置当连续几个周期内 QPS 低于某一值时就触发报警。此外，报警方式也支持多样化的工具，比如各种网易内部的聊天工具、邮件、电话以及短信等，对于任务调试阶段，为了避免被骚扰，可以设置任务报警抑制时间间隔。</p><p><img src="%E6%8A%A5%E8%AD%A6_%E7%BD%91%E6%98%93.png" alt></p><h4 id="实时数仓"><a href="#实时数仓" class="headerlink" title="实时数仓"></a>实时数仓</h4><p>目前网易很多产品已经开始实时数仓的建设了，但仍旧处于持续完善过程中。实时数仓的建设和离线数仓大致相同，只不过实时数仓是经过实时计算平台进行处理的。大致的过程就是首先收集日志、埋点数据等，将其写入到 Kafka 里面，经过实时计算平台进行处理，将 ODS 层中的明细数据抽取出来，在进行汇总以及维度关联等操作，将结果写入到 Redis，Kudu 等，再通过数据服务提供给前端的业务使用。x</p><p><img src="%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93_%E7%BD%91%E6%98%93.png" alt></p><h4 id="电商应用-数据分析"><a href="#电商应用-数据分析" class="headerlink" title="电商应用-数据分析"></a>电商应用-数据分析</h4><p>实时活动分析、首页资源分析、流量漏斗以及实时毛利计算等。</p><h4 id="电商应用-搜索推荐"><a href="#电商应用-搜索推荐" class="headerlink" title="电商应用-搜索推荐"></a>电商应用-搜索推荐</h4><p>电商的搜索推荐场景则主要包括用户实时足迹、用户实时特征、商品实时特征、实时 CTR CVR 样本组建、首页 A 区轮播、B 区活动精选等 UV、PV 实时统计等。<br>网络营销中的常见名词解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CPC (Cost Per Click): 按点击计费</span><br><span class="line">CPA (Cost Per Action): 按成果数计费</span><br><span class="line">CPM (Cost Per Mille): 按千次展现计费</span><br><span class="line">CVR (Click Value Rate): 转化率，衡量CPA广告效果的指标</span><br><span class="line">CTR (Click Through Rate): 点击率</span><br><span class="line">PV (Page View): 流量</span><br><span class="line">ADPV (Advertisement Page View): 载有广告的pageview流量ADimp (ADimpression): 单个广告的展示次数</span><br><span class="line">PV单价: 每PV的收入，衡量页面流量变现能力的指标</span><br></pre></td></tr></table></figure><h2 id="离线数仓与实时数仓"><a href="#离线数仓与实时数仓" class="headerlink" title="离线数仓与实时数仓"></a>离线数仓与实时数仓</h2><h3 id="从0建设离线数仓"><a href="#从0建设离线数仓" class="headerlink" title="从0建设离线数仓"></a>从0建设离线数仓</h3><h4 id="建设数仓"><a href="#建设数仓" class="headerlink" title="建设数仓"></a>建设数仓</h4><p>数据仓库定义：在企业管理和决策中面向主题的、集成的、与时间相关的、不可修改的数据集合。<br>数据仓库目标：数据资产、决策信息。</p><ul><li>ETL过程：打通你的任督二脉（离线+实时），让数据在整个环节中流通起来</li><li>数据分层：一套低耦合、高内聚的层级，是十分重要的，总不想业务、数据等一变化，数仓像又投胎了一次</li><li>数据集成：多业务场景下，打破数据信息壁垒，避免数据歧义，统一数据服务</li><li>规范化：良好的流程化、规范化设计，易维护、高扩展</li><li>监控与辅助：质量监控、调度管理、元数据管理、信息安全管理</li><li>走向服务：对外api服务/自助查询平台/OLAP分析平台</li></ul><h4 id="ETL"><a href="#ETL" class="headerlink" title="ETL"></a>ETL</h4><p>业务数据往往涉及多种数据源，数据存储也常常会有多种选择。文本数据、日志数据、RMDB、Nosql等。则要求etl工具能够覆盖这些业务场景。<br>工具有datax/sqoop/kettle/informatica等等。<br>ETL一般为最开始的部分，凌晨之后的时间点。a：避免集中式的对某个jdbc海量同步，影响业务(部分从库可能提供查询服务)、b：明确调度的时间，应尽可能的在某个时间段内完成(不能仅依靠调度，实现任务流的串行；为后期的大作业空间，占用等待的系统资源)</p><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p><img src="%E6%95%B0%E4%BB%93%E5%B8%B8%E7%94%A8%E5%88%86%E5%B1%82.png" alt></p><ol><li><p>Stage缓冲层<br>事务性数据，每日增量方式进行数据同步。需要注意数据同步时的边界问题，避免脏数据。<br>对于非事务性数据，一般通过快照/全量更新。不对外开放数据查询。</p></li><li><p>ods层<br>一般场景下，我们认为该层数据与线上保持一致。实际处理过程中，为了处理时间维度上的数据变化，会记录数据的变化轨迹。对于该部分数据，应该有选择的实施，避免业务处理过程变得复杂和问题发生后难以回溯。</p></li><li><p>dim/dw层 (模型层)<br>dim：维度层<br>dw：主题事实及业务宽表<br>在ods基础上，设计一个宽表/模型层，通过维度建模的方式，实现维度数据与事实数据的分离（星型模型）。</p></li><li><p>da层（应用层）<br>面向不同的应用，聚合类的数据层。该层对于dim/dw层的使用，是对模型层的一个检视维度。</p></li></ol><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><ol><li>脚本格式规范：脚本头部注释编码规范、注释规范、sql规范参考goole规范</li><li>文件/表命名规范：一个文件中，只应该有一张表，其余只能是临时表；表名称应与文件名相同</li><li>字段命名规范：去除多词同义，和同词多义的问题。尤其是在模型层（一般也叫做一致性维度）</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>离线数仓主要基于sqoop、datax、hive等技术来构建 T+1 的离线数据，通过定时任务每天垃取增量数据导入到hive表中，然后创建各个业务相关的主题，对外提供T+1的数据查询接口。<br>实时数仓主要是基于数据采集工具，如canal等原始数据写入到kafka这样的数据通道中，最后一般都是写入到类似于HBase这样的OLAP存储系统中。对外提供分钟级别，甚至秒级别的查询方案。</p><table><thead><tr><th>数仓类型</th><th>准确性</th><th>实时性</th><th>稳定性</th></tr></thead><tbody><tr><td>离线数仓</td><td>准确度高</td><td>时延一般在一天</td><td>稳定性好，方便重算</td></tr><tr><td>实时数仓</td><td>准确度低，数据延迟、数据乱序造成数据准确度低</td><td>分钟级延迟</td><td>稳定性差，需要考虑数据回溯处理</td></tr></tbody></table><p><img src="%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%A8%A1%E5%9E%8B.png" alt></p><p>数据仓库的建设主要包括数据的采集、数据的处理、数据归档、数据应用四个方面。<br>当前主要的应用场景包括报表展示、即席查询、BI展示、数据分析、数据挖掘、模型训练等方面。<br>数据仓库的建设是面向主题的、集成性的、不可更新的、时许变化的。</p><p>实时数仓的实施关键点：</p><ol><li>端到端数据延迟、数据流量的监控</li><li>故障的快速恢复能力</li><li>数据的回溯处理，系统支持消费指定时间段内的数据</li><li>实时数据从实时数仓中查询，T+1数据借助离线通道修正</li><li>数据地图、数据血缘关系的梳理</li><li>业务数据质量的实时监控，初期可以根据规则的方式来识别质量状况</li></ol><p>其实，你需要的不是实时数仓，需要的是一款合适且强大的OLAP数据库。<br>在实时数仓的建设中，OLAP数据库的选型直接制约实时数仓的可用性和功能性。</p><p>原始层<br>明细层<br>汇总层<br>应用层</p><p>ods：原始数据层，事实数据，存储在kafka中<br>dwd：数据明细层，可以做一些join等加宽处理，可以存储在kafka和redis中<br>dim：维度数据，如存储在HBase中的数据<br>dm：MySQL -&gt; 汇总指标模型；Greenplum -&gt; 明细，多维分析关联；HBase -&gt; 汇总指标(大量并发)；Redis -&gt; 汇总、大列表TopN</p><h2 id="数据中台解决方案"><a href="#数据中台解决方案" class="headerlink" title="数据中台解决方案"></a>数据中台解决方案</h2><h3 id="零售行业"><a href="#零售行业" class="headerlink" title="零售行业"></a>零售行业</h3><p><img src="%E9%9B%B6%E5%94%AE%E8%A1%8C%E4%B8%9A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt></p><pre><code>RPS (Revenue Per Search): 每搜索产生的收入，衡量搜索结果变现能力指标</code></pre><p>　  ROI： 投资回报率（ROI）是指通过投资而应返回的价值，它涵盖了企业的获利目标。利润和投入的经营所必备的财产相关，因为管理人员必须通过投资和现有财产获得利润。又称会计收益率、投资利润率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将总结下数据中台的相关理论知识。&lt;br&gt;Flink平台化需要改进的点等等。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;《数据中台》&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="http://yoursite.com/2020/03/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/23/数据结构和算法/</id>
    <published>2020-03-22T19:15:50.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍常见的数据结构，算法思想，排序算法、树等。</p><a id="more"></a><h2 id="经典机试题-剑指offer"><a href="#经典机试题-剑指offer" class="headerlink" title="经典机试题(剑指offer)"></a>经典机试题(剑指offer)</h2><h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><ul><li><p>题目描述<br>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></li><li><p>思路<br>通过分析可以很简单的找出一个规律，二维数组的最左下角的的点，该点的所在列上边的点都是减少的，该点所在行右边的点都是增加的。因此，我们以该点作为切入点，如果目标数比左下角的数大，则往右边移动；如果目标数比左下角的数小，则往上边移动；之后以此类推，如果匹配到目标数，则返回true；如果当移动到最右上角的点仍然没有匹配到目标数，则返回false。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = array.length;</span><br><span class="line">        <span class="keyword">int</span> cols = array[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row;</span><br><span class="line">        <span class="keyword">int</span> col;</span><br><span class="line">        <span class="keyword">for</span>(row = rows -<span class="number">1</span>,col=<span class="number">0</span>; row&gt;=<span class="number">0</span> &amp;&amp; col&lt;=cols-<span class="number">1</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == array[row][col])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[row][col])&#123;</span><br><span class="line">                row--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; array[row][col])&#123;</span><br><span class="line">                col++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.png" alt></p><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><ul><li><p>题目描述<br>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">' '</span>)&#123;</span><br><span class="line">                str.replace(i,i+<span class="number">1</span>,<span class="string">"%20"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newStr = str.toString();</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.png" alt></p><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><ul><li><p>题目描述<br>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.png" alt></p><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><ul><li><p>题目描述<br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></li><li><p>思路<br>通过分析前序遍历和中序遍历的规律，前序遍历的第一个节点就是二叉树的根节点，中序遍历中，位于根节点前面的所有节点都位于左子树上，位于根节点后面的所有节点都位于右子树上面。通过这个规律，我们可以使用递归方法来重建二叉树。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(pre,in,<span class="number">0</span>,pre.length-<span class="number">1</span>,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span>[] in,<span class="keyword">int</span> preStart,<span class="keyword">int</span> preEnd,<span class="keyword">int</span> inStart,<span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[preStart]);</span><br><span class="line">        <span class="keyword">int</span> rootIn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; rootIn&lt;in.length; rootIn++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[rootIn] == root.val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">int</span> leftLength = rootIn - inStart;</span><br><span class="line">        <span class="keyword">int</span> rightLength = inEnd - rootIn;</span><br><span class="line">        <span class="keyword">if</span>(leftLength &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            root.left = buildTree(pre, in, preStart+<span class="number">1</span>, preStart+leftLength, inStart, rootIn -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightLength &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            root.right = buildTree(pre, in, preStart+leftLength+<span class="number">1</span>, preEnd, rootIn+<span class="number">1</span>, inEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><ul><li><p>题目描述<br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></li><li><p>思路<br>入队：将元素进栈A<br>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.png" alt></p><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><ul><li><p>题目描述<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></li><li><p>思路<br>如果是完全正序的{1,2,3,4,5}，那么遍历到倒数第二个，应该能确定这个数组没有被旋转过，可以确定数组中的第一个为最小值。<br>如果是经过旋转的数组{3,4,5,1,2}，那么发现乱序的第一个值就应该是最小值。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i+<span class="number">1</span>]&lt;array[i])&#123;</span><br><span class="line">                <span class="comment">// 数组经过旋转之后</span></span><br><span class="line">                <span class="keyword">return</span> array[i+<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == array.length -<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="comment">// 完全正序递增的数组</span></span><br><span class="line">                    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.png" alt></p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><ul><li><p>题目描述<br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p></li><li><p>思路<br>这里可以使用递归的方法实现，但是递归的方式的时间复杂是输入规模的指数级别，不建议使用，因此这里采用迭代的方法实现。</p></li></ul><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> second = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">          result = first + second;</span><br><span class="line">          first = second;</span><br><span class="line">          second = result;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.png" alt></p><h3 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h3><ul><li><p>题目描述<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></li><li><p>思路<br>（1）可以考虑，小青蛙每一步跳跃只有两种选择：一是再跳一级阶梯到达第 i 级阶梯，此时小青蛙处于第 i-1 级阶梯；或者再跳两级阶梯到达第 i 级阶梯，此时小青蛙处于第 i-2 级阶梯。</p></li></ul><p>（2）于是，i级阶梯的跳法总和f(i)依赖于前 i-1 级阶梯的跳法总数f(i-1)和前 i-2 级阶梯的跳法总数f(i-2)。因为只有两种可能性，所以，f(i)=f(i-1)+f(i-2);</p><p>（3）通过上面的分析，我们可以很清晰地看到，这其实就是一个Fibonacci数列。</p><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * f(i)=f(i-1)+f(i-2)</span></span><br><span class="line"><span class="comment"> * 其实就是一个斐波那契数列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(target&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> first=<span class="number">0</span>,second=<span class="number">1</span>,result=<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">                 first=second;</span><br><span class="line">                 second=result;</span><br><span class="line">                 result=first+second;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E8%B7%B3%E5%8F%B0%E9%98%B6.png" alt></p><h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><ul><li><p>题目描述<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></li><li><p>思路<br>用Fib(n)表示跳上n阶台阶的跳法数。如果按照定义，Fib(0)肯定需要为0，否则没有意义。但是我们设定Fib(0) = 1；n = 0是特殊情况，通过下面的分析就会知道，强制令Fib(0) = 1很有好处。ps. Fib(0)等于几都不影响我们解题，但是会影响我们下面的分析理解。</p></li></ul><p>当n = 1 时， 只有一种跳法，即1阶跳：Fib(1) = 1;</p><p>当n = 2 时， 有两种跳的方式，一阶跳和二阶跳：Fib(2)  = 2;</p><p>到这里为止，和普通跳台阶是一样的。</p><p>当n = 3 时，有三种跳的方式，第一次跳出一阶后，对应Fib(3-1)种跳法； 第一次跳出二阶后，对应Fib(3-2)种跳法；第一次跳出三阶后，只有这一种跳法。Fib(3) = Fib(2) + Fib(1)+ 1 = Fib(2) + Fib(1) + Fib(0) = 4;</p><p>当n = 4时，有四种方式：第一次跳出一阶，对应Fib(4-1)种跳法；第一次跳出二阶，对应Fib(4-2)种跳法；第一次跳出三阶，对应Fib(4-3)种跳法；第一次跳出四阶，只有这一种跳法。所以，Fib(4) = Fib(4-1) + Fib(4-2) + Fib(4-3) + 1 = Fib(4-1) + Fib(4-2) + Fib(4-3) + Fib(4-4) 种跳法。</p><p>当n = n 时，共有n种跳的方式，第一次跳出一阶后，后面还有Fib(n-1)中跳法； 第一次跳出二阶后，后面还有Fib(n-2)中跳法……………………..第一次跳出n阶后，后面还有 Fib(n-n)中跳法。Fib(n) = Fib(n-1)+Fib(n-2)+Fib(n-3)+……….+Fib(n-n) = Fib(0)+Fib(1)+Fib(2)+…….+Fib(n-1)。</p><p>通过上述分析，我们就得到了通项公式：</p><pre><code>Fib(n) =  Fib(0)+Fib(1)+Fib(2)+.......+ Fib(n-2) + Fib(n-1)</code></pre><p>因此，有 Fib(n-1)=Fib(0)+Fib(1)+Fib(2)+…….+Fib(n-2)</p><p>两式相减得：Fib(n)-Fib(n-1) = Fib(n-1)         =====》  <code>Fib(n) = 2*Fib(n-1)     n &gt;= 3</code></p><p>这就是我们需要的递推公式：<code>Fib(n) = 2*Fib(n-1)     n &gt;= 3</code></p><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fib(1) = 1;</span></span><br><span class="line"><span class="comment"> * Fib(2) = 2;</span></span><br><span class="line"><span class="comment"> * 递推公式：Fib(n) = 2*Fib(n-1)     n &gt;= 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Integer[] array = <span class="keyword">new</span> Integer[target+<span class="number">1</span>];</span><br><span class="line">            array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            array[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            array[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">3</span>; n &lt;=target; n++)&#123;</span><br><span class="line">                array[n] = <span class="number">2</span>*array[n-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> array[target];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6.png" alt></p><h3 id="矩阵覆盖"><a href="#矩阵覆盖" class="headerlink" title="矩阵覆盖"></a>矩阵覆盖</h3><ul><li><p>题目描述<br>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？<br>比如n=3时，<code>2*3</code>的矩形块有3种覆盖方法。</p></li><li><p>思路<br>f(n) = f(n-1) + f(n-2)</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>( target&lt;<span class="number">3</span> )&#123;</span><br><span class="line">             <span class="keyword">return</span> target;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">             <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">3</span>; n&lt;=target; n++)&#123;</span><br><span class="line">                 result = first + second;</span><br><span class="line">                 first = second;</span><br><span class="line">                 second = result;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96.png" alt></p><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><ul><li><p>题目描述<br>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p></li><li><p>思路<br>使用java内置的的toBinaryString方法来实现。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        String str = Integer.toBinaryString(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'1'</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.png" alt></p><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><ul><li><p>题目描述<br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;exponent;i++)&#123;</span><br><span class="line">                result *= base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(base == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"分母不能为0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;-exponent;j++)&#123;</span><br><span class="line">                result *= base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent&gt;<span class="number">0</span> ? result:<span class="number">1</span>/result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.png" alt></p><h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><ul><li><p>题目描述<br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></li><li><p>思路</p></li></ul><ol><li>类似冒泡排序的遍历方式，前面是偶数，后面是奇数，就交换位置</li><li>用空间换时间的做法，new一个数组，从头开始遍历，遇到偶数保存进新数组，并且删除原先的偶数，最后将偶数部分接在奇数部分之后。 </li><li>类似快排的思想，使用双指针，i从左到右寻找偶数，j从右到左寻找奇数，然后交换两个数。(但是第3种方法不能保证相对顺序)</li></ol><ul><li>代码示例1 - 冒泡排序思想<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;array.length-<span class="number">1</span>-i; j++)&#123;</span><br><span class="line">                <span class="comment">// 前面是偶数，后面是奇数，就交换位置</span></span><br><span class="line">                <span class="keyword">if</span>(array[j]%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; array[j+<span class="number">1</span>]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.png" alt></p><ul><li>代码示例2 - 快速排序思想<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> length = array.length;</span><br><span class="line">  <span class="keyword">if</span>(length==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> front=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = length-<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(front&lt;end)&#123;</span><br><span class="line">    <span class="comment">// 向后找偶数</span></span><br><span class="line">    <span class="keyword">while</span>(front&lt;length &amp;&amp; array[front]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      front++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向前找奇数</span></span><br><span class="line">    <span class="keyword">while</span>(end&gt;=<span class="number">0</span> &amp;&amp; array[end]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(front&lt;end)&#123;</span><br><span class="line">      <span class="comment">// 交换偶数和奇数</span></span><br><span class="line">      <span class="keyword">int</span> temp = array[front];</span><br><span class="line">      array[front] = array[end];</span><br><span class="line">      array[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><ul><li><p>题目描述<br>输入一个链表，输出该链表中倒数第k个结点。</p></li><li><p>思路<br>先遍历一遍链表，看链表有多少个节点。下一次直接遍历到count-k处即可。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ListNode node = head;</span><br><span class="line">         <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">             count ++;</span><br><span class="line">             node = node.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(count &lt; k)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         ListNode p = head;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count-k; i++)&#123;</span><br><span class="line">             p = p.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9.png" alt></p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><ul><li><p>题目描述<br>输入一个链表，反转链表后，输出新链表的表头。</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode pNode = head;</span><br><span class="line">        ListNode pPrev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(pNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode pNext = pNode.next;</span><br><span class="line">            <span class="keyword">if</span>(pNext==<span class="keyword">null</span>)&#123;</span><br><span class="line">                newHead = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode.next = pPrev;</span><br><span class="line">            pPrev = pNode;</span><br><span class="line">            pNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png" alt></p><h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><ul><li><p>题目描述<br>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></li><li><p>思路<br>比较两个链表的第一个节点，取出最小值的节点，接着再按照相同的方式重复比较剩余链表的节点。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode pMergeHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">            pMergeHead = list1;</span><br><span class="line">            pMergeHead.next = Merge(list1.next,list2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pMergeHead = list2;</span><br><span class="line">            pMergeHead.next = Merge(list2.next,list1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pMergeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.png" alt></p><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><ul><li><p>题目描述<br>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p></li><li><p>思路<br>这个题比较简单，利用递归的方式就可以判断B是不是A树的子结构。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (isSubTree(root1,root2) || HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果tree2已经遍历完了，说明可以完全匹配上</span></span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tree2还没有遍历完，但是tree1已经遍历完了，说明匹配不上</span></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果根节点的值能匹配上，就分别去比较左右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> (isSubTree(root1.left,root2.left)&amp;&amp;isSubTree(root1.right,root2.right)); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.png" alt></p><h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><ul><li>题目描述<br>操作给定的二叉树，将其变换为源二叉树的镜像。</li></ul><p>二叉树的镜像定义：源二叉树 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6   10</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 9 11</span><br><span class="line">镜像二叉树</span><br><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  10   6</span><br><span class="line"> / \  / \</span><br><span class="line">11 9 7  5</span><br></pre></td></tr></table></figure><ul><li>思路<br>采用递归的方式，递归交换每一个父节点的两个子节点的位置。</li></ul><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        </span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.png" alt></p><h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h3><ul><li><p>题目描述<br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p></li><li><p>思路<br>待详细看看</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(matrix==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">       <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">       <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span> left=<span class="number">0</span>,top=<span class="number">0</span>,right=col-<span class="number">1</span>,bottom=row-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)&#123;</span><br><span class="line">           <span class="comment">//从左向右</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">               list.add(matrix[top][i]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//从上到下（从下一行开始向下走）</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=top+<span class="number">1</span>;j&lt;=bottom;j++)&#123;</span><br><span class="line">               list.add(matrix[j][right]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//从右到左</span></span><br><span class="line">           <span class="keyword">if</span>(top!=bottom)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k=right-<span class="number">1</span>;k&gt;=left;k--)&#123;</span><br><span class="line">                   list.add(matrix[bottom][k]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//从下到上</span></span><br><span class="line">           <span class="keyword">if</span>(left!=right)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> l=bottom-<span class="number">1</span>;l&gt;top;l--)&#123;</span><br><span class="line">                   list.add(matrix[l][left]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//下一个正方形矩阵</span></span><br><span class="line">           top++;left++;right--;bottom--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.png" alt></p><h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><ul><li><p>题目描述<br>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。<br>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p></li><li><p>思路<br>每次入栈2个元素，一个是入栈的元素本身，一个是当前栈元素的最小值。  如：入栈序列为2-3-1，则入栈后栈中元素序列为：2-2-3-2-1-1 * 用空间代价来换取时间代价。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            stack.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack.peek();</span><br><span class="line">            stack.push(node);</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;node)&#123;</span><br><span class="line">                stack.push(temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.get(stack.size()-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.png" alt></p><h3 id="栈的压入-弹出序列"><a href="#栈的压入-弹出序列" class="headerlink" title="栈的压入_弹出序列"></a>栈的压入_弹出序列</h3><ul><li><p>题目描述<br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p></li><li><p>思路<br>借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p></li></ul><p>举例：<br>入栈1,2,3,4,5<br>出栈4,5,3,2,1<br>首先1入辅助栈，此时栈顶1≠4，继续入栈2<br>此时栈顶2≠4，继续入栈3<br>此时栈顶3≠4，继续入栈4<br>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3<br>此时栈顶3≠5，继续入栈5<br>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3<br>….<br>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">      <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">          stack.push(pushA[i]);</span><br><span class="line">          <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()==popA[popIndex])&#123;</span><br><span class="line">              <span class="comment">// 弹出出栈数据</span></span><br><span class="line">              stack.pop();</span><br><span class="line">              popIndex++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5_%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.png" alt></p><h3 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h3><ul><li><p>题目描述<br>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p></li><li><p>思路<br>用arraylist模拟一个队列来存储相应的TreeNode。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.remove(<span class="number">0</span>);</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><ul><li><p>题目描述<br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></li><li><p>思路<br>已知条件：后序序列最后一个值为root；二叉搜索树左子树值都比root小，右子树值都比root大。<br>（1）确定root；<br>（2）遍历序列（除去root结点），找到第一个大于root的位置，则该位置左边为左子树，右边为右子树；<br>（3）遍历右子树，若发现有小于root的值，则直接返回false；<br>（4）分别判断左子树和右子树是否仍是二叉搜索树（即递归步骤1、2、3）。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span>[] sequence,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> rootIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt; rootIndex)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = startIndex;</span><br><span class="line">        <span class="keyword">while</span>(sequence[i]&lt;sequence[rootIndex])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断右子树中的值，不能比根节点的值小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;rootIndex;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[j]&lt;sequence[rootIndex])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分别判断左右子树是否满足平衡二叉搜索树的后序遍历</span></span><br><span class="line">        <span class="keyword">return</span> judge(sequence,startIndex,i-<span class="number">1</span>)&amp;&amp;judge(sequence,i+<span class="number">1</span>,rootIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.png" alt></p><h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><ul><li><p>题目描述<br>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p></li><li><p>思路<br>（1）root入栈，跳入该子树进行寻路操作 ；<br>（2）若root的这条路径，已满足要求，则将该路径加入到listAll中去；<br>（3）对root左右子树，继续寻路；<br>（4）root出栈，该子树访问完毕；</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 查找出所有满足条件的路径</span></span><br><span class="line">        find(root,target);</span><br><span class="line">        <span class="comment">// 根据resultList里每个list的大小进行排序</span></span><br><span class="line">        Collections.sort(resultList,<span class="keyword">new</span> Comparator&lt;ArrayList&lt;Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ArrayList&lt;Integer&gt; o1,ArrayList&lt;Integer&gt; o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.size() - o1.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(TreeNode root,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target = target - root.val;</span><br><span class="line">        <span class="comment">// 遍历到叶子节点，并且满足条件，加入到resultList中</span></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span> &amp;&amp; root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            resultList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还没有遍历到叶子节点就提前结束了,终止遍历</span></span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续探寻左右子树</span></span><br><span class="line">        find(root.left,target);</span><br><span class="line">        find(root.right,target);</span><br><span class="line">        <span class="comment">// 删除本次添加到list中的元素，为下一条路径作准备</span></span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.png" alt></p><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><ul><li><p>题目描述<br>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p></li><li><p>思路<br>首先复制出头节点，再向后循环复制。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先复制头节点</span></span><br><span class="line">        RandomListNode head = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">        RandomListNode ans = head;</span><br><span class="line">        <span class="keyword">if</span>(pHead.random!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            head.random = <span class="keyword">new</span> RandomListNode(pHead.random.label);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">            head.next = <span class="keyword">new</span> RandomListNode(pHead.label);</span><br><span class="line">            <span class="keyword">if</span>(pHead.random!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                head.next.random = <span class="keyword">new</span> RandomListNode(pHead.random.label);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.png" alt></p><h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><ul><li><p>题目描述<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><img src="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0.png" alt></p></li><li><p>思路<br>递归实现，中序遍历。每次用一个lastNode存放上一个子树的最后一个结点，该结点是上个已排好子树的最大的结点。<br>因此此时对于结点10来说，只需要建立与8之间的联系。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode lastNode=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        TreeNode p = pRootOfTree;</span><br><span class="line">        middleFind(p);</span><br><span class="line">        <span class="keyword">while</span>(lastNode!=<span class="keyword">null</span> &amp;&amp; lastNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastNode = lastNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">middleFind</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        middleFind(p.left);</span><br><span class="line">        p.left = lastNode;</span><br><span class="line">        <span class="keyword">if</span>(lastNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastNode.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        lastNode = p;</span><br><span class="line">        middleFind(p.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt></p><h3 id="字符串的全排列"><a href="#字符串的全排列" class="headerlink" title="字符串的全排列"></a>字符串的全排列</h3><ul><li><p>题目描述<br>题目描述<br>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p></li><li><p>思路<br><img src="%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3.png" alt></p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(str==<span class="keyword">null</span> || str==<span class="string">""</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       &#125;</span><br><span class="line">       Permutation(str.toCharArray(),<span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 排序</span></span><br><span class="line">       Collections.sort(list);</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == chars.length-<span class="number">1</span>)&#123;</span><br><span class="line">            String str = String.valueOf(chars);</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(str))&#123;</span><br><span class="line">                list.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;chars.length;i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">                chars[i] =  chars[pos];</span><br><span class="line">                chars[pos] = temp;</span><br><span class="line">            </span><br><span class="line">                Permutation(chars,pos+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                temp = chars[i];</span><br><span class="line">                chars[i] =  chars[pos];</span><br><span class="line">                chars[pos] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97.png" alt></p><h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><ul><li><p>题目描述<br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || length&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(times==<span class="number">0</span>)&#123;</span><br><span class="line">                result = array[i];</span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(result==array[i])&#123;</span><br><span class="line">                    times++; <span class="comment">// 如果记录的值与统计值相等，记数值增加</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    times--; <span class="comment">// 如果不相同就减少，相互抵消</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result==array[i])&#123;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&lt;=length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.png" alt></p><h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><ul><li><p>题目描述<br>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p></li><li><p>思路<br>使用冒泡排序k趟即可，每趟都可以确定一个最小值。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> || k&gt;input.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用冒泡排序k趟即可，每趟都可以确定一个最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;input.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(input[j+<span class="number">1</span>]&gt;input[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = input[j+<span class="number">1</span>];</span><br><span class="line">                    input[j+<span class="number">1</span>] = input[j];</span><br><span class="line">                    input[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(input[input.length-i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.png" alt></p><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><ul><li><p>题目描述<br>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p></li><li><p>思路<br>可以用动态规划的思想来分析这个问题。如果用函数 f(i)表示以第 i 个数字结尾的子数组的最大和，那么我们需要求出 max[f(i)]，其中 0 &lt;= i &lt; n。我们可用如下边归公式求 f(i):</p></li></ul><p><img src="%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt></p><p>这个公式的意义：当以第 i-1 个数字结尾的子数组中所有数字的和小于 0 时，如果把这个负数与第 i 个数累加，得到的结果比第 i 个数字本身还要小，所以这种情况下以第 i 个数字结尾的子数组就是第 i 个数字本身。如果以第 i-1 个数字结尾的子数组中所有数字的和大于 0，与第 i 个数字累加就得到以第 i 个数字结尾的子数组中所有数字的和。</p><p>本题采用第一种实现方式。</p><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录最大的子数组和，初始化为int的最小值，可能为负数</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 当前的和</span></span><br><span class="line">        <span class="keyword">int</span> curMax =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curMax&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果当前和小于等于0，就重新设置当前和</span></span><br><span class="line">                curMax=array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果当前和大于0，累加当前和</span></span><br><span class="line">                curMax+=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;curMax)&#123;</span><br><span class="line">                max=curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.png" alt></p><h3 id="1到n的整数中1出现的次数"><a href="#1到n的整数中1出现的次数" class="headerlink" title="1到n的整数中1出现的次数"></a>1到n的整数中1出现的次数</h3><ul><li><p>题目描述<br>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1-13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）</p></li><li><p>思路<br>遍历n个整数，把每一个整数都转成字符串，再将这个字符串转成char数组。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            String str = String.valueOf(n);</span><br><span class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chars[i]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="1%E5%88%B0n%E7%9A%84%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.png" alt></p><h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><ul><li><p>题目描述<br>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></li><li><p>思路<br>重写Comparator的compare()方法。</p></li></ul><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            list.add(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1,Integer o2)</span></span>&#123;</span><br><span class="line">                String str1 = o1+<span class="string">""</span>+o2;</span><br><span class="line">                String str2 = o2+<span class="string">""</span>+o1;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> str1.compareTo(str2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            builder.append(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.png" alt></p><h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><ul><li><p>题目描述<br>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p></li><li><p>思路<br>首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2 ^ x * 3 ^ y * 5 ^ z，换句话说一个丑数一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方法会得到重复的丑数，而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：</p></li></ul><p>（1）丑数数组： 1</p><p>乘以2的队列：2</p><p>乘以3的队列：3</p><p>乘以5的队列：5</p><p>选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（2）丑数数组：1,2</p><p>乘以2的队列：4</p><p>乘以3的队列：3，6</p><p>乘以5的队列：5，10</p><p>选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（3）丑数数组：1,2,3</p><p>乘以2的队列：4,6</p><p>乘以3的队列：6,9</p><p>乘以5的队列：5,10,15</p><p>选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（4）丑数数组：1,2,3,4</p><p>乘以2的队列：6，8</p><p>乘以3的队列：6,9,12</p><p>乘以5的队列：5,10,15,20</p><p>选择三个队列头里最小的数5加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；</p><p>（5）丑数数组：1,2,3,4,5</p><p>乘以2的队列：6,8,10，</p><p>乘以3的队列：6,9,12,15</p><p>乘以5的队列：10,15,20,25</p><p>选择三个队列头里最小的数6加入丑数数组，但我们发现，有两个队列头都为6，所以我们弹出两个队列头，同时将12,18,30放入三个队列；</p><p>……………………</p><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;index-<span class="number">1</span>)&#123;</span><br><span class="line">            temp = Math.min(result[i2]*<span class="number">2</span>,Math.min(result[i3]*<span class="number">3</span>,result[i5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(temp==result[i2]*<span class="number">2</span>)&#123;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp==result[i3]*<span class="number">3</span>)&#123;</span><br><span class="line">                i3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp==result[i5]*<span class="number">5</span>)&#123;</span><br><span class="line">                i5++;</span><br><span class="line">            &#125;</span><br><span class="line">            result[++count] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%B8%91%E6%95%B0.png" alt></p><h3 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h3><ul><li><p>题目描述<br>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p></li><li><p>思路<br>见代码注释。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先统计每个字符出现的次数</span></span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(chars[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> times = map.get(chars[i]);</span><br><span class="line">                map.put(chars[i],++times);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(chars[i],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(chars[i])==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 第一次发现字符对应的出现次数为1，立即返回下标</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.png" alt></p><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><ul><li><p>题目描述<br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p></li><li><p>思路<br>归并排序</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h3><ul><li><p>题目描述<br>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p></li><li><p>思路<br>找出两个链表的长度，然后让长的链表先走两个链表的长度差，接着两个链表一起走。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(pHead1==<span class="keyword">null</span>||pHead2==<span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">int</span> len1 = getLen(pHead1);</span><br><span class="line">         <span class="keyword">int</span> len2 = getLen(pHead2);</span><br><span class="line">         <span class="keyword">if</span>(len1&gt;len2)&#123;</span><br><span class="line">             <span class="keyword">int</span> step = len1-len2;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;step;i++)&#123;</span><br><span class="line">                 pHead1=pHead1.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span>(len2&gt;len1)&#123;</span><br><span class="line">             <span class="keyword">int</span> step = len2-len1;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;step;i++)&#123;</span><br><span class="line">                 pHead2=pHead2.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">while</span>(pHead1!=<span class="keyword">null</span>&amp;&amp;pHead2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(pHead1.val==pHead2.val)&#123;</span><br><span class="line">                 <span class="keyword">return</span> pHead1;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 pHead1 = pHead1.next;</span><br><span class="line">                 pHead2 = pHead2.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9.png" alt></p><h3 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h3><ul><li><p>题目描述<br>统计一个数字在排序数组中出现的次数。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(array[i]==k)</span><br><span class="line">               count++;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%95%B0%E7%BB%84%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.png" alt></p><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><ul><li><p>题目描述<br>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p></li><li><p>思路<br>递归</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.png" alt></p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><ul><li><p>题目描述<br>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p></li><li><p>思路<br>左右子树的高度相差不超过 1 。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(treeDepth(root.left) - treeDepth(root.right)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left)&amp;&amp;IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = treeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = treeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E5%88%AB.png" alt></p><h3 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="和为S的连续正数序列"><a href="#和为S的连续正数序列" class="headerlink" title="和为S的连续正数序列"></a>和为S的连续正数序列</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><ul><li><p>题目描述<br>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p></li><li><p>思路<br>使用两个StringBuffer，对字符串进行截断，然后再拼接。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer(str.substring(<span class="number">0</span>,n));</span><br><span class="line">        StringBuffer sb1=<span class="keyword">new</span> StringBuffer(str.substring(n,str.length()));</span><br><span class="line">        sb1.append(sb);</span><br><span class="line">        <span class="keyword">return</span> sb1.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%B7%A6%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt></p><h3 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a>翻转单词顺序列</h3><ul><li><p>题目描述<br>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String trim = str.trim();</span><br><span class="line">        String a = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(str.trim()))&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] split = str.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = split.length-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            a +=split[i]+<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97.png" alt></p><h3 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="孩子们的游戏（圆圈中最后剩下的数"><a href="#孩子们的游戏（圆圈中最后剩下的数" class="headerlink" title="孩子们的游戏（圆圈中最后剩下的数)"></a>孩子们的游戏（圆圈中最后剩下的数)</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="求1到n的整数和"><a href="#求1到n的整数和" class="headerlink" title="求1到n的整数和"></a>求1到n的整数和</h3><ul><li><p>题目描述<br>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></li><li><p>思路<br>直接使用等差数列的求和公式。利用到Math.pow(n,2)。<code>(n的二次方 + n)/2</code></p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = (<span class="keyword">int</span>) (Math.pow(n,<span class="number">2</span>) + n);</span><br><span class="line">       <span class="comment">// 除以2右移1位操作</span></span><br><span class="line">       <span class="keyword">return</span> sum&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%B1%821%E5%88%B0n%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C.png" alt></p><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><ul><li><p>题目描述<br>写一个函数，求两个整数之和，要求在函数体内不得使用<code>+、-、*、/</code>四则运算符号。</p></li><li><p>思路<br>使用java中的BigInteger封装类。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        BigInteger bi1=<span class="keyword">new</span> BigInteger(String.valueOf(num1));</span><br><span class="line">        BigInteger bi2=<span class="keyword">new</span> BigInteger(String.valueOf(num2));</span><br><span class="line">        <span class="keyword">return</span> bi1.add(bi2).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.png" alt></p><h3 id="把字符串转化成整数"><a href="#把字符串转化成整数" class="headerlink" title="把字符串转化成整数"></a>把字符串转化成整数</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="数组中的重复数字"><a href="#数组中的重复数字" class="headerlink" title="数组中的重复数字"></a>数组中的重复数字</h3><ul><li><p>题目描述<br>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></li><li><p>思路<br>需要额外的boolean[]数组，以numbers[i]值为下标，如果设置过这个下标值，对应的值就设置为true。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 将当前输入数组作为boolean[] k数组的下标</span></span><br><span class="line">         <span class="keyword">boolean</span>[] k = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(k[numbers[i]]==<span class="keyword">true</span>)&#123;</span><br><span class="line">                 duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             k[numbers[i]] = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97.png" alt></p><h3 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h3><ul><li><p>题目描述<br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p></li><li><p>思路<br>根据题目中列举的场景，进行正则匹配。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        String s=String.valueOf(str);</span><br><span class="line">        <span class="comment">//return s.matches("[+-]?[0-9]*(.[0-9]*)?([eE][+-]?[0-9]+)?");</span></span><br><span class="line">        <span class="comment">// [] 匹配所包含的任意字符</span></span><br><span class="line">        <span class="comment">// ？后面的字符紧跟在前面的字符，非贪婪匹配，非必须的</span></span><br><span class="line">        <span class="comment">// *匹配前面的子表达式任意次</span></span><br><span class="line">        <span class="comment">// +匹配一次或多次</span></span><br><span class="line">        <span class="comment">// \\. 转义特殊字符</span></span><br><span class="line">        <span class="comment">// 最前面的[+-]不一定需要，必须以[0-9]数字开头，后面接(\\.[0-9]*)，或者eE等操作</span></span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"[+-]?[0-9]*(\\.[0-9]*)?([eE][+-]?[0-9]+)?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt></p><h3 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a>字符流中第一个不重复的字符</h3><ul><li><p>题目描述<br>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>输出描述:<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p></li><li><p>思路<br>与<code>数组中的重复数字</code>的思路类似。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组的下标值为字符，字符占8位，不会超过256。对应每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">int</span>[] hashtable = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        sb.append(ch);</span><br><span class="line">        hashtable[ch] +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable[chars[i]]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 找到字符对应的出现次数为1，立即返回</span></span><br><span class="line">                <span class="keyword">return</span> chars[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.png" alt></p><h3 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h3><ul><li><p>题目描述<br>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span> || pHead.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode fast=pHead;</span><br><span class="line">        ListNode slow=pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                <span class="comment">// 找到相遇点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 链表中没有环</span></span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast重新指向第一个结点</span></span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.png" alt></p><h3 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h3><ul><li><p>题目描述<br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p></li><li><p>思路</p></li></ul><ul><li>代码示例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead!=<span class="keyword">null</span>&amp;&amp;pHead.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode current;</span><br><span class="line">        <span class="keyword">if</span>(pHead.val==pHead.next.val)&#123;</span><br><span class="line">            current = pHead.next.next;</span><br><span class="line">            <span class="keyword">while</span>(current!=<span class="keyword">null</span> &amp;&amp; current.val==pHead.val)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(current);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current = pHead.next;</span><br><span class="line">            pHead.next = deleteDuplication(current);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9.png" alt></p><h3 id="二叉树的下一个结点"><a href="#二叉树的下一个结点" class="headerlink" title="二叉树的下一个结点"></a>二叉树的下一个结点</h3><ul><li><p>题目描述<br>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></li><li><p>思路<br>分析二叉树的下一个节点，一共有以下情况：<br>（1）二叉树为空，则返回空；<br>（2）节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；<br>（3）节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复第三步的判断，返回结果。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有右子树，则返回右子树的最左结点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeLinkNode parent = pNode.next;</span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left==pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.png" alt></p><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><ul><li><p>题目描述<br>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p></li><li><p>思路<br>递归判断：<br>①只要pRoot.left和pRoot.right是否对称即可。<br>②左右节点的值相等且对称子树left.left，right.right ;left.rigth,right.left也对称。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode leftNode,TreeNode rightNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode==<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftNode.val!=rightNode.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> judge(leftNode.left,rightNode.right) &amp;&amp; judge(leftNode.right,rightNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><h3 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h3><ul><li><p>题目描述<br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p></li><li><p>思路<br>利用栈先进后出的性质，创建两个栈分别存放奇数层与偶数层的节点。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; allList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> layer = <span class="number">1</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; odd = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        odd.push(pRoot);</span><br><span class="line">        Stack&lt;TreeNode&gt; even = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!odd.empty() || !even.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(layer%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!odd.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = odd.pop();</span><br><span class="line">                    <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(node.val);</span><br><span class="line">                        even.push(node.left);</span><br><span class="line">                        even.push(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">                    allList.add(list);</span><br><span class="line">                    layer++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">while</span>(!even.isEmpty())&#123;</span><br><span class="line">                    TreeNode node = even.pop();</span><br><span class="line">                    <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        list.add(node.val);</span><br><span class="line">                        odd.push(node.right);</span><br><span class="line">                        odd.push(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!list.isEmpty())&#123;</span><br><span class="line">                    allList.add(list);</span><br><span class="line">                    layer++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><h3 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a>把二叉树打印成多行</h3><ul><li><p>题目描述<br>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p></li><li><p>思路<br>借助LinkedList这个Queue对象来实现。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">     ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line"> <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line"> ArrayList&lt;Integer&gt; queueList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> queue.add(pRoot);</span><br><span class="line"> <span class="keyword">int</span> start = <span class="number">0</span> ,end = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"> TreeNode current = queue.remove();</span><br><span class="line"> queueList.add(current.val);</span><br><span class="line"> start++;</span><br><span class="line"> <span class="keyword">if</span>(current.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> queue.add(current.left);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(current.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> queue.add(current.right);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line"> end = queue.size();</span><br><span class="line"> start=<span class="number">0</span>;</span><br><span class="line"> result.add(queueList);</span><br><span class="line"> queueList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.png" alt></p><h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><ul><li>题目描述<br>请实现两个函数，分别用来序列化和反序列化二叉树</li></ul><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><ul><li><p>思路<br>（1）根据前序遍历规则完成序列化与反序列化。所谓序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。<br>（2）依据前序遍历序列来序列化二叉树，因为前序遍历序列是从根结点开始的。当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”。另外，结点之间的数值用逗号隔开。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">"#,"</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(root.val+<span class="string">","</span>);</span><br><span class="line">        sb.append(Serialize(root.left));</span><br><span class="line">        sb.append(Serialize(root.right));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       index++;</span><br><span class="line">       <span class="keyword">int</span> len = str.length();</span><br><span class="line">       <span class="keyword">if</span>(index&gt;=len)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String[] strr = str.split(<span class="string">","</span>);</span><br><span class="line">       TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span>(!strr[index].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">           root = <span class="keyword">new</span> TreeNode(Integer.valueOf(strr[index]));</span><br><span class="line">           root.left = Deserialize(str);</span><br><span class="line">           root.right = Deserialize(str);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><h3 id="二叉搜索树的第k个结点"><a href="#二叉搜索树的第k个结点" class="headerlink" title="二叉搜索树的第k个结点"></a>二叉搜索树的第k个结点</h3><ul><li><p>题目描述<br>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p></li><li><p>思路<br>使用中序遍历找到第k个节点。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 中序遍历，左根右</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode node = KthNode(pRoot.left,k);</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index==k)&#123;</span><br><span class="line">                <span class="keyword">return</span> pRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            node = KthNode(pRoot.right,k);</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.png" alt></p><h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h3><ul><li><p>题目描述<br>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p></li><li><p>思路<br>使用一个大顶堆和一个小顶堆，维持大顶堆的数都小于等于小顶堆的数，且两者的个数相等或差1。平均数就在两个堆顶的数之中。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1,Integer o2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2-o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 记录偶数个还是奇数个</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           maxHeap.offer(num);</span><br><span class="line">           <span class="keyword">int</span> max = maxHeap.poll();</span><br><span class="line">           minHeap.offer(max);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           minHeap.offer(num);</span><br><span class="line">           <span class="keyword">int</span> min = minHeap.poll();</span><br><span class="line">           maxHeap.offer(min);</span><br><span class="line">       &#125;</span><br><span class="line">       count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek()+maxHeap.peek())/<span class="number">2</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.png" alt></p><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><ul><li><p>题目描述<br>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span> || size&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> length = num.length;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 窗口个数 = num.length-size+1 ，8-3+1=6</span></span><br><span class="line">            <span class="keyword">int</span> windows = length-size+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;windows;i++)&#123;</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;size+i;j++)&#123;</span><br><span class="line">                   temp.add(num[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                Collections.sort(temp);</span><br><span class="line">                list.add(temp.get(temp.size()-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt></p><h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><ul><li><p>题目描述</p></li><li><p>思路</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><ul><li><p>题目描述<br>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></li><li><p>思路<br>动态规划。<br>设f(n)代表长度为n的绳子剪成若干段的最大乘积，如果第一刀下去，第一段长度是i，那么剩下的就需要剪n-i，那么f(n)=max{f(i)f(n-i)}。而f(n)的最优解对应着f(i)和f(n-i)的最优解，假如f(i)不是最优解，那么其最优解和f(n-i)乘积肯定大于f(n)的最优解，和f(n)达到最优解矛盾，所以f(n)的最优解对应着f(i)和f(n-i)的最优解。首先，剪绳子是最优解问题，其次，大问题包含小问题，并且大问题的最优解包含着小问题的最优解，所以可以使用动态规划求解问题，并且从小到大求解，把小问题的最优解记录在数组中，求大问题最优解时就可以直接获取，避免重复计算。<br>  n&lt;2时，由于每次至少减一次，所以返回0。n=2时，只能剪成两个1，那么返回1。n=3时，可以剪成3个1，或者1和2，那么最大乘积是2。当n&gt;3时，就可以使用公式进行求解。<br>  f(4)=max{f(1)f(3), f(2)f(2)}<br>  f(5)=max{f(1)f(4), f(2)f(3)}<br>  …<br>  f(n)=max{f(1)f(n-1), f(2)f(n-2), f(3)f(n-3), …, f(i)(fn-i), …}<br>  因为需要保证f(i)f(n-i)不重复，就需要保证i&lt;=n/2，这是一个限制条件，求1～n/2范围内的乘积，得到最大值。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        num[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        num[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = num[j]*num[i-j];</span><br><span class="line">                <span class="keyword">if</span>(max&lt;temp)&#123;</span><br><span class="line">                    max=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="%E5%89%AA%E7%BB%B3%E5%AD%90.png" alt></p><h2 id="经典排序算法"><a href="#经典排序算法" class="headerlink" title="经典排序算法"></a>经典排序算法</h2><p>参考：<br><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>相邻的元素进行两两比较，满足条件则交换，这样一趟会将最小或最大的元素”浮”到顶端。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每一趟从待排序的元素中选择最小(大)的一个元素作为首元素。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>每一步将一个待排序的元素，插入到前面已经排好的有序序列中，直到插完所有的元素。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>“分”而治之</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>先选定一个基数，将小于基数的放到前面，大于基数的放到后面<br>循环往复</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>分组，不断除以2<br>交换元素</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>PriorityQueue</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>参考：<br><a href="https://blog.csdn.net/whoamiyang/article/details/51926985" target="_blank" rel="noopener">树</a></p><h3 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h3><p><img src="%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><p>如果根节点选择的是最小或最大的树，那么二叉树就完全退化成了线性结构，树的高度会很高，查找复杂度变高。</p><h3 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><img src="%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p><p>左右子树的树高差不超过1，和红黑树相比，它是严格的平衡二叉树。<br>在执行插入或删除操作，只要不满足条件，就要通过旋转来保持平衡，旋转是非常耗时的，因此AVL树适合用于插入删除次数比较少，但查找多的情况。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><img src="%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt></p><p>每个节点增加了一个存储位表示节点的颜色，red 或 black。通过对任何一条从根到叶子的路径上各个节点的着色的方式的限制，红黑树确保没有一条路径会比其他路径长出两倍。<br>是一种弱平衡二叉树，旋转次数变少，所以对于搜索、插入、删除操作多的情况下，我们就用红黑树。</p><ul><li>每个节点非红即黑</li><li>根节点是黑色的</li><li>每个叶节点（即树尾端NULL指针或NULL节点）都是黑色的</li><li>如果一个节点是红色的，那么它的两儿子都是黑色的</li><li>每条路径包含相同的黑色节点</li></ul><p>应用：</p><ul><li>map 和 set 都是用红黑树实现的，java中 TreeMap 的实现</li><li>linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一棵红黑树上，每个虚拟地址区域都对应红黑树的一个节点，左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间</li><li>IO多路复用epoll的实现采用红黑树组织管理 sockfd，以支持快速的增删改查</li></ul><h3 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B/B+树"></a>B/B+树</h3><p>B/B+树是为了磁盘或其他存储设备而设计的一种平衡多路查找树，B树每个内节点有多个分支。与红黑树相比，在相同节点的情况下，一棵B/B+树的高度远远小于红黑树的高度。<br>B/B+树上操作的时间通常由存取磁盘的时间和CPU计算时间两部分构成，而CPU的速度非常快，所以B树的操作小笼包取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B-树和B树是等价的。</p><p><img src="B%E6%A0%91.png" alt></p><p>在实际中B树节点中关键字很多的，比如上图中的35节点，35代表一个key（索引），而小黑块代表的是这个key所指向的内容在内存中实际的存储位置，是一个指针。</p><ul><li>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</li><li>根结点的儿子数为[2, M]；</li><li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li><li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1；</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li><li>所有叶子结点位于同一层；</li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是B树的变形树，文件的目录一级一级索引，只有最底层的叶子结点（文件）保存数据，非叶子结点只保存索引，不保存实际的数据，数据都保存在叶子结点中。<br>所有的非叶子结点都可以看成索引部分。</p><p>优点：</p><ul><li>B+树只有叶节点存放数据，其余节点用来索引，而B树的每个索引节点都会有 Data 域。</li><li>B+树所有的Data域在叶子节点，并且所有叶子节点之间都有一个链指针。 这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。</li></ul><p><img src="B+%E6%A0%91.png" alt></p><p>与B树不相同的性质：</p><ul><li>非叶子节点的子树指针与关键字个数相同;</li><li>非叶子节点的子树指针p[i],指向关键字值属于[k[i],k[i+1]]的子树.(B树是开区间,也就是说B树不允许关键字重复,B+树允许重复)；</li><li>为所有叶子节点增加一个链指针.</li><li>所有关键字都在叶子节点出现(稠密索引). (且链表中的关键字恰好是有序的);</li><li>非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层.</li><li>更适合于文件系统;</li></ul><p>不使用红黑树做索引的原因：</p><ul><li>n个节点的平衡二叉树的高度为H即（logn），而n个节点的B/B+树高度为logt((n+1)/2)+1</li><li>AVL 树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构。在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍常见的数据结构，算法思想，排序算法、树等。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://yoursite.com/2020/03/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/03/14/分布式事务/</id>
    <published>2020-03-14T02:03:39.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍什么是分布式事务，分布式事务解决什么问题，不同场景下方案的选择。</p><a id="more"></a><p>参考：<a href="https://mp.weixin.qq.com/s/vgohXl1LxYk3CyDI8WHxwA" target="_blank" rel="noopener">分布式事务</a>，特此整理到自己的博客中。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的具体定义"><a href="#事务的具体定义" class="headerlink" title="事务的具体定义"></a>事务的具体定义</h3><p>简单地说，事务提供一种“ 要么什么都不做，要么做全套（All or Nothing）”机制。</p><p><img src="%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9A%E4%B9%89.png" alt></p><p>数据库事务，简单而言，就是业务上有一组数据操作，需要如果其中有任何一个操作执行失败，整组操作全部不执行并恢复到未执行状态，要么全部成功，要么全部失败。<br>在使用数据库事务时需要注意，尽可能短的保持事务，修改多个不同表的数据的冗长事务会严重妨碍系统中的所有其他用户，这很有可能导致一些性能问题。</p><h3 id="ACID属性"><a href="#ACID属性" class="headerlink" title="ACID属性"></a>ACID属性</h3><p>例如：银行转账，从A账户转100元至B账户，分为两个步骤：</p><ol><li>从A账户取100元</li><li>存入100元至B账户</li></ol><ul><li>原子性</li></ul><p>事务操作的整体性。上述两步要么一起完成，要么一起不完成。</p><ul><li>一致性</li></ul><p>事务操作下数据的正确性。现有完整性约束 A+B=100，如果一个事务改变了 A，那么必须得改变 B，使得事务结束后依然满足 A+B=100，否则事务失败。</p><ul><li>隔离性</li></ul><p>事务并发操作下数据的正确性。现有有个交易是从 A 账户转 100 元至 B 账户，在这个交易事务还未完成的情况下，如果此时 B 查询自己的账户，是看不到新增加的 100 元的。</p><ul><li>持久性</li></ul><p>事务对数据修改的可靠性。事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h3><p>随着互联网快速发展，微服务，SOA 等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。</p><p>有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统。</p><p>下图所示是互联网常用的交易业务，包含库存和订单两个独立的微服务，每个微服务维护了自己的数据库：<br><img src="%E4%BA%92%E8%81%94%E7%BD%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%A4%E6%98%93%E4%B8%9A%E5%8A%A1.png" alt></p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul><li>原子性</li></ul><p>事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的要么什么都不做，要么做全套（All or Nothing）的原子性。</p><ul><li>一致性</li></ul><p>当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。</p><ul><li>隔离性</li></ul><p>事务隔离性的本质就是如何正确处理多个并发事务的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。</p><p>此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。</p><h3 id="分布式系统的一致性"><a href="#分布式系统的一致性" class="headerlink" title="分布式系统的一致性"></a>分布式系统的一致性</h3><h4 id="可用性和一致性冲突：CAP理论"><a href="#可用性和一致性冲突：CAP理论" class="headerlink" title="可用性和一致性冲突：CAP理论"></a>可用性和一致性冲突：CAP理论</h4><p>在一个分布式系统中，当涉及写操作时，只能保证三者中的两个，另一个必须牺牲。只能选择 CP 或者 AP 架构，在一致性和可用性间做折中选择。</p><p><img src="CAP%E7%90%86%E8%AE%BA%E5%9B%BE.png" alt></p><p>C：对某个指定的客户端来说，强调读操作保证能够返回最新的写操作结果，不会读取到实物中间写入的数据。<br>A：非故障节点在合理的时间内返回合理的响应（不是错误和超时的响应）。<br>P：由于一些故障（节点间网络连接断开、节点宕机），使得有些节点之间不连通了，整个网络就分成了几块区域，系统能够“继续履行职责”。</p><h3 id="常见分布式事务解决方案"><a href="#常见分布式事务解决方案" class="headerlink" title="常见分布式事务解决方案"></a>常见分布式事务解决方案</h3><h4 id="2PC（二阶段提交）：强一致性"><a href="#2PC（二阶段提交）：强一致性" class="headerlink" title="2PC（二阶段提交）：强一致性"></a>2PC（二阶段提交）：强一致性</h4><ol><li>准备阶段</li></ol><ul><li>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。</li><li>各参与者执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。</li><li>如参与者执行成功，给协调者反馈yes，即可以提交；如执行失败，给协调者反馈no，即不可提交。</li></ul><ol start="2"><li>提交阶段</li></ol><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚（rollback）消息；否则，发送提交（commit）消息。</p><p><img src="%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4_%E6%AD%A3%E5%B8%B8.png" alt></p><p>方案总结：</p><ul><li>性能问题：所有参与者在准备阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li><li>可靠性问题：如果协调者出现故障，参与者将一直处于锁定状态。</li><li>数据一致性问题：在提交阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，就导致了节点之间数据的不一致。</li></ul><h4 id="3PC（三阶段提交）"><a href="#3PC（三阶段提交）" class="headerlink" title="3PC（三阶段提交）"></a>3PC（三阶段提交）</h4><ol><li>canCommit</li></ol><ul><li>协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。</li><li>参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</li></ul><ol start="2"><li>preCommit</li></ol><ul><li>协调者向所有参与者发出 preCommit 请求，进入准备阶段。</li><li>参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。</li><li>各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。</li></ul><ol start="3"><li>doCommit</li></ol><ul><li>如果协调者处于工作状态，则向所有参与者发出 do Commit 请求。</li><li>参与者收到 do Commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li><li>各参与者向协调者反馈 ack 完成的消息。</li><li>协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。</li></ul><p><img src="%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4_%E6%AD%A3%E5%B8%B8.png" alt></p><p>方案总结：</p><p>相比两阶段提交，降低了阻塞范围，在 canCommit 阶段等待超时后协调者或参与者会中断事务。在 doCommit 阶段，如果协调者出现问题时，参与者会继续提交事务。<br>但数据不一致问题依然存在，在 doCommit 阶段，如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p><h4 id="TCC事务：最终一致性"><a href="#TCC事务：最终一致性" class="headerlink" title="TCC事务：最终一致性"></a>TCC事务：最终一致性</h4><ol><li>Try阶段</li></ol><ul><li>完成所有业务检查（一致性）。</li><li>预留必须业务资源（准隔离性）。</li><li>Try 尝试执行业务。</li></ul><ol start="2"><li>Confirm/Cancel阶段</li></ol><p>Confirm 和 Cancel 操作满足幂等性，如果 Confirm 和 Cancel 操作执行失败，将会不断重试知道执行完成。</p><p><img src="TCC%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86_%E6%AD%A3%E5%B8%B8" alt></p><p>方案总结：</p><ul><li>性能提升：具体业务实现控制资源，锁的粒度变小，不会锁定整个资源。</li><li>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li><li>可靠性：解决协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点。</li></ul><p>但是，TCC 的 Try、Confirm、Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p><h4 id="本地消息表：最终一致性"><a href="#本地消息表：最终一致性" class="headerlink" title="本地消息表：最终一致性"></a>本地消息表：最终一致性</h4><p>下面把分布式事务最先开始处理的事务方称为事务主动方，在事务主动方之后处理的业务内的其他事务称为事务被动方。<br>为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤。<br>库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。<br>事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p><p><img src="%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E6%96%B9%E6%A1%88.png" alt></p><h4 id="MQ事务：最终一致性"><a href="#MQ事务：最终一致性" class="headerlink" title="MQ事务：最终一致性"></a>MQ事务：最终一致性</h4><p><img src="RocketMQ%E4%BA%8B%E5%8A%A1.png" alt></p><ol><li>发送方向 MQ Server 发送 half 消息。</li><li>MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功。</li><li>发送方开始执行本地事务逻辑。</li><li>发送方根据本地事务执行结果向 MQ Server 提交二次确认 (commit或是rollback)。</li><li>MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</li></ol><p>二次确认超时的情况：</p><ol><li>MQ Server 对该消息发起消息回查。</li><li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>发送方根据检查得到本地事务的最终状态再次提交二次确认，</li><li>MQ Server基于 commit/rollback 对消息进行投递或者删除。</li></ol><p><img src="RocketMO%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8.png" alt></p><h4 id="Soga事务：最终一致性"><a href="#Soga事务：最终一致性" class="headerlink" title="Soga事务：最终一致性"></a>Soga事务：最终一致性</h4><p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。<br>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p><p><img src="Soga%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88.png" alt></p><h4 id="各方案使用场景"><a href="#各方案使用场景" class="headerlink" title="各方案使用场景"></a>各方案使用场景</h4><p><img src="%E5%90%84%E6%96%B9%E6%A1%88%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%AF%94%E8%BE%83.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍什么是分布式事务，分布式事务解决什么问题，不同场景下方案的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Flink内存管理</title>
    <link href="http://yoursite.com/2020/03/03/Flink%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/03/Flink内存管理/</id>
    <published>2020-03-03T04:35:36.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍一下Flink的内存管理。参考<a href="https://ververica.cn/developers/flink-principle-memory-management/" target="_blank" rel="noopener"></a></p><a id="more"></a><h2 id="量身定制的序列化框架"><a href="#量身定制的序列化框架" class="headerlink" title="量身定制的序列化框架"></a>量身定制的序列化框架</h2><p><img src="%E9%87%8F%E8%BA%AB%E5%AE%9A%E5%88%B6%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%86%E6%9E%B6.png" alt></p><h2 id="直接操作二进制数据"><a href="#直接操作二进制数据" class="headerlink" title="直接操作二进制数据"></a>直接操作二进制数据</h2><p><img src="%E5%B0%86sort_buffer%E5%88%86%E6%88%90%E4%B8%A4%E5%9D%97%E5%8C%BA%E5%9F%9F.png" alt></p><p><img src="sort%E4%BD%BF%E7%94%A8key%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F.png" alt></p><p>Flink通过定制的序列化框架将算法中需要操作的数据（如sort中的key）连续存储，而完整的数据存储在其他地方。因为对于完整的数据来说，key+pointer 更容易装进缓存，这大大提高了缓存命中率，从而提高了基础算法的效率。这对于上层应用是完全透明的，可以充分享受缓存友好带来的性能提升。</p><h2 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h2><p>Flink 基于堆内存的内存管理机制已经可以解决很多 JVM 现存问题了，为什么还要引入堆外内存？</p><ol><li><p>启动超大内存（上百 GB）的 JVM 需要很长时间，GC 停留时间也会很长（分钟级）。使用堆外内存的话，可以极大地减小堆内存（只需要分配 Remaining Heap 那一块），使得 TaskManager 扩展到上百 GB 内存不是问题。</p></li><li><p>高效的 IO 操作。堆外内存在写磁盘或网络传输时是 zero-copy，而堆内存的话，至少需要 copy 一次。</p></li><li><p>堆外内存是进程间共享的。也就是说，即使 JVM 进程崩溃也不会丢失数据。这可以用来做故障恢复（Flink 暂时没有利用起这个，不过未来很可能会去做）。</p></li></ol><p>Flink用通过ByteBuffer.allocateDirect(numBytes)来申请堆外内存，用 sun.misc.Unsafe 来操作堆外内存。</p><p>基于 Flink 优秀的设计，实现堆外内存是很方便的。Flink 将原来的 MemorySegment 变成了抽象类，并生成了两个子类。HeapMemorySegment 和 HybridMemorySegment。从字面意思上也很容易理解，前者是用来分配堆内存的，后者是用来分配堆外内存和堆内存的。是的，你没有看错，后者既可以分配堆外内存又可以分配堆内存。为什么要这样设计呢？</p><p>首先假设HybridMemorySegment只提供分配堆外内存。在上述堆外内存的不足中的第二点谈到，Flink 有时需要分配短生命周期的 buffer，这些 buffer 用HeapMemorySegment会更高效。那么当使用堆外内存时，为了也满足堆内存的需求，我们需要同时加载两个子类。这就涉及到了 JIT 编译优化的问题。因为以前 MemorySegment 是一个单独的 final 类，没有子类。JIT 编译时，所有要调用的方法都是确定的，所有的方法调用都可以被去虚化（de-virtualized）和内联（inlined），这可以极大地提高性能（MemroySegment的使用相当频繁）。然而如果同时加载两个子类，那么 JIT 编译器就只能在真正运行到的时候才知道是哪个子类，这样就无法提前做优化。实际测试的性能差距在 2.7 被左右。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍一下Flink的内存管理。参考&lt;a href=&quot;https://ververica.cn/developers/flink-principle-memory-management/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flink" scheme="http://yoursite.com/categories/Flink/"/>
    
    
  </entry>
  
  <entry>
    <title>Apache HBase</title>
    <link href="http://yoursite.com/2020/02/27/Apache-HBase/"/>
    <id>http://yoursite.com/2020/02/27/Apache-HBase/</id>
    <published>2020-02-27T01:48:11.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将全局介绍 HBase 的整体架构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将全局介绍 HBase 的整体架构。&lt;/p&gt;

      
    
    </summary>
    
      <category term="NoSql" scheme="http://yoursite.com/categories/NoSql/"/>
    
    
  </entry>
  
  <entry>
    <title>Apache Kafka</title>
    <link href="http://yoursite.com/2020/02/18/Apache-Kafka/"/>
    <id>http://yoursite.com/2020/02/18/Apache-Kafka/</id>
    <published>2020-02-18T01:42:04.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将全局介绍 Kafka 的整体架构。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="Kafka%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt></p><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>  消息是Kafka中最基本的数据单元。消息由一串字节构成，主要由key和value构成，key和value也都是byte数组。</p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>  Topic是用于存储消息的逻辑概念，可以看作一个消息集合。每个Topic可以有多个生产者向其推送消息，也可以有多个Consumer消费其中的消息。<br><img src="%E9%80%BB%E8%BE%91Topic1.png" alt></p><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>  每个Topic可以划分为多个Partition，同一Topic下的不同分区包含的消息是不同的。每个消息在被添加到分区时，都会被分配一个offset，它是消息在此分区中的唯一编号，Kafka通过offset保证消息在分区内的顺序。<br><img src="%E9%80%BB%E8%BE%91Partition1.png" alt></p><h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><p>  分区在逻辑上对应一个Log，当生产者将消息写入分区时，实际上是写入到分区对应的Log中。Log是一个逻辑概念，可以对应到磁盘上的一个目录。Log由多个Segment组成，每个Segment对应一个日志文件和索引文件。<br><img src="partition%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt></p><h3 id="保留策略-Retention-Policy-和日志压缩-Log-Compaction"><a href="#保留策略-Retention-Policy-和日志压缩-Log-Compaction" class="headerlink" title="保留策略(Retention Policy)和日志压缩(Log Compaction)"></a>保留策略(Retention Policy)和日志压缩(Log Compaction)</h3><p>  一种是设置消息的保留时间，另一种是设置日志文件大小阈值。Kafka后台启动线程，定期将相同的key进行合并。</p><h3 id="Replica"><a href="#Replica" class="headerlink" title="Replica"></a>Replica</h3><p>  每个Partition可以有多个副本，所有的读写请求都由选举出的Leader副本处理，其他都作为Follower副本，Follower副本仅仅是从Leader副本处把数据拉取到本地，同步更新到自己的Log中。<br><img src="%E5%89%AF%E6%9C%AC.png" alt></p><h3 id="ISR集合"><a href="#ISR集合" class="headerlink" title="ISR集合"></a>ISR集合</h3><p>  ISR集合是由Leader副本管理的， 表示的是目前可用(alive)且消息量与Leader相差不多的副本集合，是整个副本集合的一个子集。</p><h3 id="HW-amp-LEO"><a href="#HW-amp-LEO" class="headerlink" title="HW &amp; LEO"></a>HW &amp; LEO</h3><p>  HW（High Watermark）是由Leader副本管理的，HW之后的消息对消费者不可见。当ISR集合中的全部Follower副本都拉取HW指定消息进行同步之后，Leader副本递增HW的值。<br>  LEO（Log End Offset）是所有副本都会管理的一个offset标记，指向追加到当前副本的最后一个消息的offset。<br><img src="HW_LEO_1.png" alt><br><img src="HW_LEO_2.png" alt></p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>  一个单独的Kafka Server就是一个Broker。Broker的主要工作就是接收生产者发送的消息，分配offset，之后保存到磁盘；同时接收消费者、其他Broker的请求，根据请求类型进行相应处理并返回响应。一般生产环境中，一个Broker独占一台物理机。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>  Controller是Kafka集群的指挥中心，而其他Broker则听从Controller指挥实现相应地功能。Controller负责管理分区的状态、管理每个分区的副本状态、监听Zookeeper中的数据变化等工作。当Leader Controller出现故障时则重新选举新的Controller。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>  生产者的主要工作是生产消息，并将消息按照一定的规则推送到Topic。选择分区的规则可以有多种，根据消息的key的Hash值选择分区，或按序轮询全部分区的方式，或自定义路由规则。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>  消费者的主要工作是从Topic拉取消息，并对消息进行消费。每个消费者消费到Partition的哪个位置（offset）的相关信息，是Consumer自己维护的。<br><img src="Consumer.png" alt></p><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>  在Kafka中，多个Consumer可以组成一个Consumer Group，一个Consumer只能属于一个Consumer Group。<br><img src="Consumer_Group.png" alt></p><h2 id="Broker模块功能"><a href="#Broker模块功能" class="headerlink" title="Broker模块功能"></a>Broker模块功能</h2><p>Kafka源码包结构：<br><img src="Kafka%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84.png" alt></p><p>Kafka源码组成：<br><img src="Kafka%E6%BA%90%E7%A0%81%E7%BB%84%E6%88%90.png" alt></p><h3 id="LogManager"><a href="#LogManager" class="headerlink" title="LogManager"></a>LogManager</h3><p>定位LogSegment：<br><img src="%E5%AE%9A%E4%BD%8DLogSegment.png" alt></p><p>定位index项及position：<br><img src="%E5%AE%9A%E4%BD%8Dindex%E9%A1%B9%E5%8F%8Aposition.png" alt></p><p>LogManager模块实现：<br><img src="LogManager%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0.png" alt></p><p>此模块中的定时线程任务：</p><ol><li>kafka-log-retention</li></ol><p>负责LogSegment的清理工作，一是LogSegment的存活时长log.retention.hours，二是Log的大小log.retention.bytes。</p><ol start="2"><li>kafka-log-flusher</li></ol><p>定时刷写页面缓存中的日志到磁盘。log.flush.interval.messages，log.flush.interval.ms</p><p><img src="%E5%88%B7%E5%86%99%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%97%A5%E5%BF%97%E5%88%B0%E7%A3%81%E7%9B%98.png" alt></p><ol start="3"><li>kafka-recovery-point-checkpoint</li></ol><p>定时将所有数据目录的所有日志的检查点写到“recovery-point-offset-checkpoint”文件中。检查点是指日志已经刷新到磁盘的位置，用于故障恢复。</p><ol start="4"><li>Cleaner</li></ol><p>activeSegment不参与。 log.clenear.enable </p><p><img src="%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9clean%E4%B8%8Edirty%E9%83%A8%E5%88%86%E5%88%92%E5%88%86.png" alt></p><p>Clean部分表示已经被压缩过的部分，dirty部分表示未压缩的部分。“迫切程度”是通过cleanableRation(ditry部分占整个Log的比例)决定的。</p><h3 id="ReplicaManager"><a href="#ReplicaManager" class="headerlink" title="ReplicaManager"></a>ReplicaManager</h3><p><img src="ReplicaManager%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0.png" alt></p><h3 id="KafkaController"><a href="#KafkaController" class="headerlink" title="KafkaController"></a>KafkaController</h3><p>Kafka在zookeeper上记录的信息：<br><img src="kafka_on_zookeeper.png" alt></p><ul><li>/brokers/ids/[id]:可用broker的id</li><li>/brokers/topics/[topic]/partitions:topic的分区以及AR</li><li>/brokers/topics/[topic]/partitions/[partition_id]/state:分区的Leader、ISR等</li><li>/controller_epoch:Controller Leader的选举次数</li><li>/controller:当前Controller Leader的id</li><li>/admin/reassign_partitions:需要进行副本重新分配的分区</li><li>/admin/preferred_replica_election:需要进行“优先副本”选举的分区</li><li>/admin/delete_topics:待删除的Topic</li><li>/isr_change_notification:ISR集合发生变化的分区</li><li>/config: 配置信息</li></ul><p>KafkaController模块实现：<br><img src="KafkaController%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0.png" alt></p><h3 id="GroupCoordinator"><a href="#GroupCoordinator" class="headerlink" title="GroupCoordinator"></a>GroupCoordinator</h3><p>ConsumerCoordinator的实现：<br><img src="ConsumerCoordinator%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt></p><p>GroupCoordinator的实现：<br><img src="GroupCoordinator%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt></p><p>Consumer加入Consumer Group的过程：</p><ol><li><p>查找GroupCoordinator<br><img src="%E6%9F%A5%E6%89%BEGroupCoordinator.png" alt></p></li><li><p>发送JoinGroupRequest<br><img src="%E5%8F%91%E9%80%81JoinGroupRequest.png" alt></p></li><li><p>发送SyncGroupRequest<br><img src="%E5%8F%91%E9%80%81SyncGroupRequest.png" alt></p></li></ol><ul><li><p>问题1：集群规模大，KafkaConsumer数量多导致频繁Rebalance<br>解决：0.11.0版本中添加了” group.initial.rebalance.delay.ms”配置，让GroupCoordinator推迟空消费组接收到成员加入请求后本应立即开启的rebalance。</p></li><li><p>问题2：Kafka0.10.0版本的Consumer心跳和next接口在同一个线程中，如果处理时间长，会导致超时<br>解决：0.10.1版本中在ConsumerCoordinator中添加了单独的HeartbeatThread线程。</p></li></ul><h2 id="网络层实现"><a href="#网络层实现" class="headerlink" title="网络层实现"></a>网络层实现</h2><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>选择器Selector是SelectableChannel的多路复用器，可以同时监控多个SelectableChannel的IO状况，即利用Selector可使一个单独的线程管理多个SelectableChannel，SelectableChannel设置为非阻塞。服务端为ServerSocketChannel，客户端为SocketChannel。</p><p><img src="Selector.png" alt></p><p>通道使用register（Selector sel，int ops）方法将通道注册到选择器，第二个参数指定监听的事件类型。<br>SelectionKey.OP_READ          (1)        读<br>SelectionKey.OP_WRITE        (4)         写<br>SelectionKey.OP_CONNECT   (8)         连接<br>SelectionKey.OP_ACCEPT      (16)       接收</p><p>Selector.open()                创建一个Selector<br>selector.select()               阻塞等待监听的事件就绪，返回大于0说明有事件就绪<br>selector.selectedKeys()   获得就绪的事件，使用其iterator遍历SelectionKey，根据key判断事件类型<br>                                                 key.isAcceptable()、key.isReadable()，处理完移除<br>wakeUp()                          唤醒由于调用select()方法而阻塞的线程</p><h3 id="网络线程模型"><a href="#网络线程模型" class="headerlink" title="网络线程模型"></a>网络线程模型</h3><ul><li><p>broker端网络线程模型：<br><img src="broker%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt></p></li><li><p>Reactor单线程模型：</p></li></ul><p><img src="Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt></p><ul><li>Reactor多线程模型：</li></ul><p><img src="Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt></p><ul><li>主从Reactor多线程模型：</li></ul><p><img src="%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt></p><ul><li><p>与Netty网络线程模型的对比：<br>Netty使用的是Reactor多线程模型：因为服务器端的 ServerSocketChannel 只绑定到了 bossGroup 中的一个线程, 因此在调用 Java NIO 的 Selector.select() 处理客户端的连接请求时, 实际上是在一个线程中的；而且workerGroup必须创建。<br>Netty服务器端需要绑定多个端口时，才会用到主从Reactor多线程模型。<br>Kafka网络层默认也是使用Reactor多线程模型，当”listeners”配置多个，监听不同的端口时，才用到主从Reactor多线程模型。<br>Kafka网络层有独立的Handler处理线程池，而Netty的业务处理是在work线程调用的Handler中完成。</p></li><li><p>Kafka新老版本网络模型对比</p></li></ul><p><img src="Kafka%E6%96%B0%E8%80%81%E7%89%88%E6%9C%AC%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.png" alt></p><h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><ul><li>V1 Message &amp; Message Set</li></ul><p><img src="V1_Message.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">V1的消息格式：</span><br><span class="line">也叫“浅层shallow消息”</span><br><span class="line">CRC：4字节，消息的校验码</span><br><span class="line">magic: 1字节，魔数标识，与消息格式有关，取值为0或1。当magic为0时，消息的offset使用绝对offset且 消息格式中没有timestamp部分；当magic为1时，消息的offset使用相对offset且消息格式中存在timestamp部分。</span><br><span class="line">attributes:1字节，消息的属性。其中第0-2位的组合表示使用的压缩类型，0表示无压缩，1表示gzip压缩，2表示snappy压缩，3表示lz4压缩。第3位表示时间戳类型，0表示创建时间，1表示追加时间。</span><br><span class="line">timestamp：时间戳。</span><br><span class="line">key length：消息key的长度。</span><br><span class="line">key: 消息的key。</span><br><span class="line">value length：消息的value长度。</span><br><span class="line">value：消息的value。</span><br><span class="line"></span><br><span class="line">V1消息长度举例：</span><br><span class="line">    消息头部开销为22字节，即消息的长度至少为22字节。</span><br><span class="line">    假设有一条Kafka消息，key是“key”，value是“hello”，那么key的长度就是3，value的长度就是5，因此这条Kafka消息需要占用22 + 3 + 5 = 30字节；</span><br><span class="line">    假设另一条Kafka消息未指定key，而value依然是“hello”，那么Kafka会往key长度字段中写入-1表明key是空，因而不再需要保存key信息，故总的消息长度= 22 + 5 = 27字节。</span><br><span class="line"></span><br><span class="line">V1的消息集合：</span><br><span class="line">offset：保存浅层消息的位移</span><br><span class="line">size：浅层消息的字节数</span><br><span class="line"></span><br><span class="line">V1消息集合长度举例：</span><br><span class="line">    计算消息集合大小，还是拿之前的两条Kafka消息为例。第一条消息被封装进一个消息集合，那么该消息集合总的长度 = 12 + 30 = 42字节，而包含第二条未指定key消息的消息集合总长度 = 12 + 27 = 39字节。此时，两条消息总共占81字节。</span><br></pre></td></tr></table></figure><ul><li>V2 Record &amp; RecordBatch</li></ul><p><img src="V2_Record.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">V2的消息格式：</span><br><span class="line">length:消息总长度。直接计算出消息的总长度并保存在第一个字段中，而不需要像v1版本时每次需要重新计算。这样做的好处在于提升解序列化的效率——拿到总长度后，Kafka可以直接new出一个等长度的ByteBuffer，然后装填各个字段。同时有了这个总长度，在遍历消息时可以实现快速地跳跃，省去了很多copy的工作。</span><br><span class="line">attributes: int8</span><br><span class="line">    bit 0~7: unused</span><br><span class="line">timestampDelta: varint 消息时间戳与所属record batch起始时间戳的差值，保存差值可以进一步节省消息字节数</span><br><span class="line">offsetDelta: varint 消息位移与所属record batch起始位移的差值，保存差值可以进一步节省消息字节数</span><br><span class="line">keyLength: varint</span><br><span class="line">key: byte[]</span><br><span class="line">valueLen: varint</span><br><span class="line">value: byte[]</span><br><span class="line">Headers =&gt; [Header]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">headerKeyLength: varint</span><br><span class="line">headerKey: String</span><br><span class="line">headerValueLength: varint</span><br><span class="line">Value: byte[]</span><br><span class="line">v2版本不在对每条消息执行CRC校验，而是针对整个batch</span><br><span class="line">v2版本的属性字节不再使用，原先保存在属性字段中的诸如压缩类型、时间戳类型等信息都统一保存在外层的batch中</span><br><span class="line">查看MemoryRecordsBuilder.writeDefaultBatchHeader()方法封装RecordBatch</span><br><span class="line">再调用DefaultRecordBatch.writeHeader()方法</span><br><span class="line"></span><br><span class="line">V2的消息长度举例：</span><br><span class="line">    假设这条Kafka消息的key是“key”，value是“hello”，同时假设这是batch中的第一条消息，因此时间戳增量和位移增量都是0，另外我们还假设没有指定任何header，因此header数组个数是0。结合上图我们可以计算这条消息的长度 = 总长度值占用的字节数 + 1 + 1 + 1 + 1 + 3 + 1 + 5 + 1 =  总长度值占用的字节数 + 14，由于14小于64，因此总长度值只需1个字节，故消息总长度是15字节。同时消息的第一个字节保存的值就是15。</span><br><span class="line"></span><br><span class="line">V2的消息集合：</span><br><span class="line">baseOffset: int64   起始位移</span><br><span class="line">batchLength: int32  RecordBatch总长度</span><br><span class="line">partitionLeaderEpoch: int32  分区leader版本号</span><br><span class="line">magic: int8 (current magic value is 2)  版本</span><br><span class="line">crc: int32    crc被移动到batch这一层，而非消息这一层</span><br><span class="line">attributes: int16</span><br><span class="line">    bit 0~2:</span><br><span class="line">        0: no compression</span><br><span class="line">        1: gzip</span><br><span class="line">        2: snappy</span><br><span class="line">        3: lz4</span><br><span class="line">    bit 3: timestampType</span><br><span class="line">    bit 4: isTransactional (0 means not transactional)</span><br><span class="line">    bit 5: isControlBatch (0 means not a control batch)</span><br><span class="line">    bit 6~15: unused</span><br><span class="line">lastOffsetDelta: int32   最大唯一增量</span><br><span class="line">firstTimestamp: int64    起始时间戳</span><br><span class="line">maxTimestamp: int64      最大时间戳</span><br><span class="line">producerId: int64        </span><br><span class="line">producerEpoch: int16</span><br><span class="line">baseSequence: int32</span><br><span class="line">records: [Record]</span><br><span class="line"></span><br><span class="line">V2消息集合长度举例：</span><br><span class="line">   和v2版本一样，我们来看下如何计算消息集合大小，还是以上面的两条Kafka消息为例。第一条消息被封装进一个batch，那么该batch总的长度 = 61 + 15 = 76字节。</span><br></pre></td></tr></table></figure><ul><li>二者比较<br>从上面的情况来看，似乎V2占用的磁盘空间反而增加了，这是因为我们测试的时候，Producer向Kafka一次发送的batch中只包含一条消息。如果我们改用java API程序来批量发送消息的话，我们就会发现两者的不同。在未有任何调优的情况下，v2版本消息格式在一定程度上减少了网络IO和磁盘IO的开销。展示那两张性能对比图。</li></ul><h3 id="Producer客户端"><a href="#Producer客户端" class="headerlink" title="Producer客户端"></a>Producer客户端</h3><p>Producer java客户端实现：<br><img src="Producer%E5%86%99%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><p>Producer客户端与broker端交互的协议格式：<br><img src="Producer%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8Ebroker%E7%AB%AF%E4%BA%A4%E4%BA%92%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png" alt></p><p>请求数据从生产者发送到服务端的流转过程：<br><img src="%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E4%BB%8E%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B.png" alt></p><h2 id="Delay机制"><a href="#Delay机制" class="headerlink" title="Delay机制"></a>Delay机制</h2><h3 id="TimingWheel"><a href="#TimingWheel" class="headerlink" title="TimingWheel"></a>TimingWheel</h3><p>DelayQueue本质上是封装了一个PriorityQueue。PriorityQueue内部使用最小堆来实现排序队列。最小堆在插入和获取时，时间复杂度随着DelayQueue中的元素个数呈对数级别增长，都是O(logn)。Kafka这类分布式框架有大量延迟操作并且对性能要求高， DelayQueue不能满足Kafka的性能要求，因此Kafka字节实现了时间轮。</p><p>TimingWheel：底层使用数组实现，数组中的每个元素存放一个TimerTaskList对象，同一个TimerTaskList中的任务到期时间相近，但不一定相同。expiration记录整个TimerTaskList的超时时间，expirationMs记录TimerTask的超时时间戳。</p><p>TimingWheel时间格数据结构：<br><img src="TimingWheel%E6%97%B6%E9%97%B4%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt></p><ul><li>到期时间和bucket选择</li></ul><p><img src="%E5%88%B0%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8Cbucket%E9%80%89%E6%8B%A9.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">virtualId = expiration/tickMs</span><br><span class="line">bucket = virtualId%wheelSize              ----- 计算延时任务的桶号</span><br><span class="line">bucket.expiration = virtualId*tickMs  ----- 计算桶的到期时间</span><br><span class="line">时间轮的expiration范围 = [currentTime+tickMs , currentTime+interval]</span><br></pre></td></tr></table></figure><ul><li>单层时间轮添加任务及执行过程</li></ul><p><img src="%E5%8D%95%E5%B1%82%E6%97%B6%E9%97%B4%E8%BD%AE%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%E5%8F%8A%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">外部的Purgatory添加任务，Repear线程轮询一次timeoutMs=200ms,</span><br><span class="line">加入A、B、C、D4个任务，到期时间戳：[A=0s,B=1s,C=1s,D=3s]，</span><br><span class="line">currentTime=0s，tickMs=1s，wheelSize=8，interval=8</span><br></pre></td></tr></table></figure><ul><li>多层时间轮的任务流转过程</li></ul><p><img src="%E5%A4%9A%E5%B1%82%E6%97%B6%E9%97%B4%E8%BD%AE%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%B5%81%E8%BD%AC%E8%BF%87%E7%A8%8B.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设有两个时间轮，分别为Level0、Level1</span><br><span class="line">Level0 ： currentTime=Time0，tickMs=1s，wheelSize=8，interval=8s</span><br><span class="line">Level1 ： currentTime=Time0，tickMs=8s，wheelSize=8，interval=64s</span><br><span class="line">加入了⑦⑧⑨三个任务，任务⑦在Level0的7-8之间，任务⑧⑨在Level1的8-16之间</span><br><span class="line"></span><br><span class="line">currentTime=Time7</span><br><span class="line">Level0 的指针指向了7~8之间，任务⑦到期</span><br><span class="line">Level1 的指针还是没有变化</span><br><span class="line"></span><br><span class="line">currentTime=Time8</span><br><span class="line">Level0 的指针移动到了8~9之间</span><br><span class="line">Level1 的指针移动到了8~16之间，任务⑧⑨到期，从Level1弹出，重新添加到低层级的更细粒度的Level0中执行</span><br></pre></td></tr></table></figure><h3 id="DelayedOperation组件"><a href="#DelayedOperation组件" class="headerlink" title="DelayedOperation组件"></a>DelayedOperation组件</h3><p>DelayedOperationPurgatory组件实现：<br><img src="DelayedOperationPurgatory%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0.png" alt></p><p>DelayedProduce：<br><img src="DelayedProduce.png" alt></p><p>DelayedFetch：<br><img src="DelayedFetch.png" alt></p><p>DelayedProduce和DelayedFetch之间的关联：在处理ProduceRequest过程中可能会向Log中添加数据，可能会后移Leader副本的LEO，Follower副本就可以读取到足量的数据（FetchRequest的min_bytes），所以会尝试DelayedFetch；在处理来自Follower副本的FetchRequest过程中，可能会后移HW，所以会尝试完成DelayedProduce（ProduceRequest的acks为-1），这样两者可以很好地协同工作了。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Kafka实现高吞吐的原因？"><a href="#Kafka实现高吞吐的原因？" class="headerlink" title="Kafka实现高吞吐的原因？"></a>Kafka实现高吞吐的原因？</h3><ul><li>读写文件依赖OS文件系统的页缓存，而不是在JVM内部缓存数据，利用OS来缓存，内存利用率高</li><li>sendfile技术（零拷贝），避免了传统网络IO四步流程</li><li>支持End-to-End的批量发送与压缩发送</li><li>顺序IO以及常量时间get、put消息，时间轮数据结构</li><li>Partition 可以很好的横向扩展和提供高并发处理</li></ul><h3 id="消息中间件的比较选型？"><a href="#消息中间件的比较选型？" class="headerlink" title="消息中间件的比较选型？"></a>消息中间件的比较选型？</h3><p><a href="http://xhrong.github.io/2018/06/13/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90%E4%B8%8E%E9%80%89%E5%9E%8B%E5%BB%BA%E8%AE%AE/" target="_blank" rel="noopener"></a></p><p><a href="https://cloud.tencent.com/developer/article/1460984" target="_blank" rel="noopener"></a></p><h3 id="kafka中副本的概念？"><a href="#kafka中副本的概念？" class="headerlink" title="kafka中副本的概念？"></a>kafka中副本的概念？</h3><h3 id="kafka副本如何进行leader选举？"><a href="#kafka副本如何进行leader选举？" class="headerlink" title="kafka副本如何进行leader选举？"></a>kafka副本如何进行leader选举？</h3><h3 id="kafka中consumer-group与consumer的关系？新加入一个consumer后，kafka内部如何做rebalance的？"><a href="#kafka中consumer-group与consumer的关系？新加入一个consumer后，kafka内部如何做rebalance的？" class="headerlink" title="kafka中consumer group与consumer的关系？新加入一个consumer后，kafka内部如何做rebalance的？"></a>kafka中consumer group与consumer的关系？新加入一个consumer后，kafka内部如何做rebalance的？</h3><h3 id="kafka的事务实现？"><a href="#kafka的事务实现？" class="headerlink" title="kafka的事务实现？"></a>kafka的事务实现？</h3><h3 id="Kafka怎样保证不重复消费消息？"><a href="#Kafka怎样保证不重复消费消息？" class="headerlink" title="Kafka怎样保证不重复消费消息？"></a>Kafka怎样保证不重复消费消息？</h3><p>此问题其实等价于保证消息队列消费的幂等性</p><p>主要需要结合实际业务来操作:</p><p>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。<br>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。<br>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。<br>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</p><h3 id="Kafka怎样保证数据不丢失，不重复？"><a href="#Kafka怎样保证数据不丢失，不重复？" class="headerlink" title="Kafka怎样保证数据不丢失，不重复？"></a>Kafka怎样保证数据不丢失，不重复？</h3><ul><li><p>关闭自动提交offset</p></li><li><p>给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</p></li><li><p>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</p></li><li><p>在 producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。</p></li><li><p>在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。</p></li></ul><h3 id="Kafka多数据中心部署灾备？"><a href="#Kafka多数据中心部署灾备？" class="headerlink" title="Kafka多数据中心部署灾备？"></a>Kafka多数据中心部署灾备？</h3><p>一个Kafka数据中心由于灾难性硬件故障、软件故障、停电 – 导致一个装有Apache Kafka集群的数据中心完全失效。不过，另一个数据中心的Kafka继续运行中，它已经拥有原始数据中心的数据副本，这些数据是从相同topic上复制过来的。客户端应用程序从故障集群切换到正在运行的集群，并根据在原始数据中心中停止的位置自动恢复在新数据中心的数据消费。企业最大限度地减少灾难导致的停机时间和数据丢失，并继续运行它们的任务关键型应用程序。</p><p>采取三项措施来进行灾难规划：</p><ul><li><p>设计多数据中心解决方案</p></li><li><p>制定故障转移和故障恢复手册</p></li><li><p>多测试</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将全局介绍 Kafka 的整体架构。&lt;/p&gt;
    
    </summary>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2020/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/10/设计模式/</id>
    <published>2020-02-10T05:37:38.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Java开发中常见的设计模式。</p><p>参考：<br>《设计模式之禅》</p><a id="more"></a><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><h3 id="创造类"><a href="#创造类" class="headerlink" title="创造类"></a>创造类</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><img src="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt></p><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双重检测"><a href="#双重检测" class="headerlink" title="双重检测"></a>双重检测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// Single Checked</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// Double checked</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SomeThing &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> Resource instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Resource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p><img src="%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p><img src="%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="模版方式模式"><a href="#模版方式模式" class="headerlink" title="模版方式模式"></a>模版方式模式</h4><p><img src="%E6%A8%A1%E7%89%88%E6%96%B9%E5%BC%8F%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p><img src="%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p><img src="%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" alt></p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><img src="%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt></p><h3 id="结构类"><a href="#结构类" class="headerlink" title="结构类"></a>结构类</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p><img src="%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p><img src="%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p><img src="%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p><img src="%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p><img src="%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h4><p><img src="%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F.png" alt></p><h3 id="行为类"><a href="#行为类" class="headerlink" title="行为类"></a>行为类</h3><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p><img src="%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><img src="%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><img src="%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><img src="%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><img src="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p><img src="%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p><img src="%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p><img src="%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt></p><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p><img src="%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt></p><h2 id="6大设计原则"><a href="#6大设计原则" class="headerlink" title="6大设计原则"></a>6大设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>Single Responsibility Principle，SRP，应该有且只有一个原因引起类的变更。一个方法尽可能做一件事<br>但是职责和变化原因是不可度量的，因项目而异，因环境而异。建议接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变更。</p><p>类的复杂性降低，实现什么职责都有清晰明确的定义。可读性提高，可维护性提高。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>LiskovSubstitutionPrinciple，LSP，所有引用基类的地方必须能透明地使用其子类的对象。</p><p>最佳实践：</p><ol><li>子类必须完全实现父类的方法</li><li>子类可以有自己的个性</li><li>覆盖或实现父类的方法时输入参数可以被放大，子类中方法的输入参数必须与父类中被覆写的方法的输入参数类型相同或者更宽松。</li><li>覆写或实现父类的方法时输出结果可以被缩小，父类的一个方法返回值是一个类型T，子类的相同方法（重载或覆写）的返回类型为S，要求S类型必须小于等于T类型。</li></ol><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>DependenceInversionPrinciple，DIP，模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；接口或抽象类不依赖于实现类；实现类依赖接口或抽象类。<br>精简的定义就是“面向接口编程”。</p><ol><li><p>构造函数传递依赖对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> ICar car;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">(ICar car)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Setter方法传递依赖对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line"><span class="comment">// 接口声明依赖对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> ICar car;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setter依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>最佳实践：</p><ol><li>每个类都尽量都有接口或抽象类，或者抽象类或接口两者都具备。</li><li>变量的表面类型尽量是接口或者抽象类。</li><li>任何类都不应该从具体类派生。</li><li>尽量不要覆写基类的方法，如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。</li><li>结合里氏替换原则使用。</li></ol><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型事物的描述，这是一种接口。<br>类接口（Class Interface），使用interface关键字定义的接口。</p><p>两种类型的美女定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGoodBodyGirl</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodLooking</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">niceFigure</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGreatTemperamentGirl</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">greatTemperament</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最标准的美女：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrettyGirl</span> <span class="keyword">implements</span> <span class="title">IGoodBodyGirl</span>,<span class="title">IGreatTemperamentGirl</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrettyGirl</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goodLooking</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"She has good looking."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">niceFigure</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"She has nice figure."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">greatTemperament</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"She has great temperament."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最佳实践：</p><ol><li>一个接口只服务于一个子模块或业务逻辑，通过业务逻辑压缩接口中的public方法，接口时长去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法。</li><li>已经被污染的接口，尽量去修改，若变更的风险较大，则采用适配器模式去转化处理。</li></ol><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>LawofDemeter，LoD，一个类应该对自己需要耦合或调用的类知道的最少，你的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的那么多public方法，我就调用这么多，其他我一概不管。<br>核心概念就是类间解藕，弱耦合，只有弱耦合了以后，类的复用率才可以提高。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>类、模块和函数应该对扩展开放，对修改关闭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍Java开发中常见的设计模式。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;《设计模式之禅》&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://yoursite.com/2020/02/10/Redis/"/>
    <id>http://yoursite.com/2020/02/10/Redis/</id>
    <published>2020-02-10T01:28:56.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将全局介绍 Redis 的整体架构。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h3 id="缓存与数据库双写一致性问题"><a href="#缓存与数据库双写一致性问题" class="headerlink" title="缓存与数据库双写一致性问题"></a>缓存与数据库双写一致性问题</h3><p>先更新数据库，再删除缓存（推荐）</p><p>通过读取binlog的方式，采用mq异步淘汰缓存，提供一个保障的重试机制!!!</p><p><a href="https://blog.csdn.net/hukaijun/article/details/81010475" target="_blank" rel="noopener"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将全局介绍 Redis 的整体架构。&lt;/p&gt;
    
    </summary>
    
      <category term="NoSql" scheme="http://yoursite.com/categories/NoSql/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://yoursite.com/2020/02/09/JVM/"/>
    <id>http://yoursite.com/2020/02/09/JVM/</id>
    <published>2020-02-09T09:14:38.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍JVM内存结构、类加载、GC、JVM调优等方面。《深入理解Java虚拟机: JVM高级特性与最佳实践》</p><a id="more"></a><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p>JVM = 类加载器(classloader) + 执行引擎(execution engine) + 运行时数据区域(runtime data area)</p><p><img src="JVM%E7%BB%84%E6%88%90.png" alt></p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些数据区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户新城的启动和结束而建立和销毁。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>思考：为什么要使用分代模型？？？</p><p>被所有线程共享，在虚拟机启动时创建，用来存放对象实例，几乎所有的对象实例都在这里分配内存。<br>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。<br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；新生代又有Eden空间、From Survivor空间、To Survivor空间三部分。<br>Java堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出OOM异常。</p><p><img src="%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt></p><table><thead><tr><th align="center">控制参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-Xms</td><td align="center">设置堆的最小空间大小</td></tr><tr><td align="center">-Xmx</td><td align="center">设置堆的最大空间大小</td></tr><tr><td align="center">-XX:NewSize</td><td align="center">设置新生代最小空间大小</td></tr><tr><td align="center">-XX:MaxNewSize</td><td align="center">设置新生代最大空间大小</td></tr><tr><td align="center">-Xss</td><td align="center">设置每个线程的堆栈大小</td></tr></tbody></table><h5 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h5><p>有将近98%的对象都是朝生夕死，所以针对这一情况，对象会在新生代Eden中进行分配，当Eden区没有足够空间的时候，虚拟机会触发Minor GC。Minor GC的回收速度很快，通过Minor GC后，Eden区会被清空。Eden区的绝大部分对象在这个时候都会被回收，剩下的那些无需被回收的对象会被放到Survior的from区，如果from区放不下就会直接被放到Old区。<br>等到再次触发Minor GC后会将Eden区和from区存活的对象放到to区。同样的，如果to区放不下就会被放到Old区。Minor GC会将年轻代的存活的对象在from区和to区来回存放。<br>在Survivor区中存活的对象，每经历一次Minor GC，对象的年龄就会加1，当长期存活的对象年龄达到一定数字 15 就会被移到老年代。<br>另外还有一个机制，虚拟机并不一定要对象年龄达到 15 岁时才会放入老年代，如果Survivor区中相同年龄对象的大小的和大于Suvivor空间的一半，年龄大于等于改年龄的对象就可以直接进入老年代，无需等待“成年”，类似于负载均衡。</p><h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>老年代占据着，2/3的堆内存空间，只有在Major GC时才会被清理，每次Major GC都会出发”Stop The World”。内存越大，STW的时间就越长，所以内存也不是越大越好。</p><p>除了年轻代那里的对象会进入老年代以外，还有一种特殊情况：大对象。大对象是指大量连续内存空间的对象，这部分对象不管其生命周期有多短，都会直接进入老年代。这样做的目的是为了避免在Eden区和两个Survivor区发生大量的内存复制。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>和Java堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OOM异常。<br>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载。<br>方法区逻辑上属于堆的一部分，为了与堆进行区分，通常又叫“非堆”。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池。运行时常量池是方法区的一部分。<br>Class文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。<br>除了在编译期生成的常量，还允许动态生成，例如String的intern（）。这部分常量也会被放入运行时常量池。</p><p>注：<br>在JDK1.7之前， HotSpot 使用永久代实现方法区；HotSpot 使用GC分代实现方法区带来了很大便利；<br>从JDK1.7开始 HotSpot 开始移除永久代。其中符号引用（Symbols）被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap 中。<br>在JDK1.8中，永久代已经被完全被元空间（Metaspace）取代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>线程私有，它的生命周期与线程相同。<br>虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈桢用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、double、long）、对象引用（reference），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置和returnAddress的类型。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><ul><li>局部变量表 - 存储方法参数，内部使用的变量</li><li>操作栈数 - 在变量进行存储时，需要进行入栈和出栈</li><li>动态链接 - 引用类型的指针</li><li>方法出口 - 方法的返回</li></ul><p>一段源程序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(hello());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成字节码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac demo.java</span><br></pre></td></tr></table></figure><p>对class文件反汇编：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c demo.class &gt; demo.txt</span><br></pre></td></tr></table></figure><p>通过文件编译工具来查看demo.txt的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Demo.java&quot;</span><br><span class="line">public class Demo &#123;</span><br><span class="line">  public Demo();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  static int hello();</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1 // 把第一个整型变量推到操作数栈</span><br><span class="line">       1: istore_0 // 让它出栈，并存储到局部变量表</span><br><span class="line">       2: iconst_2</span><br><span class="line">       3: istore_1</span><br><span class="line">       4: iload_0 // 加载第一个数据入操作数栈</span><br><span class="line">       5: iload_1 // 加载第二个数据入操作数栈</span><br><span class="line">       6: iadd // 将两个数相加，结束入操作数栈</span><br><span class="line">       7: istore_2 // 将结果出栈，存到局部变量表</span><br><span class="line">       8: iload_2 // 加载它入操作数栈</span><br><span class="line">       9: ireturn // 返回</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: invokestatic  #3                  // Method hello:()I</span><br><span class="line">       6: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       9: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该区域可能抛出以下异常：</p><ol><li>当线程请求的栈深度超过最大值，会抛出StackOverflowError异常</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryError异常</li></ol><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈非常类似，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机（Sun Hotpot）直接把本地方法栈和虚拟机栈合二为一。<br>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>线程私有，它的生命周期与线程相同。<br>可以看作是当前线程所执行的字节码的行号指示器。<br>在虚拟机的概念模型里，字节码解释器的工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，如：分支、循环、跳转、跳转、异常处理、线程恢复等基础功能。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器值则为空（undefined）。<br>程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，所以此区域不会出现OOM的情况。</p><h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致OOM异常。<br>在JDK1.4中新加入了NIO类，引入了一种基于 Channel 与 Buffer 的I/O方式，可以直接使用Native函数库分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制，也会抛出OOM异常。</p><h3 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol><li>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。</li><li>虚拟机将为新生对象分配内存：<br>Serial、ParNew带Compact过程 -&gt; 绝对规整的内存 -&gt; “指针碰撞” Bump the pointer<br>CMS Mark-Sweep -&gt; 不规整的内存 -&gt; “空闲列表” Free List<br>并发创建对象如何保证线程安全：<br>同步处理 -&gt; CAS + 失败重试<br>线程划分 -&gt; TLAB</li><li>虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</li></ol><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（InstanceData）和对齐填充（Padding）。</p><p><img src="Mark_Word.png" alt></p><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpotVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p><img src="%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt></p><p>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p><img src="%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt></p><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><h3 id="OOM-java示例"><a href="#OOM-java示例" class="headerlink" title="OOM java示例"></a>OOM java示例</h3><h4 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="HeapOOM.png" alt></p><h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><p>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xss 128k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        JavaVMStackSOF oom  = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span>+oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="JavaVMStackSOF.png" alt></p><p>创建线程导致内存溢出异常，每个线程都会分配到一定的栈容量，每个线程分配到的栈容量越大，可以创建的线程数就越少，建立线程时就容易把剩下的内存耗尽</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xss 2m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontstop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    dontstop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="JavaVMStackOOM.png" alt></p><h4 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h4><p>借助CGLib直接操作字节码运行生成大量的动态类，撑爆方法区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK7：-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * JDK8：-XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invoke(o, objects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="JavaMethodAreaOOM.png" alt></p><h2 id="GC算法-垃圾收集器"><a href="#GC算法-垃圾收集器" class="headerlink" title="GC算法 垃圾收集器"></a>GC算法 垃圾收集器</h2><h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><p>可达性分析：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p>GC Roots包括：</p><ul><li>虚拟机栈引用的对象</li><li>方法区中类静态属性实体引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p><img src="%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png" alt></p><ul><li>复制：将内存缩小为原来的一半，代价略高。YGC</li><li>标记-清除：标记和清除的两个过程效率都不高；产生大量不连续的内存碎片。OGC</li><li>标记整理：如果不想浪费50%的空间，又不想要内存碎片。OGC</li></ul><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾回收都发现只有少量对象死去，选用复制算法，只需要付出少量存活对象的肤质成本就可以完成收集。而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用标记清除或标记整理来回收。</p><p><img src="%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png" alt> </p><h4 id="垃圾回收器分类标准"><a href="#垃圾回收器分类标准" class="headerlink" title="垃圾回收器分类标准"></a>垃圾回收器分类标准</h4><table><thead><tr><th>分类标准</th><th>描述</th></tr></thead><tbody><tr><td>线程数</td><td>串行和并行，串行一次只使用一个线程进行垃圾回收，并行一次将开启多个线程同时进行垃圾回收。在并行能力较强的CPU上，使用并行垃圾回收器可以缩短GC的停顿时间</td></tr><tr><td>工作模式</td><td>并发式和独占式，并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间，独占式垃圾回收器(Stop the world)一旦运行，就停止应用程序的其他所有线程</td></tr><tr><td>碎片处理方式</td><td>压缩式和非压缩式，压缩式垃圾回收器在回收完成后，对存活对象进行压缩整理，消除回收后的碎片</td></tr><tr><td>工作的内存区间</td><td>新生代垃圾回收器和老年代垃圾回收器</td></tr></tbody></table><h4 id="Serial-新生代串行收集器"><a href="#Serial-新生代串行收集器" class="headerlink" title="Serial - 新生代串行收集器"></a>Serial - 新生代串行收集器</h4><p><img src="Serial-%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8.png" alt></p><p>使用单线程进行垃圾回收，独占式，使用-XX:+UseSerialGC指定使用，JVM在Client模式下默认垃圾收集器</p><p>复制算法</p><p>优点：实现简单，处理高效<br>缺点：Stop The World</p><p>[GC (Allocation Failure) [DefNew: 1937K-&gt;320K(3072K), 0.0021596 secs] 1937K-&gt;1645K(9920K), 0.0023185 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </p><h4 id="ParNew-新生代并行收集器"><a href="#ParNew-新生代并行收集器" class="headerlink" title="ParNew - 新生代并行收集器"></a>ParNew - 新生代并行收集器</h4><p><img src="ParNew-%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%B2%E8%A1%8C%E6%94%B6%E9%9B%86%E5%99%A8.png" alt></p><p>实现和Serial相同，仅将GC线程改成多线程，使用-XX:+UseParNewGC指定使用</p><p>复制算法</p><p>优点：在多CPU情况下优于Serial<br>缺点：Stop The World</p><p>GC线程数， -XX:+ParallelGCThreads<br>当CPU个数&lt;8，ParallelGCThreads = CPU个数<br>当CPU个数&gt;8，ParallelGCThreads = <code>3 + （（5*CPU个数/8））</code></p><p>[GC (Allocation Failure) [ParNew: 1937K-&gt;320K(3072K), 0.0023399 secs] 1937K-&gt;1656K(9920K), 0.0025229 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </p><p><img src="ParNew%E4%B8%8ESerial_Old%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt></p><h4 id="Parallel-Scavenge-新生代并行收集器"><a href="#Parallel-Scavenge-新生代并行收集器" class="headerlink" title="Parallel Scavenge - 新生代并行收集器"></a>Parallel Scavenge - 新生代并行收集器</h4><p>缺点：Stop The World</p><p>线程模型和ParNew相同，区别在于Parallel Scavenge收集器的目标是达到一个可以控制的吞吐量</p><p>复制算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC，指定使用 </span><br><span class="line">-XX:MaxGCPauseMillis，设置最大停顿时间，大于0的整数 </span><br><span class="line">-XX:GCTimeRatio，设置吞吐量大小，0~100整数，即运行用户代码时间 / 垃圾收集时间，默认值为99 </span><br><span class="line">-XX:+UseAdaptiveSizePolicy 自适应GC策略开关，在自适应模式下，新生代大小，survivor和eden区的比例、晋升老年代对象年龄等参数会被自动调整，以达到最合适的停顿时间，或最大吞吐量</span><br></pre></td></tr></table></figure><p>[GC (Allocation Failure) –[PSYoungGen: 1998K-&gt;1998K(2560K)] 8142K-&gt;</p><h4 id="Serial-Old（MSC）-老年代串行收集器"><a href="#Serial-Old（MSC）-老年代串行收集器" class="headerlink" title="Serial Old（MSC） - 老年代串行收集器"></a>Serial Old（MSC） - 老年代串行收集器</h4><p>缺点：Stop The World</p><p>使用标记-整理算法，和Serial一样是串行独占式回收器，可以和Serial、ParNew搭配使用。<br>缺点是停顿时间可能会比较长。</p><p>[Full GC (Allocation Failure) [Tenured: 33389K-&gt;33377K(34176K), 0.0128073 secs] 47726K-&gt;47714K(49536K), [Metaspace: 2501K-&gt;2501K(1056768K)], 0.0136535 secs] [Times: user =0.02 sys=0.00, real=0.01 secs] </p><h4 id="Parallel-Old-老年代并行收集器"><a href="#Parallel-Old-老年代并行收集器" class="headerlink" title="Parallel Old - 老年代并行收集器"></a>Parallel Old - 老年代并行收集器</h4><p>缺点：Stop The World</p><p>使用标记-整理算法，和Parallel Scavenge一样是并行多线程收集器，关注于吞吐量和CPU资源敏感的场合。<br>-XX:+UseParallelOldGC<br>缺点是停顿时间可能会比较长。</p><p>[Full GC (Ergonomics) [PSYoungGen: 1957K-&gt;1526K(2560K)] [ParOldGen: 6248K-&gt;6261K(7168K)] 8205K&gt;7788K(9728K), [Metaspace: 2496K-&gt;2496K(1056768K)], 0.0072201 secs] [Times : user=0.01 sys=0.00, real=0.01 secs] </p><p><img src="Parallel_Scavenge%E5%92%8CParallel_Old%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt></p><h4 id="CMS-老年代并发收集器"><a href="#CMS-老年代并发收集器" class="headerlink" title="CMS - 老年代并发收集器"></a>CMS - 老年代并发收集器</h4><p><img src="CMS-%E8%80%81%E5%B9%B4%E4%BB%A3%E5%B9%B6%E5%8F%91%E6%94%B6%E9%9B%86%E5%99%A8.png" alt></p><p>全称：Concurrent Mark Sweep<br>基于标记-清除算法<br>一种以获取最短停顿时间为目标的收集器。CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停，它的收集周期如下：</p><ol><li>初始标记<br>Stop The World<br>仅仅标记GC Roots内直接关联的对象。这个阶段速度很快。</li><li>并发标记<br>进行GC Tracing，从GC Roots开始对堆进行可达性分析，找出存活对象。</li><li>重新标记<br>修正并发期间由于用户进行运作导致的标记变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段稍长点，但远比并发标记的时间短。</li><li>并发清除<br>清除垃圾对象，标记-清除算法。</li><li>并发重置状态等待下一次CMS的触发</li></ol><p>在整个过程中，CMS 回收器的内存回收基本上和用户线程并发执行。</p><p>缺点：</p><ol><li>对CPU资源非常依赖。过分依赖于多线程环境，默认开启的线程数为<code>(CPU的数量*3)/4</code>，当CPU的数量小于4时，CMS对用户查询的影响将会很大，因为他们要分出一半的运算能力去执行回收器线程。</li><li>无法清除浮动垃圾。CMS并发清除阶段清除已标记的垃圾，但用户线程还在运行，因此会有新的垃圾产生，但是这部分垃圾未被标记，在下一次GC才能清除，因此被称为浮动垃圾。</li><li>垃圾收集结束后残余大量空间碎片。因为采用的标记-清除算法。</li></ol><h4 id="G1-整堆回收器"><a href="#G1-整堆回收器" class="headerlink" title="G1 - 整堆回收器"></a>G1 - 整堆回收器</h4><p>JDK1.7中正式投入使用，用于取代 CMS 的压缩回收器。</p><p>G1 首先将 堆 分为 大小相等 的  Region，避免 全区域 的垃圾回收。然后追踪每个 Region 垃圾 堆积的价值大小，在后台维护一个 优先列表，根据允许的回收时间优先回收价值最大的 Region。同时 G1采用 Remembered Set 来存放 Region 之间的 对象引用 ，其他回收器中的 新生代 与 老年代 之间的对象引用，从而避免 全堆扫描。</p><p><img src="G1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt></p><ol><li>初始标记<br>Stop The World<br>仅仅标记GC Roots内直接关联的对象。这个阶段速度很快。</li><li>并发标记<br>进行GC Tracing，从GC Roots开始对堆进行可达性分析，找出存活对象。</li><li>重新标记<br>修正并发期间由于用户进行运作导致的标记变动的那一部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段稍长点，但远比并发标记的时间短。</li><li>筛选回收<br>首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC停顿时间来制定回收计划。这个阶段可以与用户程序并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高回收效率。</li></ol><p>与其他 GC回收相比，G1具备以下4个特点：</p><ol><li><p>并行与并发<br>使用多个 CPU 来缩短 Stop-the-World 的 停顿时间，部分其他回收器需要停顿 Java 线程执行的 GC 动作，G1 回收器仍然可以通过 并发的方式 让 Java 程序继续执行。</p></li><li><p>分代回收<br>与其他回收器一样，分代概念 在 G1 中依然得以保留。虽然 G1 可以不需要 其他回收器配合 就能独立管理 整个GC堆，但它能够采用 不同的策略 去处理 新创建的对象 和 已经存活 一段时间、熬过多次 GC 的旧对象，以获取更好的回收效果。新生代 和 老年代 不再是 物理隔离，是多个 大小相等 的独立 Region。</p></li><li><p>空间整合<br>与 CMS 的 标记—清理 算法不同，G1 从 整体 来看是基于 标记—整理 算法实现的回收器。从 局部（两个 Region 之间）上来看是基于 复制算法 实现的。<br>但无论如何，这 两种算法 都意味着 G1 运作期间 不会产生内存空间碎片，回收后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象 时不会因为无法找到 连续内存空间 而提前触发 下一次 GC。</p></li><li><p>可预测的停顿<br>这是 G1 相对于 CMS 的另一大优势，降低停顿时间 是 G1 和 CMS 共同的关注点。G1 除了追求 低停顿 外，还能建立 可预测 的 停顿时间模型，能让使用者明确指定在一个 长度 为 M 毫秒的 时间片段 内，消耗在 垃圾回收 上的时间不得超过 N 毫秒。（后台维护的 优先列表，优先回收 价值大 的 Region）。</p></li></ol><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h3><p>类的加载是指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的借口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError），如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过一个类的全限定名来获取此定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表此类的java.lang.Class对象，作为方法区这个类的各种数据结构的访问入口</li></ol><p>加载.class文件的方式：</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip,jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>从Java源文件动态编译为.class文件</li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>目的在于确保class文件的字节流中包含的信息符合当前虚拟机的要求，不会危害虚拟机自身安全。</p><ol><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。是否有父类（除了java.lang.Object都应该有父类），是否继承了被final修饰的类，是否实现了接口中的所有方法。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：符号引用中通过字符串描述的全限定名是否能找到对应的类；符号引用中通过字符串描述的全限定名是否能找到对应的类；符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li></ol><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>进行内存分配，仅包括类变量（被static修饰的变量），而不包括实例变量。类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>；</span><br></pre></td></tr></table></figure><p>变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p><p>而用final修饰的static，在编译的时候就会分配了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value=<span class="number">123</span>；</span><br></pre></td></tr></table></figure><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在前一章讲解Class文件格式的时候已经出现过多次，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，就是一组符号来描述目标，可以是任何字面量。而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><ol><li>类或接口解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>到了初始化阶段，才真正执行类中定义的Java代码。初始化阶段是执行类构造器＜clinit＞()方法的过程。类加载的最后阶段，若该类有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量（如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化）。</p><p>初始化类中的静态变量，并执行类中的static代码、构造函数。<br>JVM规范严格定义了何时需要对类进行初始化：</p><ul><li>通过new 关键字、反射、clone、反序列化机制实例化对象时</li><li>调用类的静态方法时</li><li>使用类的静态字段或对其赋值时</li><li>通过反射调用类的方法时</li><li>初始化该类的子类时（初始化子类前其父类必须已经被初始化）</li><li>JVM启动时被标记为启动类的类（简单理解为具有main方法的类）</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例。</p><p><img src="%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.png" alt></p><p>站在Java虚拟机的角度，只存在两种不同的类加载器: 启动类加载器，是虚拟机自身的一部分；所有其它的类加载器，独立于虚拟机之外，并且全部继承自java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载器他的类。</p><ul><li>启动类加载器</li></ul><p>负责加载存放在 <code>JDK\jre\lib</code> 下，或被 <code>-Xbootclasspath</code> 参数指定的路径下的，并且能够被虚拟机识别的类库（如rt.jar，所有java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的，主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，</p><ul><li>扩展类加载器</li></ul><p>该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</p><ul><li>应用程序类加载器</li></ul><p>该加载器由sun.misc.Launcher$AppClassLoader实现，它负责加载用户类路径 <code>java -classpath</code> 或 <code>-Djava.class.path</code>所指定的类库，也就是我们经常用到的classpath路径。开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br>通过 <code>ClassLoader#getSystemClassLoader()</code> 可以直接获取到该类加载器。</p><p>类加载的几种方式：</p><ol><li>命令行启动应用时由JVM初始化加载</li><li>Class.forName()方式动态加载，将类.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块</li><li>ClassLoader.loadClass()方法动态加载，就是将.class文件中加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块</li><li>Class.forName(name,intialize,loader)，带参函数也可以控制是否加载static块，并且只有调用了newInstance()方法才调用构造函数，创建类的对象</li></ol><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父类加载器去完成，依次向上，因此，所有类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>当 AppClassLoader 加载一个class时，它首先不会自己去尝试加载这个类，而是被类加载请求委派给父类加载器 ExtClassLoader 去完成。<br>当 ExtClassLoader 加载一个class时，它首先不会自己去尝试加载这个类，而是被类加载请求委派给父类加载器 BootstrapClassLoader 去完成。<br>如果 BootstrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载<br>如果 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException</p><p>双亲委派模型的意义：<br>系统类防止内存中出现多份同样的字节码，避免类的重复加载<br>保证Java程序安全稳定运行，Java核心api中定义类型不会被随意替换</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil pid [interval] [count]</span><br><span class="line"></span><br><span class="line">jstat -gcutil 2764 250 20</span><br></pre></td></tr></table></figure><h4 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo: Java配置信息工具"></a>jinfo: Java配置信息工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jinfo -heap pid</span><br><span class="line"></span><br><span class="line">jinfo -flag CMSInitiatingOccupancyFraction pid : 查询参数值，-XX:CMSInitiatingOccupancyFraction=85</span><br></pre></td></tr></table></figure><h4 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live pid</span><br><span class="line"></span><br><span class="line">jmap  -dump:live,format=b,file=dump.hprof pid</span><br></pre></td></tr></table></figure><h4 id="jhat-虚拟机堆转储快照工具"><a href="#jhat-虚拟机堆转储快照工具" class="headerlink" title="jhat: 虚拟机堆转储快照工具"></a>jhat: 虚拟机堆转储快照工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat dump.hprof</span><br></pre></td></tr></table></figure><p>屏幕显示”Serverisready.”的提示后，用户在浏览器中键入<a href="http://localhost:7000/就可以看到分析结果。" target="_blank" rel="noopener">http://localhost:7000/就可以看到分析结果。</a></p><h4 id="jstack-Java堆栈跟踪工具"><a href="#jstack-Java堆栈跟踪工具" class="headerlink" title="jstack: Java堆栈跟踪工具"></a>jstack: Java堆栈跟踪工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l pid</span><br></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>JConsole</p><p>VisualVM</p><p>MAT </p><h3 id="GC参数调优"><a href="#GC参数调优" class="headerlink" title="GC参数调优"></a>GC参数调优</h3><ol><li><p>排除Cache内容过多的问题，如果Cache内容过多会导致JVM老年代容易被用满导致频繁GC，使用jstat命令查看GC情况</p></li><li><p>调整GC时间点<br>如果GC需要处理的内存量比较大，执行的时间也就比较长，STW时间也就更长。按照这个思路调整CMS启动的时间点，希望提早GC，也就是让GC变得更加频繁但是期望每次执行的时间较少。</p><p>-XX:+UseCMSInitiatingOccupancyOnly<br>-XX:+CMSInitiatingOccupancyFraction=50</p><p>在Old区使用了50%的时候触发GC，实验后发现GC的频率有所增加。</p></li><li><p>调整对象在年轻代中驻留的时间，尝试提升这些对象在年轻代GC时被销毁的概率，-XX:MaxTenuringThreshold=31</p></li><li><p>Full GC之前先再进行一次YGC</p><p>-XX:+ScavengeBeforeFullGC<br>-XX:+CMSScavengeBeforeRemark</p><p>Young区对象引用了Old区的对象，如果Old区进行清理之前不进行Young区清理就会导致Old区被Young区引用的对象无法释放</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍JVM内存结构、类加载、GC、JVM调优等方面。《深入理解Java虚拟机: JVM高级特性与最佳实践》&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Netty内存池化管理</title>
    <link href="http://yoursite.com/2020/02/09/Netty%E5%86%85%E5%AD%98%E6%B1%A0%E5%8C%96%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/09/Netty内存池化管理/</id>
    <published>2020-02-09T08:14:12.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Netty内存池化管理。</p><a id="more"></a><h2 id="Netty内存池化管理"><a href="#Netty内存池化管理" class="headerlink" title="Netty内存池化管理"></a>Netty内存池化管理</h2><p>参考：<a href="https://mp.weixin.qq.com/s/89P9ujogvvKGot9sB9XO4g" target="_blank" rel="noopener">一文读懂Netty的内存管理</a></p><h2 id="PooledBufferAllocator"><a href="#PooledBufferAllocator" class="headerlink" title="PooledBufferAllocator"></a>PooledBufferAllocator</h2><h3 id="PoolThreadCache"><a href="#PoolThreadCache" class="headerlink" title="PoolThreadCache"></a>PoolThreadCache</h3><p>Netty自己实现了类似LocalThread的类来充当线程缓存</p><p>PoolThreadLocalCache 继承自 FastThreadLocal</p><h3 id="JEMalloc分配算法"><a href="#JEMalloc分配算法" class="headerlink" title="JEMalloc分配算法"></a>JEMalloc分配算法</h3><p><a href="https://www.jianshu.com/p/15304cd63175" target="_blank" rel="noopener">JEMalloc分配算法</a></p><h3 id="PoolArena"><a href="#PoolArena" class="headerlink" title="PoolArena"></a>PoolArena</h3><p>Netty内存主要分为两种：DirectByteBuf 和 HeapByteBuf。Netty作为服务器架构技术，拥有大量的网络数据传输，当我们进行网络传输时，必须将数据拷贝至直接内存，合理利用好直接内存，<br>能够显著提高性能。</p><ul><li>Pool 和 Unpool的区别</li></ul><p>池化内存的管理方式是首先申请一大块内存，当使用完成释放后，再将该部分内存放入池子中，等待下一次的使用，这样的话，可以减少垃圾回收的次数，提高处理性能。<br>非池化内存就是普通的内存使用，需要时直接申请，释放时直接释放。目前netty针对pool做了大量的支持，这样内存使用直接交给了netty管理，减轻了直接内存回收的压力。</p><p>这样的话，内存分为4种： PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。Netty底层默认使用PoolDireBuf类型的内存，这些内存主要由PoolArena管理。</p><ul><li>PoolArena</li></ul><p>PoolArena作为Netty底层内存池核心管理类，主要原理是首先申请一些内存块，不同的成员变量来完成不同大小的内存块分配。下图描述了PoolArena最重要的成员变量：</p><p><img src="PoolArena%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt></p><p>Tiny解决 16b～498b 之间的内存分配，Small解决 512b~4kb 的内存分配，Normal解决 8kb～16mb 的内存分配。</p><ul><li>PoolArena的内存分配</li></ul><p>线程分配内存主要从两个地方分配：PoolThreadCache 和 PoolArena</p><p><img src="%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt></p><p>其中 PoolThreadCache 线程独享，PoolArena为几个线程共享。</p><p>Netty真正申请内存时的调用过程：</p><p><img src="PoolArena%E4%B8%AD%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><p>PoolArena.allocate() 分配内存主要考虑先尝试从缓存中，然后再尝试从PoolArena分配。Tiny 和 Small 的申请过程一样，以Tiny申请为例，具体过程如下：</p><p>1）对申请的内存进行规范化，就是说只能申请某些固定大小的内存，比如Tiny范围的是16b倍数的内存，Small为512b、1k、2k、4k 的内存，Normal为8k、16k … 16m</p><p>  范围的内存，始终是2的幂次方。申请的内存不足16b的，按照16b去申请。</p><p>2) 判断是否是小于8k的内存申请，若是申请Tiny|Small级别的内存：</p><p>  首先尝试从cache中申请，申请不到的话，接着会尝试从 tinySubPagePools 中申请，首先计算出该内存在 tinySubPagePools 中对应的下标。</p><p>  检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分配</p><p>  若没有可分配的内存, 则会进入allocateNormal进行分配</p><p>3）若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。</p><p>4）若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。</p><h3 id="PoolChunkList"><a href="#PoolChunkList" class="headerlink" title="PoolChunkList"></a>PoolChunkList</h3><p>对于在q050、q025、q000、qInit、q075这些PoolChunkList里申请内存的流程图如下：</p><p><img src="%E5%9C%A8PoolChunkList%E4%B8%AD%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98.png" alt></p><p>按照以上顺序，这样安排的考虑是：</p><p>将PoolChunk分配维持在较高的比例上</p><p>保存一些空闲较大的内存，以便大内存的分配</p><h3 id="PoolChunk"><a href="#PoolChunk" class="headerlink" title="PoolChunk"></a>PoolChunk</h3><h3 id="PoolSubpage"><a href="#PoolSubpage" class="headerlink" title="PoolSubpage"></a>PoolSubpage</h3><p>Netty中大于8k的内存都是通过PoolChunk来分配的，小于8k的内存是通过PoolSubpage分配的。当申请小于8k的内存时，会分配一个8k的叶子节点，若用不完的话，存在很大的浪费，所以通过</p><ul><li>双向链表</li></ul><p>添加节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void addToPool(PoolSubpage&lt;T&gt; head) &#123;</span><br><span class="line">    assert prev == null &amp;&amp; next == null;</span><br><span class="line">    prev = head;</span><br><span class="line">    next = head.next;</span><br><span class="line">    next.prev = this;</span><br><span class="line">    head.next = this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向列表的插入：</p><p><img src="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%9B%BE%E8%A7%A3.png" alt></p><p>第一步：首先找到插入位置，节点 s 将插入到节点 p 之前<br>第二步：将节点 s 的前驱指向节点 p 的前驱，即 s-&gt;prior = p-&gt;prior;<br>第三步：将节点 p 的前驱的后继指向节点 s 即 p-&gt;prior-&gt;next = s;<br>第四步：将节点 s 的后继指向节点 p 即 s-&gt;next = p;<br>第五步：将节点 p 的前驱指向节点 s 即 p-&gt;prior = s;</p><p>移除节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void removeFromPool() &#123;</span><br><span class="line">    assert prev != null &amp;&amp; next != null;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">    next = null;</span><br><span class="line">    prev = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向列表的删除：</p><p><img src="%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E5%9B%BE%E8%A7%A3.png" alt></p><p>第一步：找到即将被删除的节点 p<br>第二步：将 p 的前驱的后继指向 p 的后继，即 p-&gt;prior-&gt;next = p-&gt;next;<br>第三步：将 p 的后继的前驱指向 p 的前驱，即 p-&gt;next-&gt;prior = p-&gt;prior;<br>第四步：删除节点 p 即 delete p;</p><p>PoolSubpage 管理8k的内存，如下图：</p><p><img src="PoolSubpage%E6%9D%A5%E7%AE%A1%E7%90%868k%E7%9A%84%E5%86%85%E5%AD%98.png" alt></p><p>每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来。</p><p>1.首次请求Arena分配，Arena中的双向链表为空，不能分配；</p><p>2.传递给Chunk分配，Chunk找到一个空闲的Page，然后均等切分并加入到Arena链表中，最后分配满足要求的大小。<br>之后请求分配同样大小的内存，则直接在Arena中的PoolSubpage双向链表进行分配；如果链表中的节点都没有空间分配，则重复1步骤。</p><p>Netty使用一个long整型表示在 PoolSubpage 中的分配结果，高32位表示均等切分小块的块号，其中的低6位用来表示64位即一个long的分配信息，其余位用来表示long数组的索引。低32位表示所属Chunk号。</p><p>以下是PoolSubpage的init及allocate流程图:</p><p><img src="PoolSubpage%E7%9A%84init%E5%8F%8Aallocate%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>我们知道, 在使用IO传输数据时, 首先会将数据传输到堆外直接内存中, 然后才通过网络发送出去。这样的话, 数据多了次中间copy, 能否不经过copy而直接将数据发送出去呢, 其实是可以的, 存放的位置就是本文要讲的主角:DirectByteBuffer 。</p><p>JVM内存主要分为heap内存和堆外内存(一般我们也会称呼为直接内存), heap内存我们不用care, jvm能自动帮我们管理, 而堆外内存回收不受JVM GC控制, 因此, 堆外内存使用必须小心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍Netty内存池化管理。&lt;/p&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
  </entry>
  
  <entry>
    <title>Netty线程模型</title>
    <link href="http://yoursite.com/2020/02/09/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/02/09/Netty线程模型/</id>
    <published>2020-02-09T08:13:52.000Z</published>
    <updated>2020-04-05T09:14:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Netty的线程模型以及服务端、客户端启动、客户端接入等流程。</p><a id="more"></a><h2 id="Netty-Reactor"><a href="#Netty-Reactor" class="headerlink" title="Netty Reactor"></a>Netty Reactor</h2><p>![](Netty Reactor工作架构图.png)</p><h2 id="ServerBootstrap启动流程"><a href="#ServerBootstrap启动流程" class="headerlink" title="ServerBootstrap启动流程"></a>ServerBootstrap启动流程</h2><p><img src="bind%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><h2 id="Client接入流程"><a href="#Client接入流程" class="headerlink" title="Client接入流程"></a>Client接入流程</h2><p><img src="%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><h2 id="Bootstrap启动流程"><a href="#Bootstrap启动流程" class="headerlink" title="Bootstrap启动流程"></a>Bootstrap启动流程</h2><p><img src="Bootstrap%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt></p><h2 id="TCP粘包-拆包问题"><a href="#TCP粘包-拆包问题" class="headerlink" title="TCP粘包/拆包问题"></a>TCP粘包/拆包问题</h2><h3 id="TCP粘包-拆包的基础知识"><a href="#TCP粘包-拆包的基础知识" class="headerlink" title="TCP粘包/拆包的基础知识"></a>TCP粘包/拆包的基础知识</h3><p>TCP是一个”流”协议，在业务上认为，一个完整的包可能会被拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包/拆包问题。</p><p><img src="TCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98.png" alt></p><p>由于底层的TCP协议无法理解上层的业务数据，所以在底层不能保证数据包不被拆分和重组，这个问题只能通过上层的应用协议栈设计来解决：</p><ul><li>消息定长，不够补空格</li><li>在包尾增加回车换行符进行分割</li><li>将消息分为消息头和消息体，消息头中包含消息总长度或消息体长度的字段</li><li>更复杂的应用层协议</li></ul><h3 id="没考虑TCP粘包-拆包的问题案例"><a href="#没考虑TCP粘包-拆包的问题案例" class="headerlink" title="没考虑TCP粘包/拆包的问题案例"></a>没考虑TCP粘包/拆包的问题案例</h3><p>TCP粘包导致的读半包问题<br>查看example模块中的\ TimeServerTcpStickyException 和 TimeClientTcpStickyException:</p><p>服务端只收到2条消息，说明客户端发送的消息发生了TCP粘包：<br><img src="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AA%E6%94%B6%E5%88%B02%E6%9D%A1%E6%B6%88%E6%81%AF.png" alt></p><p>服务端只收到2条消息，因此只发送2条应答，但实际上客户端值收到一条包含2个”BAD ORDER”的消息，说明服务端返回的应答消息也发生了TCP粘包：<br><img src="%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%9F%E5%8F%AA%E6%94%B6%E5%88%B0%E4%B8%80%E6%9D%A1%E5%BA%94%E7%AD%94%E6%B6%88%E6%81%AF.png" alt></p><h3 id="使用Netty解决读半包问题"><a href="#使用Netty解决读半包问题" class="headerlink" title="使用Netty解决读半包问题"></a>使用Netty解决读半包问题</h3><p>为了解决TCP粘包/拆包导致的问题，Netty默认提供了多种编解码器用于处理半包。</p><p>查看example模块中的 TimeServerFixTcpStickyException 和 TimeClientFixTcpStickyException:</p><p>分别在服务端和客户端添加 LineBasedFrameDecoder 和 StringDecoder 解决问题。</p><p>服务端正常收到客户端的100次请求：<br><img src="%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%AD%A3%E5%B8%B8%E6%94%B6%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84100%E6%AC%A1%E8%AF%B7%E6%B1%82.png" alt></p><p>客户端正常收到服务端的100次应答消息：<br><img src="image/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%AD%A3%E5%B8%B8%E6%94%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84100%E6%AC%A1%E5%BA%94%E7%AD%94%E6%B6%88%E6%81%AF.png" alt="avatar"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Netty的消息可靠性机制"><a href="#Netty的消息可靠性机制" class="headerlink" title="Netty的消息可靠性机制"></a>Netty的消息可靠性机制</h3><ul><li><p>网络通信类故障</p><ol><li>客户端指定连接超时时间</li><li>TCP心跳机制</li><li>故障定制：客户端的断连重连机制，消息的缓存重发，接口日志中详细记录故障细节，运维相关功能，例如告警、触发邮件/短信等</li></ol></li></ul><h3 id="select、poll-与-epoll-的区别"><a href="#select、poll-与-epoll-的区别" class="headerlink" title="select、poll 与 epoll 的区别"></a>select、poll 与 epoll 的区别</h3><p>IO多路复用：I/O是指网络I/O,多路指多个TCP连接(即socket或者channel）,复用指复用一个或几个线程。意思说一个或一组线程处理多个TCP连接。最大优势是减少系统开销小，不必创建过多的进程/线程，也不必维护这些进程/线程。<br>　　IO多路复用使用两个系统调用(select/poll/epoll和recvfrom)，blocking IO只调用了recvfrom；select/poll/epoll 核心是可以同时处理多个connection，而不是更快，所以连接数不高的话，性能不一定比多线程+阻塞IO好,多路复用模型中，每一个socket，设置为non-blocking,阻塞是被select这个函数block，而不是被socket阻塞的。</p><h4 id="select机制"><a href="#select机制" class="headerlink" title="select机制"></a>select机制</h4><p>基本原理：<br>　　客户端操作服务器时就会产生这三种文件描述符(简称fd)：writefds(写)、readfds(读)、和exceptfds(异常)。select会阻塞住监视3类文件描述符，等有数据、可读、可写、出异常 或超时、就会返回；返回后通过遍历fdset整个数组来找到就绪的描述符fd，然后进行对应的IO操作。一个连接对应一个fd。<br>优点：<br>　　几乎在所有的平台上支持，跨平台支持性好<br>缺点：<br>　　由于是采用轮询方式全盘扫描，会随着文件描述符FD数量增多而性能下降。<br>　　每次调用 select()，需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)<br>　　默认单个进程打开的FD有限制是1024个，可修改宏定义，但是效率仍然慢。</p><p>select的调用过程如下：</p><p><img src="select%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</span><br><span class="line"></span><br><span class="line">（2）注册回调函数__pollwait</span><br><span class="line"></span><br><span class="line">（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</span><br><span class="line"></span><br><span class="line">（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</span><br><span class="line"></span><br><span class="line">（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</span><br><span class="line"></span><br><span class="line">（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</span><br><span class="line"></span><br><span class="line">（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</span><br><span class="line"></span><br><span class="line">（8）把fd_set从内核空间拷贝到用户空间。</span><br></pre></td></tr></table></figure><h4 id="poll机制"><a href="#poll机制" class="headerlink" title="poll机制"></a>poll机制</h4><p>　　基本原理与select一致，也是轮询+遍历；唯一的区别就是poll没有最大文件描述符限制（使用链表的方式存储fd），使用 pollfd 结构而不是 select 的 fd_set 结构。</p><h4 id="epoll机制"><a href="#epoll机制" class="headerlink" title="epoll机制"></a>epoll机制</h4><p>基本原理：<br>　　没有fd个数限制，用户态拷贝到内核态只需要一次，使用时间通知机制来触发。通过epoll_ctl注册fd，一旦fd就绪就会通过callback回调机制来激活对应fd，进行相关的io操作。<br>epoll之所以高性能是得益于它的三个函数<br>　　1)epoll_create()系统启动时，在Linux内核里面申请一个B+树结构文件系统，返回epoll对象，也是一个fd<br>　　2)epoll_ctl() 每新建一个连接，都通过该函数操作epoll对象，在这个对象里面修改添加删除对应的链接fd, 绑定一个callback函数<br>　　3)epoll_wait() 轮训所有的callback集合，并完成对应的IO操作<br>优点：<br>　　没fd这个限制，所支持的FD上限是操作系统的最大文件句柄数，1G内存大概支持10万个句柄<br>　　效率提高，使用回调通知而不是轮询的方式，不会随着FD数目的增加效率下降<br>　　内核和用户空间mmap同一块内存实现(mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间)</p><p>例子：100万个连接，里面有1万个连接是活跃，我们可以对比 select、poll、epoll 的性能表现<br>　　select：  不修改宏定义默认是1024,l则需要100w/1024=977个进程才可以支持 100万连接，会使得CPU性能特别的差。<br>　　poll：    没有最大文件描述符限制,100万个链接则需要100w个fd，遍历都响应不过来了，还有空间的拷贝消耗大量的资源。<br>　　epoll:    请求进来时就创建fd并绑定一个callback，主需要遍历1w个活跃连接的callback即可，即高效又不用内存拷贝。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍Netty的线程模型以及服务端、客户端启动、客户端接入等流程。&lt;/p&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
  </entry>
  
</feed>
